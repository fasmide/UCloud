@file:Suppress("RemoveRedundantBackticks", "FunctionName", "CascadeIf")

package dk.sdu.cloud
inline fun `dk_sdu_cloud_project_api_CreateProjectRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.CreateProjectRequest {
var title: String? = null
var parent: String? = null
var principalInvestigator: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"parent" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
parent = prop.element.value
} else { throw ParsingException("Wrong type for parent") }
}
"principalInvestigator" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
principalInvestigator = prop.element.value
} else { throw ParsingException("Wrong type for principalInvestigator") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.CreateProjectRequest(
title = title ?: throw ParsingException("Missing key 'title'"),
parent = parent,
principalInvestigator = principalInvestigator,
)
}
inline fun `dk_sdu_cloud_FindByStringId_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.FindByStringId {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.FindByStringId(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_CommonErrorMessage_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.CommonErrorMessage {
var why: String? = null
var errorCode: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"why" -> {
if (prop.element is JsonStreamElement.Text) {
why = prop.element.value
} else { throw ParsingException("Wrong type for why") }
}
"errorCode" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
errorCode = prop.element.value
} else { throw ParsingException("Wrong type for errorCode") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.CommonErrorMessage(
why = why ?: throw ParsingException("Missing key 'why'"),
errorCode = errorCode,
)
}
inline fun `dk_sdu_cloud_project_api_ViewMemberInProjectRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ViewMemberInProjectRequest {
var projectId: String? = null
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ViewMemberInProjectRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
username = username ?: throw ParsingException("Missing key 'username'"),
)
}
inline fun `dk_sdu_cloud_project_api_ViewMemberInProjectResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ViewMemberInProjectResponse {
var member: dk.sdu.cloud.project.api.ProjectMember? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"member" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
member = parseJson<dk.sdu.cloud.project.api.ProjectMember>(parser)
} else { throw ParsingException("Wrong type for member") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ViewMemberInProjectResponse(
member = member ?: throw ParsingException("Missing key 'member'"),
)
}
inline fun `dk_sdu_cloud_project_api_ProjectMember_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ProjectMember {
var username: String? = null
var role: dk.sdu.cloud.project.api.ProjectRole? = null
var memberOfAnyGroup: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
"role" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.project.api.ProjectRole>(parser)
} else { throw ParsingException("Wrong type for role") }
}
"memberOfAnyGroup" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
memberOfAnyGroup = prop.element.value
} else { throw ParsingException("Wrong type for memberOfAnyGroup") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ProjectMember(
username = username ?: throw ParsingException("Missing key 'username'"),
role = role ?: throw ParsingException("Missing key 'role'"),
memberOfAnyGroup = memberOfAnyGroup,
)
}
inline fun `dk_sdu_cloud_project_api_InviteRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.InviteRequest {
var projectId: String? = null
var usernames: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"usernames" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val usernamesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val usernamesElem: String
if (prop.element is JsonStreamElement.Text) {
usernamesElem = prop.element.value
} else { throw ParsingException("Wrong type for usernamesElem") }
usernamesList.add(usernamesElem)
} else { throw ParsingException("Wrong element type for usernames") }
}
usernames = usernamesList
} else { throw ParsingException("Wrong type for usernames") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.InviteRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
usernames = usernames ?: throw ParsingException("Missing key 'usernames'"),
)
}
inline fun `dk_sdu_cloud_project_api_AcceptInviteRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.AcceptInviteRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.AcceptInviteRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_project_api_RejectInviteRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.RejectInviteRequest {
var username: String? = null
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.RejectInviteRequest(
username = username,
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListIngoingInvitesRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListIngoingInvitesRequest {
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListIngoingInvitesRequest(
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun <reified T> `dk_sdu_cloud_Page_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.Page<T> {
var itemsInTotal: Int? = null
var itemsPerPage: Int? = null
var pageNumber: Int? = null
var items: List<T>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsInTotal" -> {
if (prop.element is JsonStreamElement.Number) {
itemsInTotal = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsInTotal") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"pageNumber" -> {
if (prop.element is JsonStreamElement.Number) {
pageNumber = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for pageNumber") }
}
"items" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val itemsList = ArrayList<T>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val itemsElem: T
if (prop.element is JsonStreamElement.ObjectStart) {
itemsElem = parseJson<T>(parser)
} else { throw ParsingException("Wrong type for itemsElem") }
itemsList.add(itemsElem)
} else { throw ParsingException("Wrong element type for items") }
}
items = itemsList
} else { throw ParsingException("Wrong type for items") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.Page(
itemsInTotal = itemsInTotal ?: throw ParsingException("Missing key 'itemsInTotal'"),
itemsPerPage = itemsPerPage ?: throw ParsingException("Missing key 'itemsPerPage'"),
pageNumber = pageNumber ?: throw ParsingException("Missing key 'pageNumber'"),
items = items ?: throw ParsingException("Missing key 'items'"),
)
}
inline fun `dk_sdu_cloud_project_api_IngoingInvite_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.IngoingInvite {
var project: String? = null
var title: String? = null
var invitedBy: String? = null
var timestamp: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"project" -> {
if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"invitedBy" -> {
if (prop.element is JsonStreamElement.Text) {
invitedBy = prop.element.value
} else { throw ParsingException("Wrong type for invitedBy") }
}
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.IngoingInvite(
project = project ?: throw ParsingException("Missing key 'project'"),
title = title ?: throw ParsingException("Missing key 'title'"),
invitedBy = invitedBy ?: throw ParsingException("Missing key 'invitedBy'"),
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListOutgoingInvitesRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListOutgoingInvitesRequest {
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListOutgoingInvitesRequest(
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_project_api_OutgoingInvite_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.OutgoingInvite {
var username: String? = null
var invitedBy: String? = null
var timestamp: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
"invitedBy" -> {
if (prop.element is JsonStreamElement.Text) {
invitedBy = prop.element.value
} else { throw ParsingException("Wrong type for invitedBy") }
}
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.OutgoingInvite(
username = username ?: throw ParsingException("Missing key 'username'"),
invitedBy = invitedBy ?: throw ParsingException("Missing key 'invitedBy'"),
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
)
}
inline fun `dk_sdu_cloud_project_api_TransferPiRoleRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.TransferPiRoleRequest {
var newPrincipalInvestigator: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"newPrincipalInvestigator" -> {
if (prop.element is JsonStreamElement.Text) {
newPrincipalInvestigator = prop.element.value
} else { throw ParsingException("Wrong type for newPrincipalInvestigator") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.TransferPiRoleRequest(
newPrincipalInvestigator = newPrincipalInvestigator ?: throw ParsingException("Missing key 'newPrincipalInvestigator'"),
)
}
inline fun `dk_sdu_cloud_project_api_DeleteMemberRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.DeleteMemberRequest {
var projectId: String? = null
var member: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"member" -> {
if (prop.element is JsonStreamElement.Text) {
member = prop.element.value
} else { throw ParsingException("Wrong type for member") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.DeleteMemberRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
member = member ?: throw ParsingException("Missing key 'member'"),
)
}
inline fun `dk_sdu_cloud_project_api_ChangeUserRoleRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ChangeUserRoleRequest {
var projectId: String? = null
var member: String? = null
var newRole: dk.sdu.cloud.project.api.ProjectRole? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"member" -> {
if (prop.element is JsonStreamElement.Text) {
member = prop.element.value
} else { throw ParsingException("Wrong type for member") }
}
"newRole" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
newRole = parseJson<dk.sdu.cloud.project.api.ProjectRole>(parser)
} else { throw ParsingException("Wrong type for newRole") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ChangeUserRoleRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
member = member ?: throw ParsingException("Missing key 'member'"),
newRole = newRole ?: throw ParsingException("Missing key 'newRole'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListFavoriteProjectsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListFavoriteProjectsRequest {
var user: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
var archived: Boolean? = null
var showAncestorPath: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"user" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
user = prop.element.value
} else { throw ParsingException("Wrong type for user") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
"archived" -> {
if (prop.element is JsonStreamElement.Bool) {
archived = prop.element.value
} else { throw ParsingException("Wrong type for archived") }
}
"showAncestorPath" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
showAncestorPath = prop.element.value
} else { throw ParsingException("Wrong type for showAncestorPath") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListFavoriteProjectsRequest(
user = user,
itemsPerPage = itemsPerPage ?: throw ParsingException("Missing key 'itemsPerPage'"),
page = page ?: throw ParsingException("Missing key 'page'"),
archived = archived ?: throw ParsingException("Missing key 'archived'"),
showAncestorPath = showAncestorPath,
)
}
inline fun `dk_sdu_cloud_project_api_UserProjectSummary_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.UserProjectSummary {
var projectId: String? = null
var title: String? = null
var whoami: dk.sdu.cloud.project.api.ProjectMember? = null
var needsVerification: Boolean? = null
var isFavorite: Boolean? = null
var archived: Boolean? = null
var parent: String? = null
var ancestorPath: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"whoami" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
whoami = parseJson<dk.sdu.cloud.project.api.ProjectMember>(parser)
} else { throw ParsingException("Wrong type for whoami") }
}
"needsVerification" -> {
if (prop.element is JsonStreamElement.Bool) {
needsVerification = prop.element.value
} else { throw ParsingException("Wrong type for needsVerification") }
}
"isFavorite" -> {
if (prop.element is JsonStreamElement.Bool) {
isFavorite = prop.element.value
} else { throw ParsingException("Wrong type for isFavorite") }
}
"archived" -> {
if (prop.element is JsonStreamElement.Bool) {
archived = prop.element.value
} else { throw ParsingException("Wrong type for archived") }
}
"parent" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
parent = prop.element.value
} else { throw ParsingException("Wrong type for parent") }
}
"ancestorPath" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
ancestorPath = prop.element.value
} else { throw ParsingException("Wrong type for ancestorPath") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.UserProjectSummary(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
title = title ?: throw ParsingException("Missing key 'title'"),
whoami = whoami ?: throw ParsingException("Missing key 'whoami'"),
needsVerification = needsVerification ?: throw ParsingException("Missing key 'needsVerification'"),
isFavorite = isFavorite ?: throw ParsingException("Missing key 'isFavorite'"),
archived = archived ?: throw ParsingException("Missing key 'archived'"),
parent = parent,
ancestorPath = ancestorPath,
)
}
inline fun `dk_sdu_cloud_project_api_ListProjectsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListProjectsRequest {
var user: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
var archived: Boolean? = null
var noFavorites: Boolean? = null
var showAncestorPath: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"user" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
user = prop.element.value
} else { throw ParsingException("Wrong type for user") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
"archived" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
archived = prop.element.value
} else { throw ParsingException("Wrong type for archived") }
}
"noFavorites" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
noFavorites = prop.element.value
} else { throw ParsingException("Wrong type for noFavorites") }
}
"showAncestorPath" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
showAncestorPath = prop.element.value
} else { throw ParsingException("Wrong type for showAncestorPath") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListProjectsRequest(
user = user,
itemsPerPage = itemsPerPage,
page = page,
archived = archived,
noFavorites = noFavorites,
showAncestorPath = showAncestorPath,
)
}
inline fun `dk_sdu_cloud_project_api_ViewProjectRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ViewProjectRequest {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ViewProjectRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_project_api_ArchiveRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ArchiveRequest {
var archiveStatus: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"archiveStatus" -> {
if (prop.element is JsonStreamElement.Bool) {
archiveStatus = prop.element.value
} else { throw ParsingException("Wrong type for archiveStatus") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ArchiveRequest(
archiveStatus = archiveStatus ?: throw ParsingException("Missing key 'archiveStatus'"),
)
}
inline fun `dk_sdu_cloud_project_api_ArchiveBulkRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ArchiveBulkRequest {
var projects: List<dk.sdu.cloud.project.api.UserProjectSummary>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projects" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val projectsList = ArrayList<dk.sdu.cloud.project.api.UserProjectSummary>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val projectsElem: dk.sdu.cloud.project.api.UserProjectSummary
if (prop.element is JsonStreamElement.ObjectStart) {
projectsElem = parseJson<dk.sdu.cloud.project.api.UserProjectSummary>(parser)
} else { throw ParsingException("Wrong type for projectsElem") }
projectsList.add(projectsElem)
} else { throw ParsingException("Wrong element type for projects") }
}
projects = projectsList
} else { throw ParsingException("Wrong type for projects") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ArchiveBulkRequest(
projects = projects ?: throw ParsingException("Missing key 'projects'"),
)
}
inline fun `dk_sdu_cloud_project_api_ExistsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ExistsRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ExistsRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_project_api_ExistsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ExistsResponse {
var exists: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"exists" -> {
if (prop.element is JsonStreamElement.Bool) {
exists = prop.element.value
} else { throw ParsingException("Wrong type for exists") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ExistsResponse(
exists = exists ?: throw ParsingException("Missing key 'exists'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListSubProjectsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListSubProjectsRequest {
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListSubProjectsRequest(
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun <reified T> `dk_sdu_cloud_PageV2_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.PageV2<T> {
var itemsPerPage: Int? = null
var items: List<T>? = null
var next: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"items" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val itemsList = ArrayList<T>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val itemsElem: T
if (prop.element is JsonStreamElement.ObjectStart) {
itemsElem = parseJson<T>(parser)
} else { throw ParsingException("Wrong type for itemsElem") }
itemsList.add(itemsElem)
} else { throw ParsingException("Wrong element type for items") }
}
items = itemsList
} else { throw ParsingException("Wrong type for items") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.PageV2(
itemsPerPage = itemsPerPage ?: throw ParsingException("Missing key 'itemsPerPage'"),
items = items ?: throw ParsingException("Missing key 'items'"),
next = next,
)
}
inline fun `dk_sdu_cloud_project_api_MemberInProject_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.MemberInProject {
var role: dk.sdu.cloud.project.api.ProjectRole? = null
var project: dk.sdu.cloud.project.api.Project? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"role" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.project.api.ProjectRole?>(parser)
} else { throw ParsingException("Wrong type for role") }
}
"project" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
project = parseJson<dk.sdu.cloud.project.api.Project>(parser)
} else { throw ParsingException("Wrong type for project") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.MemberInProject(
role = role,
project = project ?: throw ParsingException("Missing key 'project'"),
)
}
inline fun `dk_sdu_cloud_project_api_Project_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.Project {
var id: String? = null
var title: String? = null
var parent: String? = null
var archived: Boolean? = null
var fullPath: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"parent" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
parent = prop.element.value
} else { throw ParsingException("Wrong type for parent") }
}
"archived" -> {
if (prop.element is JsonStreamElement.Bool) {
archived = prop.element.value
} else { throw ParsingException("Wrong type for archived") }
}
"fullPath" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
fullPath = prop.element.value
} else { throw ParsingException("Wrong type for fullPath") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.Project(
id = id ?: throw ParsingException("Missing key 'id'"),
title = title ?: throw ParsingException("Missing key 'title'"),
parent = parent,
archived = archived ?: throw ParsingException("Missing key 'archived'"),
fullPath = fullPath,
)
}
inline fun `dk_sdu_cloud_project_api_LookupByTitleRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupByTitleRequest {
var title: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupByTitleRequest(
title = title ?: throw ParsingException("Missing key 'title'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupByIdRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupByIdRequest {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupByIdRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupByIdBulkRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupByIdBulkRequest {
var ids: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"ids" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val idsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val idsElem: String
if (prop.element is JsonStreamElement.Text) {
idsElem = prop.element.value
} else { throw ParsingException("Wrong type for idsElem") }
idsList.add(idsElem)
} else { throw ParsingException("Wrong element type for ids") }
}
ids = idsList
} else { throw ParsingException("Wrong type for ids") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupByIdBulkRequest(
ids = ids ?: throw ParsingException("Missing key 'ids'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupPrincipalInvestigatorResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupPrincipalInvestigatorResponse {
var principalInvestigator: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"principalInvestigator" -> {
if (prop.element is JsonStreamElement.Text) {
principalInvestigator = prop.element.value
} else { throw ParsingException("Wrong type for principalInvestigator") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupPrincipalInvestigatorResponse(
principalInvestigator = principalInvestigator ?: throw ParsingException("Missing key 'principalInvestigator'"),
)
}
inline fun `dk_sdu_cloud_project_api_RenameProjectRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.RenameProjectRequest {
var id: String? = null
var newTitle: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"newTitle" -> {
if (prop.element is JsonStreamElement.Text) {
newTitle = prop.element.value
} else { throw ParsingException("Wrong type for newTitle") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.RenameProjectRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
newTitle = newTitle ?: throw ParsingException("Missing key 'newTitle'"),
)
}
inline fun `dk_sdu_cloud_project_api_ToggleRenamingRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ToggleRenamingRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ToggleRenamingRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_project_api_AllowsRenamingRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.AllowsRenamingRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.AllowsRenamingRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_project_api_AllowsRenamingResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.AllowsRenamingResponse {
var allowed: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"allowed" -> {
if (prop.element is JsonStreamElement.Bool) {
allowed = prop.element.value
} else { throw ParsingException("Wrong type for allowed") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.AllowsRenamingResponse(
allowed = allowed ?: throw ParsingException("Missing key 'allowed'"),
)
}
inline fun `dk_sdu_cloud_project_api_UpdateDataManagementPlanRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.UpdateDataManagementPlanRequest {
var id: String? = null
var dmp: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"dmp" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
dmp = prop.element.value
} else { throw ParsingException("Wrong type for dmp") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.UpdateDataManagementPlanRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
dmp = dmp,
)
}
inline fun `dk_sdu_cloud_project_api_FetchDataManagementPlanResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.FetchDataManagementPlanResponse {
var dmp: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"dmp" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
dmp = prop.element.value
} else { throw ParsingException("Wrong type for dmp") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.FetchDataManagementPlanResponse(
dmp = dmp,
)
}
inline fun `dk_sdu_cloud_project_api_ProjectSearchByPathRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ProjectSearchByPathRequest {
var path: String? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
var includeFullPath: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"path" -> {
if (prop.element is JsonStreamElement.Text) {
path = prop.element.value
} else { throw ParsingException("Wrong type for path") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
"includeFullPath" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeFullPath = prop.element.value
} else { throw ParsingException("Wrong type for includeFullPath") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ProjectSearchByPathRequest(
path = path ?: throw ParsingException("Missing key 'path'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
includeFullPath = includeFullPath,
)
}
inline fun `dk_sdu_cloud_project_api_UserStatusRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.UserStatusRequest {
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.UserStatusRequest(
username = username,
)
}
inline fun `dk_sdu_cloud_project_api_UserStatusResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.UserStatusResponse {
var membership: List<dk.sdu.cloud.project.api.UserStatusInProject>? = null
var groups: List<dk.sdu.cloud.project.api.UserGroupSummary>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"membership" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val membershipList = ArrayList<dk.sdu.cloud.project.api.UserStatusInProject>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val membershipElem: dk.sdu.cloud.project.api.UserStatusInProject
if (prop.element is JsonStreamElement.ObjectStart) {
membershipElem = parseJson<dk.sdu.cloud.project.api.UserStatusInProject>(parser)
} else { throw ParsingException("Wrong type for membershipElem") }
membershipList.add(membershipElem)
} else { throw ParsingException("Wrong element type for membership") }
}
membership = membershipList
} else { throw ParsingException("Wrong type for membership") }
}
"groups" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val groupsList = ArrayList<dk.sdu.cloud.project.api.UserGroupSummary>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val groupsElem: dk.sdu.cloud.project.api.UserGroupSummary
if (prop.element is JsonStreamElement.ObjectStart) {
groupsElem = parseJson<dk.sdu.cloud.project.api.UserGroupSummary>(parser)
} else { throw ParsingException("Wrong type for groupsElem") }
groupsList.add(groupsElem)
} else { throw ParsingException("Wrong element type for groups") }
}
groups = groupsList
} else { throw ParsingException("Wrong type for groups") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.UserStatusResponse(
membership = membership ?: throw ParsingException("Missing key 'membership'"),
groups = groups ?: throw ParsingException("Missing key 'groups'"),
)
}
inline fun `dk_sdu_cloud_project_api_UserStatusInProject_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.UserStatusInProject {
var projectId: String? = null
var title: String? = null
var whoami: dk.sdu.cloud.project.api.ProjectMember? = null
var parent: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"whoami" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
whoami = parseJson<dk.sdu.cloud.project.api.ProjectMember>(parser)
} else { throw ParsingException("Wrong type for whoami") }
}
"parent" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
parent = prop.element.value
} else { throw ParsingException("Wrong type for parent") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.UserStatusInProject(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
title = title ?: throw ParsingException("Missing key 'title'"),
whoami = whoami ?: throw ParsingException("Missing key 'whoami'"),
parent = parent,
)
}
inline fun `dk_sdu_cloud_project_api_UserGroupSummary_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.UserGroupSummary {
var project: String? = null
var group: String? = null
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"project" -> {
if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.UserGroupSummary(
project = project ?: throw ParsingException("Missing key 'project'"),
group = group ?: throw ParsingException("Missing key 'group'"),
username = username ?: throw ParsingException("Missing key 'username'"),
)
}
inline fun `dk_sdu_cloud_project_api_SearchRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.SearchRequest {
var query: String? = null
var notInGroup: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"query" -> {
if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
"notInGroup" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
notInGroup = prop.element.value
} else { throw ParsingException("Wrong type for notInGroup") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.SearchRequest(
query = query ?: throw ParsingException("Missing key 'query'"),
notInGroup = notInGroup,
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_project_api_LookupAdminsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupAdminsRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupAdminsRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupAdminsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupAdminsResponse {
var admins: List<dk.sdu.cloud.project.api.ProjectMember>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"admins" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val adminsList = ArrayList<dk.sdu.cloud.project.api.ProjectMember>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val adminsElem: dk.sdu.cloud.project.api.ProjectMember
if (prop.element is JsonStreamElement.ObjectStart) {
adminsElem = parseJson<dk.sdu.cloud.project.api.ProjectMember>(parser)
} else { throw ParsingException("Wrong type for adminsElem") }
adminsList.add(adminsElem)
} else { throw ParsingException("Wrong element type for admins") }
}
admins = adminsList
} else { throw ParsingException("Wrong type for admins") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupAdminsResponse(
admins = admins ?: throw ParsingException("Missing key 'admins'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupAdminsBulkRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupAdminsBulkRequest {
var projectId: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val projectIdList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val projectIdElem: String
if (prop.element is JsonStreamElement.Text) {
projectIdElem = prop.element.value
} else { throw ParsingException("Wrong type for projectIdElem") }
projectIdList.add(projectIdElem)
} else { throw ParsingException("Wrong element type for projectId") }
}
projectId = projectIdList
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupAdminsBulkRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupAdminsBulkResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupAdminsBulkResponse {
var admins: List<dk.sdu.cloud.project.api.Pair<String, List<dk.sdu.cloud.project.api.ProjectMember>>>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"admins" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val adminsList = ArrayList<dk.sdu.cloud.project.api.Pair<String, List<dk.sdu.cloud.project.api.ProjectMember>>>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val adminsElem: dk.sdu.cloud.project.api.Pair<String, List<dk.sdu.cloud.project.api.ProjectMember>>
if (prop.element is JsonStreamElement.ObjectStart) {
adminsElem = parseJson<dk.sdu.cloud.project.api.Pair<String, List<dk.sdu.cloud.project.api.ProjectMember>>>(parser)
} else { throw ParsingException("Wrong type for adminsElem") }
adminsList.add(adminsElem)
} else { throw ParsingException("Wrong element type for admins") }
}
admins = adminsList
} else { throw ParsingException("Wrong type for admins") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupAdminsBulkResponse(
admins = admins ?: throw ParsingException("Missing key 'admins'"),
)
}
inline fun <reified A, reified B> `dk_sdu_cloud_project_api_Pair_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.Pair<A, B> {
var first: A? = null
var second: B? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"first" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
first = parseJson<A>(parser)
} else { throw ParsingException("Wrong type for first") }
}
"second" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
second = parseJson<B>(parser)
} else { throw ParsingException("Wrong type for second") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.Pair(
first = first ?: throw ParsingException("Missing key 'first'"),
second = second ?: throw ParsingException("Missing key 'second'"),
)
}
inline fun `dk_sdu_cloud_project_api_CreateGroupRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.CreateGroupRequest {
var group: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.CreateGroupRequest(
group = group ?: throw ParsingException("Missing key 'group'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListGroupsWithSummaryRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListGroupsWithSummaryRequest {
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListGroupsWithSummaryRequest(
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_project_api_GroupWithSummary_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.GroupWithSummary {
var groupId: String? = null
var groupTitle: String? = null
var numberOfMembers: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"groupId" -> {
if (prop.element is JsonStreamElement.Text) {
groupId = prop.element.value
} else { throw ParsingException("Wrong type for groupId") }
}
"groupTitle" -> {
if (prop.element is JsonStreamElement.Text) {
groupTitle = prop.element.value
} else { throw ParsingException("Wrong type for groupTitle") }
}
"numberOfMembers" -> {
if (prop.element is JsonStreamElement.Number) {
numberOfMembers = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for numberOfMembers") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.GroupWithSummary(
groupId = groupId ?: throw ParsingException("Missing key 'groupId'"),
groupTitle = groupTitle ?: throw ParsingException("Missing key 'groupTitle'"),
numberOfMembers = numberOfMembers ?: throw ParsingException("Missing key 'numberOfMembers'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListAllGroupMembersRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListAllGroupMembersRequest {
var project: String? = null
var group: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"project" -> {
if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListAllGroupMembersRequest(
project = project ?: throw ParsingException("Missing key 'project'"),
group = group ?: throw ParsingException("Missing key 'group'"),
)
}
inline fun `dk_sdu_cloud_project_api_DeleteGroupsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.DeleteGroupsRequest {
var groups: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"groups" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val groupsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val groupsElem: String
if (prop.element is JsonStreamElement.Text) {
groupsElem = prop.element.value
} else { throw ParsingException("Wrong type for groupsElem") }
groupsList.add(groupsElem)
} else { throw ParsingException("Wrong element type for groups") }
}
groups = groupsList
} else { throw ParsingException("Wrong type for groups") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.DeleteGroupsRequest(
groups = groups ?: throw ParsingException("Missing key 'groups'"),
)
}
inline fun `dk_sdu_cloud_project_api_AddGroupMemberRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.AddGroupMemberRequest {
var group: String? = null
var memberUsername: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
"memberUsername" -> {
if (prop.element is JsonStreamElement.Text) {
memberUsername = prop.element.value
} else { throw ParsingException("Wrong type for memberUsername") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.AddGroupMemberRequest(
group = group ?: throw ParsingException("Missing key 'group'"),
memberUsername = memberUsername ?: throw ParsingException("Missing key 'memberUsername'"),
)
}
inline fun `dk_sdu_cloud_project_api_RemoveGroupMemberRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.RemoveGroupMemberRequest {
var group: String? = null
var memberUsername: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
"memberUsername" -> {
if (prop.element is JsonStreamElement.Text) {
memberUsername = prop.element.value
} else { throw ParsingException("Wrong type for memberUsername") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.RemoveGroupMemberRequest(
group = group ?: throw ParsingException("Missing key 'group'"),
memberUsername = memberUsername ?: throw ParsingException("Missing key 'memberUsername'"),
)
}
inline fun `dk_sdu_cloud_project_api_UpdateGroupNameRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.UpdateGroupNameRequest {
var groupId: String? = null
var newGroupName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"groupId" -> {
if (prop.element is JsonStreamElement.Text) {
groupId = prop.element.value
} else { throw ParsingException("Wrong type for groupId") }
}
"newGroupName" -> {
if (prop.element is JsonStreamElement.Text) {
newGroupName = prop.element.value
} else { throw ParsingException("Wrong type for newGroupName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.UpdateGroupNameRequest(
groupId = groupId ?: throw ParsingException("Missing key 'groupId'"),
newGroupName = newGroupName ?: throw ParsingException("Missing key 'newGroupName'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListGroupMembersRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListGroupMembersRequest {
var group: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListGroupMembersRequest(
group = group ?: throw ParsingException("Missing key 'group'"),
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_project_api_IsMemberRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.IsMemberRequest {
var queries: List<dk.sdu.cloud.project.api.IsMemberQuery>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"queries" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val queriesList = ArrayList<dk.sdu.cloud.project.api.IsMemberQuery>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val queriesElem: dk.sdu.cloud.project.api.IsMemberQuery
if (prop.element is JsonStreamElement.ObjectStart) {
queriesElem = parseJson<dk.sdu.cloud.project.api.IsMemberQuery>(parser)
} else { throw ParsingException("Wrong type for queriesElem") }
queriesList.add(queriesElem)
} else { throw ParsingException("Wrong element type for queries") }
}
queries = queriesList
} else { throw ParsingException("Wrong type for queries") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.IsMemberRequest(
queries = queries ?: throw ParsingException("Missing key 'queries'"),
)
}
inline fun `dk_sdu_cloud_project_api_IsMemberQuery_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.IsMemberQuery {
var project: String? = null
var group: String? = null
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"project" -> {
if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.IsMemberQuery(
project = project ?: throw ParsingException("Missing key 'project'"),
group = group ?: throw ParsingException("Missing key 'group'"),
username = username ?: throw ParsingException("Missing key 'username'"),
)
}
inline fun `dk_sdu_cloud_project_api_IsMemberResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.IsMemberResponse {
var responses: List<Boolean>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"responses" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val responsesList = ArrayList<Boolean>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val responsesElem: Boolean
if (prop.element is JsonStreamElement.Bool) {
responsesElem = prop.element.value
} else { throw ParsingException("Wrong type for responsesElem") }
responsesList.add(responsesElem)
} else { throw ParsingException("Wrong element type for responses") }
}
responses = responsesList
} else { throw ParsingException("Wrong type for responses") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.IsMemberResponse(
responses = responses ?: throw ParsingException("Missing key 'responses'"),
)
}
inline fun `dk_sdu_cloud_project_api_GroupExistsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.GroupExistsRequest {
var project: String? = null
var groups: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"project" -> {
if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
"groups" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val groupsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val groupsElem: String
if (prop.element is JsonStreamElement.Text) {
groupsElem = prop.element.value
} else { throw ParsingException("Wrong type for groupsElem") }
groupsList.add(groupsElem)
} else { throw ParsingException("Wrong element type for groups") }
}
groups = groupsList
} else { throw ParsingException("Wrong type for groups") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.GroupExistsRequest(
project = project ?: throw ParsingException("Missing key 'project'"),
groups = groups ?: throw ParsingException("Missing key 'groups'"),
)
}
inline fun `dk_sdu_cloud_project_api_GroupExistsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.GroupExistsResponse {
var exists: List<Boolean>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"exists" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val existsList = ArrayList<Boolean>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val existsElem: Boolean
if (prop.element is JsonStreamElement.Bool) {
existsElem = prop.element.value
} else { throw ParsingException("Wrong type for existsElem") }
existsList.add(existsElem)
} else { throw ParsingException("Wrong element type for exists") }
}
exists = existsList
} else { throw ParsingException("Wrong type for exists") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.GroupExistsResponse(
exists = exists ?: throw ParsingException("Missing key 'exists'"),
)
}
inline fun `dk_sdu_cloud_project_api_ViewGroupRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ViewGroupRequest {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ViewGroupRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupByGroupTitleRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupByGroupTitleRequest {
var projectId: String? = null
var title: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupByGroupTitleRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
title = title ?: throw ParsingException("Missing key 'title'"),
)
}
inline fun `dk_sdu_cloud_project_api_LookupProjectAndGroupRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.LookupProjectAndGroupRequest {
var project: String? = null
var group: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"project" -> {
if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.LookupProjectAndGroupRequest(
project = project ?: throw ParsingException("Missing key 'project'"),
group = group ?: throw ParsingException("Missing key 'group'"),
)
}
inline fun `dk_sdu_cloud_project_api_ProjectAndGroup_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ProjectAndGroup {
var project: dk.sdu.cloud.project.api.Project? = null
var group: dk.sdu.cloud.project.api.ProjectGroup? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"project" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
project = parseJson<dk.sdu.cloud.project.api.Project>(parser)
} else { throw ParsingException("Wrong type for project") }
}
"group" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
group = parseJson<dk.sdu.cloud.project.api.ProjectGroup>(parser)
} else { throw ParsingException("Wrong type for group") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ProjectAndGroup(
project = project ?: throw ParsingException("Missing key 'project'"),
group = group ?: throw ParsingException("Missing key 'group'"),
)
}
inline fun `dk_sdu_cloud_project_api_ProjectGroup_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ProjectGroup {
var id: String? = null
var title: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ProjectGroup(
id = id ?: throw ParsingException("Missing key 'id'"),
title = title ?: throw ParsingException("Missing key 'title'"),
)
}
inline fun `dk_sdu_cloud_project_api_ListAllGroupIdsAndTitlesResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.api.ListAllGroupIdsAndTitlesResponse {
var groups: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"groups" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for groups") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.api.ListAllGroupIdsAndTitlesResponse(
groups = groups ?: throw ParsingException("Missing key 'groups'"),
)
}
inline fun `dk_sdu_cloud_project_favorite_api_ToggleFavoriteRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.project.favorite.api.ToggleFavoriteRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.project.favorite.api.ToggleFavoriteRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProviderSpecification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProviderSpecification {
var id: String? = null
var domain: String? = null
var https: Boolean? = null
var port: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"domain" -> {
if (prop.element is JsonStreamElement.Text) {
domain = prop.element.value
} else { throw ParsingException("Wrong type for domain") }
}
"https" -> {
if (prop.element is JsonStreamElement.Bool) {
https = prop.element.value
} else { throw ParsingException("Wrong type for https") }
}
"port" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
port = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for port") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProviderSpecification(
id = id ?: throw ParsingException("Missing key 'id'"),
domain = domain ?: throw ParsingException("Missing key 'domain'"),
https = https ?: throw ParsingException("Missing key 'https'"),
port = port,
)
}
inline fun `dk_sdu_cloud_accounting_api_ProductReference_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.ProductReference {
var id: String? = null
var category: String? = null
var provider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"category" -> {
if (prop.element is JsonStreamElement.Text) {
category = prop.element.value
} else { throw ParsingException("Wrong type for category") }
}
"provider" -> {
if (prop.element is JsonStreamElement.Text) {
provider = prop.element.value
} else { throw ParsingException("Wrong type for provider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.ProductReference(
id = id ?: throw ParsingException("Missing key 'id'"),
category = category ?: throw ParsingException("Missing key 'category'"),
provider = provider ?: throw ParsingException("Missing key 'provider'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProviderUpdate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProviderUpdate {
var timestamp: Long? = null
var status: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProviderUpdate(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
status = status,
)
}
inline fun `dk_sdu_cloud_provider_api_ProviderSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProviderSupport {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProviderSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_ProductCategoryId_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.ProductCategoryId {
var name: String? = null
var provider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"provider" -> {
if (prop.element is JsonStreamElement.Text) {
provider = prop.element.value
} else { throw ParsingException("Wrong type for provider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.ProductCategoryId(
name = name ?: throw ParsingException("Missing key 'name'"),
provider = provider ?: throw ParsingException("Missing key 'provider'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_Product_Storage_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.Product.Storage {
var name: String? = null
var pricePerUnit: Long? = null
var category: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var description: String? = null
var priority: Int? = null
var version: Int? = null
var freeToUse: Boolean? = null
var unitOfPrice: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var hiddenInGrantApplications: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"pricePerUnit" -> {
if (prop.element is JsonStreamElement.Number) {
pricePerUnit = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for pricePerUnit") }
}
"category" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
category = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for category") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"priority" -> {
if (prop.element is JsonStreamElement.Number) {
priority = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for priority") }
}
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
"freeToUse" -> {
if (prop.element is JsonStreamElement.Bool) {
freeToUse = prop.element.value
} else { throw ParsingException("Wrong type for freeToUse") }
}
"unitOfPrice" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unitOfPrice = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unitOfPrice") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"hiddenInGrantApplications" -> {
if (prop.element is JsonStreamElement.Bool) {
hiddenInGrantApplications = prop.element.value
} else { throw ParsingException("Wrong type for hiddenInGrantApplications") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.Product.Storage(
name = name ?: throw ParsingException("Missing key 'name'"),
pricePerUnit = pricePerUnit ?: throw ParsingException("Missing key 'pricePerUnit'"),
category = category ?: throw ParsingException("Missing key 'category'"),
description = description ?: throw ParsingException("Missing key 'description'"),
priority = priority ?: throw ParsingException("Missing key 'priority'"),
version = version ?: throw ParsingException("Missing key 'version'"),
freeToUse = freeToUse ?: throw ParsingException("Missing key 'freeToUse'"),
unitOfPrice = unitOfPrice ?: throw ParsingException("Missing key 'unitOfPrice'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
hiddenInGrantApplications = hiddenInGrantApplications ?: throw ParsingException("Missing key 'hiddenInGrantApplications'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_Product_Compute_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.Product.Compute {
var name: String? = null
var pricePerUnit: Long? = null
var category: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var description: String? = null
var priority: Int? = null
var cpu: Int? = null
var memoryInGigs: Int? = null
var gpu: Int? = null
var version: Int? = null
var freeToUse: Boolean? = null
var unitOfPrice: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var hiddenInGrantApplications: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"pricePerUnit" -> {
if (prop.element is JsonStreamElement.Number) {
pricePerUnit = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for pricePerUnit") }
}
"category" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
category = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for category") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"priority" -> {
if (prop.element is JsonStreamElement.Number) {
priority = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for priority") }
}
"cpu" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
cpu = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for cpu") }
}
"memoryInGigs" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
memoryInGigs = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for memoryInGigs") }
}
"gpu" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
gpu = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for gpu") }
}
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
"freeToUse" -> {
if (prop.element is JsonStreamElement.Bool) {
freeToUse = prop.element.value
} else { throw ParsingException("Wrong type for freeToUse") }
}
"unitOfPrice" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unitOfPrice = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unitOfPrice") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"hiddenInGrantApplications" -> {
if (prop.element is JsonStreamElement.Bool) {
hiddenInGrantApplications = prop.element.value
} else { throw ParsingException("Wrong type for hiddenInGrantApplications") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.Product.Compute(
name = name ?: throw ParsingException("Missing key 'name'"),
pricePerUnit = pricePerUnit ?: throw ParsingException("Missing key 'pricePerUnit'"),
category = category ?: throw ParsingException("Missing key 'category'"),
description = description ?: throw ParsingException("Missing key 'description'"),
priority = priority ?: throw ParsingException("Missing key 'priority'"),
cpu = cpu,
memoryInGigs = memoryInGigs,
gpu = gpu,
version = version ?: throw ParsingException("Missing key 'version'"),
freeToUse = freeToUse ?: throw ParsingException("Missing key 'freeToUse'"),
unitOfPrice = unitOfPrice ?: throw ParsingException("Missing key 'unitOfPrice'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
hiddenInGrantApplications = hiddenInGrantApplications ?: throw ParsingException("Missing key 'hiddenInGrantApplications'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_Product_Ingress_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.Product.Ingress {
var name: String? = null
var pricePerUnit: Long? = null
var category: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var description: String? = null
var priority: Int? = null
var version: Int? = null
var freeToUse: Boolean? = null
var unitOfPrice: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var hiddenInGrantApplications: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"pricePerUnit" -> {
if (prop.element is JsonStreamElement.Number) {
pricePerUnit = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for pricePerUnit") }
}
"category" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
category = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for category") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"priority" -> {
if (prop.element is JsonStreamElement.Number) {
priority = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for priority") }
}
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
"freeToUse" -> {
if (prop.element is JsonStreamElement.Bool) {
freeToUse = prop.element.value
} else { throw ParsingException("Wrong type for freeToUse") }
}
"unitOfPrice" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unitOfPrice = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unitOfPrice") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"hiddenInGrantApplications" -> {
if (prop.element is JsonStreamElement.Bool) {
hiddenInGrantApplications = prop.element.value
} else { throw ParsingException("Wrong type for hiddenInGrantApplications") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.Product.Ingress(
name = name ?: throw ParsingException("Missing key 'name'"),
pricePerUnit = pricePerUnit ?: throw ParsingException("Missing key 'pricePerUnit'"),
category = category ?: throw ParsingException("Missing key 'category'"),
description = description ?: throw ParsingException("Missing key 'description'"),
priority = priority ?: throw ParsingException("Missing key 'priority'"),
version = version ?: throw ParsingException("Missing key 'version'"),
freeToUse = freeToUse ?: throw ParsingException("Missing key 'freeToUse'"),
unitOfPrice = unitOfPrice ?: throw ParsingException("Missing key 'unitOfPrice'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
hiddenInGrantApplications = hiddenInGrantApplications ?: throw ParsingException("Missing key 'hiddenInGrantApplications'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_Product_License_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.Product.License {
var name: String? = null
var pricePerUnit: Long? = null
var category: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var description: String? = null
var priority: Int? = null
var tags: List<String>? = null
var version: Int? = null
var freeToUse: Boolean? = null
var unitOfPrice: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var hiddenInGrantApplications: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"pricePerUnit" -> {
if (prop.element is JsonStreamElement.Number) {
pricePerUnit = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for pricePerUnit") }
}
"category" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
category = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for category") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"priority" -> {
if (prop.element is JsonStreamElement.Number) {
priority = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for priority") }
}
"tags" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val tagsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val tagsElem: String
if (prop.element is JsonStreamElement.Text) {
tagsElem = prop.element.value
} else { throw ParsingException("Wrong type for tagsElem") }
tagsList.add(tagsElem)
} else { throw ParsingException("Wrong element type for tags") }
}
tags = tagsList
} else { throw ParsingException("Wrong type for tags") }
}
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
"freeToUse" -> {
if (prop.element is JsonStreamElement.Bool) {
freeToUse = prop.element.value
} else { throw ParsingException("Wrong type for freeToUse") }
}
"unitOfPrice" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unitOfPrice = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unitOfPrice") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"hiddenInGrantApplications" -> {
if (prop.element is JsonStreamElement.Bool) {
hiddenInGrantApplications = prop.element.value
} else { throw ParsingException("Wrong type for hiddenInGrantApplications") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.Product.License(
name = name ?: throw ParsingException("Missing key 'name'"),
pricePerUnit = pricePerUnit ?: throw ParsingException("Missing key 'pricePerUnit'"),
category = category ?: throw ParsingException("Missing key 'category'"),
description = description ?: throw ParsingException("Missing key 'description'"),
priority = priority ?: throw ParsingException("Missing key 'priority'"),
tags = tags ?: throw ParsingException("Missing key 'tags'"),
version = version ?: throw ParsingException("Missing key 'version'"),
freeToUse = freeToUse ?: throw ParsingException("Missing key 'freeToUse'"),
unitOfPrice = unitOfPrice ?: throw ParsingException("Missing key 'unitOfPrice'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
hiddenInGrantApplications = hiddenInGrantApplications ?: throw ParsingException("Missing key 'hiddenInGrantApplications'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_Product_NetworkIP_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.Product.NetworkIP {
var name: String? = null
var pricePerUnit: Long? = null
var category: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var description: String? = null
var priority: Int? = null
var version: Int? = null
var freeToUse: Boolean? = null
var unitOfPrice: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var hiddenInGrantApplications: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"pricePerUnit" -> {
if (prop.element is JsonStreamElement.Number) {
pricePerUnit = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for pricePerUnit") }
}
"category" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
category = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for category") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"priority" -> {
if (prop.element is JsonStreamElement.Number) {
priority = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for priority") }
}
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
"freeToUse" -> {
if (prop.element is JsonStreamElement.Bool) {
freeToUse = prop.element.value
} else { throw ParsingException("Wrong type for freeToUse") }
}
"unitOfPrice" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unitOfPrice = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unitOfPrice") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"hiddenInGrantApplications" -> {
if (prop.element is JsonStreamElement.Bool) {
hiddenInGrantApplications = prop.element.value
} else { throw ParsingException("Wrong type for hiddenInGrantApplications") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.Product.NetworkIP(
name = name ?: throw ParsingException("Missing key 'name'"),
pricePerUnit = pricePerUnit ?: throw ParsingException("Missing key 'pricePerUnit'"),
category = category ?: throw ParsingException("Missing key 'category'"),
description = description ?: throw ParsingException("Missing key 'description'"),
priority = priority ?: throw ParsingException("Missing key 'priority'"),
version = version ?: throw ParsingException("Missing key 'version'"),
freeToUse = freeToUse ?: throw ParsingException("Missing key 'freeToUse'"),
unitOfPrice = unitOfPrice ?: throw ParsingException("Missing key 'unitOfPrice'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
hiddenInGrantApplications = hiddenInGrantApplications ?: throw ParsingException("Missing key 'hiddenInGrantApplications'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_Product_Synchronization_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.Product.Synchronization {
var name: String? = null
var pricePerUnit: Long? = null
var category: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var description: String? = null
var priority: Int? = null
var version: Int? = null
var freeToUse: Boolean? = null
var unitOfPrice: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var hiddenInGrantApplications: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"pricePerUnit" -> {
if (prop.element is JsonStreamElement.Number) {
pricePerUnit = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for pricePerUnit") }
}
"category" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
category = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for category") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"priority" -> {
if (prop.element is JsonStreamElement.Number) {
priority = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for priority") }
}
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
"freeToUse" -> {
if (prop.element is JsonStreamElement.Bool) {
freeToUse = prop.element.value
} else { throw ParsingException("Wrong type for freeToUse") }
}
"unitOfPrice" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unitOfPrice = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unitOfPrice") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"hiddenInGrantApplications" -> {
if (prop.element is JsonStreamElement.Bool) {
hiddenInGrantApplications = prop.element.value
} else { throw ParsingException("Wrong type for hiddenInGrantApplications") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.Product.Synchronization(
name = name ?: throw ParsingException("Missing key 'name'"),
pricePerUnit = pricePerUnit ?: throw ParsingException("Missing key 'pricePerUnit'"),
category = category ?: throw ParsingException("Missing key 'category'"),
description = description ?: throw ParsingException("Missing key 'description'"),
priority = priority ?: throw ParsingException("Missing key 'priority'"),
version = version ?: throw ParsingException("Missing key 'version'"),
freeToUse = freeToUse ?: throw ParsingException("Missing key 'freeToUse'"),
unitOfPrice = unitOfPrice ?: throw ParsingException("Missing key 'unitOfPrice'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
hiddenInGrantApplications = hiddenInGrantApplications ?: throw ParsingException("Missing key 'hiddenInGrantApplications'"),
)
}
inline fun `dk_sdu_cloud_provider_api_Provider_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.Provider {
var id: String? = null
var specification: dk.sdu.cloud.provider.api.ProviderSpecification? = null
var refreshToken: String? = null
var publicKey: String? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.provider.api.ProviderStatus? = null
var updates: List<dk.sdu.cloud.provider.api.ProviderUpdate>? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.provider.api.ProviderSpecification>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"refreshToken" -> {
if (prop.element is JsonStreamElement.Text) {
refreshToken = prop.element.value
} else { throw ParsingException("Wrong type for refreshToken") }
}
"publicKey" -> {
if (prop.element is JsonStreamElement.Text) {
publicKey = prop.element.value
} else { throw ParsingException("Wrong type for publicKey") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.provider.api.ProviderStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.provider.api.ProviderUpdate>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.provider.api.ProviderUpdate
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.provider.api.ProviderUpdate>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.Provider(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
refreshToken = refreshToken ?: throw ParsingException("Missing key 'refreshToken'"),
publicKey = publicKey ?: throw ParsingException("Missing key 'publicKey'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_provider_api_ProviderStatus_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProviderStatus {
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product, dk.sdu.cloud.provider.api.ProviderSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product, dk.sdu.cloud.provider.api.ProviderSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProviderStatus(
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun <reified P, reified Support> `dk_sdu_cloud_accounting_api_providers_ResolvedSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.ResolvedSupport<P, Support> {
var product: P? = null
var support: Support? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<P>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"support" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
support = parseJson<Support>(parser)
} else { throw ParsingException("Wrong type for support") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.ResolvedSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
support = support ?: throw ParsingException("Missing key 'support'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ResourceOwner_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ResourceOwner {
var createdBy: String? = null
var project: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"createdBy" -> {
if (prop.element is JsonStreamElement.Text) {
createdBy = prop.element.value
} else { throw ParsingException("Wrong type for createdBy") }
}
"project" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ResourceOwner(
createdBy = createdBy ?: throw ParsingException("Missing key 'createdBy'"),
project = project,
)
}
inline fun `dk_sdu_cloud_provider_api_ResourcePermissions_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ResourcePermissions {
var myself: List<dk.sdu.cloud.provider.api.Permission>? = null
var others: List<dk.sdu.cloud.provider.api.ResourceAclEntry>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"myself" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val myselfList = ArrayList<dk.sdu.cloud.provider.api.Permission>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val myselfElem: dk.sdu.cloud.provider.api.Permission
if (prop.element is JsonStreamElement.ObjectStart) {
myselfElem = parseJson<dk.sdu.cloud.provider.api.Permission>(parser)
} else { throw ParsingException("Wrong type for myselfElem") }
myselfList.add(myselfElem)
} else { throw ParsingException("Wrong element type for myself") }
}
myself = myselfList
} else { throw ParsingException("Wrong type for myself") }
}
"others" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ArrayStart) {
val othersList = ArrayList<dk.sdu.cloud.provider.api.ResourceAclEntry>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val othersElem: dk.sdu.cloud.provider.api.ResourceAclEntry
if (prop.element is JsonStreamElement.ObjectStart) {
othersElem = parseJson<dk.sdu.cloud.provider.api.ResourceAclEntry>(parser)
} else { throw ParsingException("Wrong type for othersElem") }
othersList.add(othersElem)
} else { throw ParsingException("Wrong element type for others") }
}
others = othersList
} else { throw ParsingException("Wrong type for others") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ResourcePermissions(
myself = myself ?: throw ParsingException("Missing key 'myself'"),
others = others,
)
}
inline fun `dk_sdu_cloud_provider_api_ResourceAclEntry_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ResourceAclEntry {
var entity: dk.sdu.cloud.provider.api.AclEntity? = null
var permissions: List<dk.sdu.cloud.provider.api.Permission>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"entity" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
entity = parseJson<dk.sdu.cloud.provider.api.AclEntity>(parser)
} else { throw ParsingException("Wrong type for entity") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val permissionsList = ArrayList<dk.sdu.cloud.provider.api.Permission>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val permissionsElem: dk.sdu.cloud.provider.api.Permission
if (prop.element is JsonStreamElement.ObjectStart) {
permissionsElem = parseJson<dk.sdu.cloud.provider.api.Permission>(parser)
} else { throw ParsingException("Wrong type for permissionsElem") }
permissionsList.add(permissionsElem)
} else { throw ParsingException("Wrong element type for permissions") }
}
permissions = permissionsList
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ResourceAclEntry(
entity = entity ?: throw ParsingException("Missing key 'entity'"),
permissions = permissions ?: throw ParsingException("Missing key 'permissions'"),
)
}
inline fun `dk_sdu_cloud_provider_api_AclEntity_ProjectGroup_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.AclEntity.ProjectGroup {
var projectId: String? = null
var group: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"group" -> {
if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.AclEntity.ProjectGroup(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
group = group ?: throw ParsingException("Missing key 'group'"),
)
}
inline fun `dk_sdu_cloud_provider_api_AclEntity_User_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.AclEntity.User {
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.AclEntity.User(
username = username ?: throw ParsingException("Missing key 'username'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProviderIncludeFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProviderIncludeFlags {
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var filterName: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"filterName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterName = prop.element.value
} else { throw ParsingException("Wrong type for filterName") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProviderIncludeFlags(
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
filterName = filterName,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun <reified T> `dk_sdu_cloud_calls_BulkRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.calls.BulkRequest<T> {
var items: List<T>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"items" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val itemsList = ArrayList<T>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val itemsElem: T
if (prop.element is JsonStreamElement.ObjectStart) {
itemsElem = parseJson<T>(parser)
} else { throw ParsingException("Wrong type for itemsElem") }
itemsList.add(itemsElem)
} else { throw ParsingException("Wrong element type for items") }
}
items = itemsList
} else { throw ParsingException("Wrong type for items") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.calls.BulkRequest(
items = items ?: throw ParsingException("Missing key 'items'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProvidersRenewRefreshTokenRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProvidersRenewRefreshTokenRequestItem {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProvidersRenewRefreshTokenRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProvidersRequestApprovalRequest_Information_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProvidersRequestApprovalRequest.Information {
var specification: dk.sdu.cloud.provider.api.ProviderSpecification? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.provider.api.ProviderSpecification>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProvidersRequestApprovalRequest.Information(
specification = specification ?: throw ParsingException("Missing key 'specification'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProvidersRequestApprovalRequest_Sign_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProvidersRequestApprovalRequest.Sign {
var token: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProvidersRequestApprovalRequest.Sign(
token = token ?: throw ParsingException("Missing key 'token'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProvidersRequestApprovalResponse_RequiresSignature_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProvidersRequestApprovalResponse.RequiresSignature {
var token: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProvidersRequestApprovalResponse.RequiresSignature(
token = token ?: throw ParsingException("Missing key 'token'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProvidersRequestApprovalResponse_AwaitingAdministratorApproval_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProvidersRequestApprovalResponse.AwaitingAdministratorApproval {
var token: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProvidersRequestApprovalResponse.AwaitingAdministratorApproval(
token = token ?: throw ParsingException("Missing key 'token'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ProvidersApproveRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ProvidersApproveRequest {
var token: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ProvidersApproveRequest(
token = token ?: throw ParsingException("Missing key 'token'"),
)
}
inline fun <reified Flags> `dk_sdu_cloud_accounting_api_providers_ResourceRetrieveRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.ResourceRetrieveRequest<Flags> {
var flags: Flags? = null
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"flags" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
flags = parseJson<Flags>(parser)
} else { throw ParsingException("Wrong type for flags") }
}
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.ResourceRetrieveRequest(
flags = flags ?: throw ParsingException("Missing key 'flags'"),
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun <reified Flags> `dk_sdu_cloud_accounting_api_providers_ResourceBrowseRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.ResourceBrowseRequest<Flags> {
var flags: Flags? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
var sortBy: String? = null
var sortDirection: dk.sdu.cloud.accounting.api.providers.SortDirection? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"flags" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
flags = parseJson<Flags>(parser)
} else { throw ParsingException("Wrong type for flags") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
"sortBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
sortBy = prop.element.value
} else { throw ParsingException("Wrong type for sortBy") }
}
"sortDirection" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
sortDirection = parseJson<dk.sdu.cloud.accounting.api.providers.SortDirection?>(parser)
} else { throw ParsingException("Wrong type for sortDirection") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.ResourceBrowseRequest(
flags = flags ?: throw ParsingException("Missing key 'flags'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
sortBy = sortBy,
sortDirection = sortDirection,
)
}
inline fun <reified P, reified S> `dk_sdu_cloud_accounting_api_providers_SupportByProvider_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.SupportByProvider<P, S> {
var productsByProvider: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"productsByProvider" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for productsByProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.SupportByProvider(
productsByProvider = productsByProvider ?: throw ParsingException("Missing key 'productsByProvider'"),
)
}
inline fun <reified T> `dk_sdu_cloud_calls_BulkResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.calls.BulkResponse<T> {
var responses: List<T>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"responses" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val responsesList = ArrayList<T>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val responsesElem: T
if (prop.element is JsonStreamElement.ObjectStart) {
responsesElem = parseJson<T>(parser)
} else { throw ParsingException("Wrong type for responsesElem") }
responsesList.add(responsesElem)
} else { throw ParsingException("Wrong element type for responses") }
}
responses = responsesList
} else { throw ParsingException("Wrong type for responses") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.calls.BulkResponse(
responses = responses ?: throw ParsingException("Missing key 'responses'"),
)
}
inline fun <reified Flags> `dk_sdu_cloud_accounting_api_providers_ResourceSearchRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.ResourceSearchRequest<Flags> {
var flags: Flags? = null
var query: String? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
var sortBy: String? = null
var sortDirection: dk.sdu.cloud.accounting.api.providers.SortDirection? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"flags" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
flags = parseJson<Flags>(parser)
} else { throw ParsingException("Wrong type for flags") }
}
"query" -> {
if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
"sortBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
sortBy = prop.element.value
} else { throw ParsingException("Wrong type for sortBy") }
}
"sortDirection" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
sortDirection = parseJson<dk.sdu.cloud.accounting.api.providers.SortDirection?>(parser)
} else { throw ParsingException("Wrong type for sortDirection") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.ResourceSearchRequest(
flags = flags ?: throw ParsingException("Missing key 'flags'"),
query = query ?: throw ParsingException("Missing key 'query'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
sortBy = sortBy,
sortDirection = sortDirection,
)
}
inline fun `dk_sdu_cloud_provider_api_UpdatedAcl_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.UpdatedAcl {
var id: String? = null
var added: List<dk.sdu.cloud.provider.api.ResourceAclEntry>? = null
var deleted: List<dk.sdu.cloud.provider.api.AclEntity>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"added" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val addedList = ArrayList<dk.sdu.cloud.provider.api.ResourceAclEntry>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val addedElem: dk.sdu.cloud.provider.api.ResourceAclEntry
if (prop.element is JsonStreamElement.ObjectStart) {
addedElem = parseJson<dk.sdu.cloud.provider.api.ResourceAclEntry>(parser)
} else { throw ParsingException("Wrong type for addedElem") }
addedList.add(addedElem)
} else { throw ParsingException("Wrong element type for added") }
}
added = addedList
} else { throw ParsingException("Wrong type for added") }
}
"deleted" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val deletedList = ArrayList<dk.sdu.cloud.provider.api.AclEntity>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val deletedElem: dk.sdu.cloud.provider.api.AclEntity
if (prop.element is JsonStreamElement.ObjectStart) {
deletedElem = parseJson<dk.sdu.cloud.provider.api.AclEntity>(parser)
} else { throw ParsingException("Wrong type for deletedElem") }
deletedList.add(deletedElem)
} else { throw ParsingException("Wrong element type for deleted") }
}
deleted = deletedList
} else { throw ParsingException("Wrong type for deleted") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.UpdatedAcl(
id = id ?: throw ParsingException("Missing key 'id'"),
added = added ?: throw ParsingException("Missing key 'added'"),
deleted = deleted ?: throw ParsingException("Missing key 'deleted'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_ProductsRetrieveRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.ProductsRetrieveRequest {
var filterName: String? = null
var filterCategory: String? = null
var filterProvider: String? = null
var filterArea: dk.sdu.cloud.accounting.api.ProductType? = null
var filterVersion: Int? = null
var includeBalance: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterName" -> {
if (prop.element is JsonStreamElement.Text) {
filterName = prop.element.value
} else { throw ParsingException("Wrong type for filterName") }
}
"filterCategory" -> {
if (prop.element is JsonStreamElement.Text) {
filterCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterCategory") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterArea" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterArea = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for filterArea") }
}
"filterVersion" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterVersion = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for filterVersion") }
}
"includeBalance" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeBalance = prop.element.value
} else { throw ParsingException("Wrong type for includeBalance") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.ProductsRetrieveRequest(
filterName = filterName ?: throw ParsingException("Missing key 'filterName'"),
filterCategory = filterCategory ?: throw ParsingException("Missing key 'filterCategory'"),
filterProvider = filterProvider ?: throw ParsingException("Missing key 'filterProvider'"),
filterArea = filterArea,
filterVersion = filterVersion,
includeBalance = includeBalance,
)
}
inline fun `dk_sdu_cloud_accounting_api_ProductsBrowseRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.ProductsBrowseRequest {
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
var filterName: String? = null
var filterProvider: String? = null
var filterArea: dk.sdu.cloud.accounting.api.ProductType? = null
var filterCategory: String? = null
var filterVersion: Int? = null
var showAllVersions: Boolean? = null
var includeBalance: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
"filterName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterName = prop.element.value
} else { throw ParsingException("Wrong type for filterName") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterArea" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterArea = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for filterArea") }
}
"filterCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterCategory") }
}
"filterVersion" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterVersion = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for filterVersion") }
}
"showAllVersions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
showAllVersions = prop.element.value
} else { throw ParsingException("Wrong type for showAllVersions") }
}
"includeBalance" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeBalance = prop.element.value
} else { throw ParsingException("Wrong type for includeBalance") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.ProductsBrowseRequest(
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
filterName = filterName,
filterProvider = filterProvider,
filterArea = filterArea,
filterCategory = filterCategory,
filterVersion = filterVersion,
showAllVersions = showAllVersions,
includeBalance = includeBalance,
)
}
inline fun `dk_sdu_cloud_accounting_api_PushWalletChangeRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.PushWalletChangeRequestItem {
var allocationId: String? = null
var amount: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"allocationId" -> {
if (prop.element is JsonStreamElement.Text) {
allocationId = prop.element.value
} else { throw ParsingException("Wrong type for allocationId") }
}
"amount" -> {
if (prop.element is JsonStreamElement.Number) {
amount = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for amount") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.PushWalletChangeRequestItem(
allocationId = allocationId ?: throw ParsingException("Missing key 'allocationId'"),
amount = amount ?: throw ParsingException("Missing key 'amount'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_RegisterWalletRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.RegisterWalletRequestItem {
var owner: dk.sdu.cloud.accounting.api.WalletOwner? = null
var uniqueAllocationId: String? = null
var categoryId: String? = null
var balance: Long? = null
var providerGeneratedId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.accounting.api.WalletOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"uniqueAllocationId" -> {
if (prop.element is JsonStreamElement.Text) {
uniqueAllocationId = prop.element.value
} else { throw ParsingException("Wrong type for uniqueAllocationId") }
}
"categoryId" -> {
if (prop.element is JsonStreamElement.Text) {
categoryId = prop.element.value
} else { throw ParsingException("Wrong type for categoryId") }
}
"balance" -> {
if (prop.element is JsonStreamElement.Number) {
balance = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for balance") }
}
"providerGeneratedId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
providerGeneratedId = prop.element.value
} else { throw ParsingException("Wrong type for providerGeneratedId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.RegisterWalletRequestItem(
owner = owner ?: throw ParsingException("Missing key 'owner'"),
uniqueAllocationId = uniqueAllocationId ?: throw ParsingException("Missing key 'uniqueAllocationId'"),
categoryId = categoryId ?: throw ParsingException("Missing key 'categoryId'"),
balance = balance ?: throw ParsingException("Missing key 'balance'"),
providerGeneratedId = providerGeneratedId,
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletOwner_User_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletOwner.User {
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletOwner.User(
username = username ?: throw ParsingException("Missing key 'username'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletOwner_Project_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletOwner.Project {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletOwner.Project(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletBrowseRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletBrowseRequest {
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
var filterType: dk.sdu.cloud.accounting.api.ProductType? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
"filterType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterType = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for filterType") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletBrowseRequest(
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
filterType = filterType,
)
}
inline fun `dk_sdu_cloud_accounting_api_Wallet_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.Wallet {
var owner: dk.sdu.cloud.accounting.api.WalletOwner? = null
var paysFor: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var allocations: List<dk.sdu.cloud.accounting.api.WalletAllocation>? = null
var chargePolicy: dk.sdu.cloud.accounting.api.AllocationSelectorPolicy? = null
var productType: dk.sdu.cloud.accounting.api.ProductType? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var unit: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.accounting.api.WalletOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"paysFor" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
paysFor = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for paysFor") }
}
"allocations" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val allocationsList = ArrayList<dk.sdu.cloud.accounting.api.WalletAllocation>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val allocationsElem: dk.sdu.cloud.accounting.api.WalletAllocation
if (prop.element is JsonStreamElement.ObjectStart) {
allocationsElem = parseJson<dk.sdu.cloud.accounting.api.WalletAllocation>(parser)
} else { throw ParsingException("Wrong type for allocationsElem") }
allocationsList.add(allocationsElem)
} else { throw ParsingException("Wrong element type for allocations") }
}
allocations = allocationsList
} else { throw ParsingException("Wrong type for allocations") }
}
"chargePolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargePolicy = parseJson<dk.sdu.cloud.accounting.api.AllocationSelectorPolicy>(parser)
} else { throw ParsingException("Wrong type for chargePolicy") }
}
"productType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
productType = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for productType") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType?>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"unit" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
unit = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit?>(parser)
} else { throw ParsingException("Wrong type for unit") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.Wallet(
owner = owner ?: throw ParsingException("Missing key 'owner'"),
paysFor = paysFor ?: throw ParsingException("Missing key 'paysFor'"),
allocations = allocations ?: throw ParsingException("Missing key 'allocations'"),
chargePolicy = chargePolicy ?: throw ParsingException("Missing key 'chargePolicy'"),
productType = productType,
chargeType = chargeType,
unit = unit,
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletAllocation_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletAllocation {
var id: String? = null
var allocationPath: List<String>? = null
var balance: Long? = null
var initialBalance: Long? = null
var localBalance: Long? = null
var startDate: Long? = null
var endDate: Long? = null
var grantedIn: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"allocationPath" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val allocationPathList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val allocationPathElem: String
if (prop.element is JsonStreamElement.Text) {
allocationPathElem = prop.element.value
} else { throw ParsingException("Wrong type for allocationPathElem") }
allocationPathList.add(allocationPathElem)
} else { throw ParsingException("Wrong element type for allocationPath") }
}
allocationPath = allocationPathList
} else { throw ParsingException("Wrong type for allocationPath") }
}
"balance" -> {
if (prop.element is JsonStreamElement.Number) {
balance = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for balance") }
}
"initialBalance" -> {
if (prop.element is JsonStreamElement.Number) {
initialBalance = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for initialBalance") }
}
"localBalance" -> {
if (prop.element is JsonStreamElement.Number) {
localBalance = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for localBalance") }
}
"startDate" -> {
if (prop.element is JsonStreamElement.Number) {
startDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startDate") }
}
"endDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
endDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for endDate") }
}
"grantedIn" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
grantedIn = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for grantedIn") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletAllocation(
id = id ?: throw ParsingException("Missing key 'id'"),
allocationPath = allocationPath ?: throw ParsingException("Missing key 'allocationPath'"),
balance = balance ?: throw ParsingException("Missing key 'balance'"),
initialBalance = initialBalance ?: throw ParsingException("Missing key 'initialBalance'"),
localBalance = localBalance ?: throw ParsingException("Missing key 'localBalance'"),
startDate = startDate ?: throw ParsingException("Missing key 'startDate'"),
endDate = endDate,
grantedIn = grantedIn,
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletsSearchSubAllocationsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletsSearchSubAllocationsRequest {
var query: String? = null
var filterType: dk.sdu.cloud.accounting.api.ProductType? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"query" -> {
if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
"filterType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterType = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for filterType") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletsSearchSubAllocationsRequest(
query = query ?: throw ParsingException("Missing key 'query'"),
filterType = filterType,
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_accounting_api_SubAllocation_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.SubAllocation {
var id: String? = null
var path: String? = null
var startDate: Long? = null
var endDate: Long? = null
var productCategoryId: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var productType: dk.sdu.cloud.accounting.api.ProductType? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var unit: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var workspaceId: String? = null
var workspaceTitle: String? = null
var workspaceIsProject: Boolean? = null
var remaining: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"path" -> {
if (prop.element is JsonStreamElement.Text) {
path = prop.element.value
} else { throw ParsingException("Wrong type for path") }
}
"startDate" -> {
if (prop.element is JsonStreamElement.Number) {
startDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startDate") }
}
"endDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
endDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for endDate") }
}
"productCategoryId" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
productCategoryId = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for productCategoryId") }
}
"productType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
productType = parseJson<dk.sdu.cloud.accounting.api.ProductType>(parser)
} else { throw ParsingException("Wrong type for productType") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"unit" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unit = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unit") }
}
"workspaceId" -> {
if (prop.element is JsonStreamElement.Text) {
workspaceId = prop.element.value
} else { throw ParsingException("Wrong type for workspaceId") }
}
"workspaceTitle" -> {
if (prop.element is JsonStreamElement.Text) {
workspaceTitle = prop.element.value
} else { throw ParsingException("Wrong type for workspaceTitle") }
}
"workspaceIsProject" -> {
if (prop.element is JsonStreamElement.Bool) {
workspaceIsProject = prop.element.value
} else { throw ParsingException("Wrong type for workspaceIsProject") }
}
"remaining" -> {
if (prop.element is JsonStreamElement.Number) {
remaining = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for remaining") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.SubAllocation(
id = id ?: throw ParsingException("Missing key 'id'"),
path = path ?: throw ParsingException("Missing key 'path'"),
startDate = startDate ?: throw ParsingException("Missing key 'startDate'"),
endDate = endDate,
productCategoryId = productCategoryId ?: throw ParsingException("Missing key 'productCategoryId'"),
productType = productType ?: throw ParsingException("Missing key 'productType'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
unit = unit ?: throw ParsingException("Missing key 'unit'"),
workspaceId = workspaceId ?: throw ParsingException("Missing key 'workspaceId'"),
workspaceTitle = workspaceTitle ?: throw ParsingException("Missing key 'workspaceTitle'"),
workspaceIsProject = workspaceIsProject ?: throw ParsingException("Missing key 'workspaceIsProject'"),
remaining = remaining ?: throw ParsingException("Missing key 'remaining'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletsBrowseSubAllocationsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletsBrowseSubAllocationsRequest {
var filterType: dk.sdu.cloud.accounting.api.ProductType? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterType = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for filterType") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletsBrowseSubAllocationsRequest(
filterType = filterType,
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletsRetrieveRecipientRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletsRetrieveRecipientRequest {
var query: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"query" -> {
if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletsRetrieveRecipientRequest(
query = query ?: throw ParsingException("Missing key 'query'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_WalletsRetrieveRecipientResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.WalletsRetrieveRecipientResponse {
var id: String? = null
var isProject: Boolean? = null
var title: String? = null
var principalInvestigator: String? = null
var numberOfMembers: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"isProject" -> {
if (prop.element is JsonStreamElement.Bool) {
isProject = prop.element.value
} else { throw ParsingException("Wrong type for isProject") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"principalInvestigator" -> {
if (prop.element is JsonStreamElement.Text) {
principalInvestigator = prop.element.value
} else { throw ParsingException("Wrong type for principalInvestigator") }
}
"numberOfMembers" -> {
if (prop.element is JsonStreamElement.Number) {
numberOfMembers = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for numberOfMembers") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.WalletsRetrieveRecipientResponse(
id = id ?: throw ParsingException("Missing key 'id'"),
isProject = isProject ?: throw ParsingException("Missing key 'isProject'"),
title = title ?: throw ParsingException("Missing key 'title'"),
principalInvestigator = principalInvestigator ?: throw ParsingException("Missing key 'principalInvestigator'"),
numberOfMembers = numberOfMembers ?: throw ParsingException("Missing key 'numberOfMembers'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_ChargeWalletRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.ChargeWalletRequestItem {
var payer: dk.sdu.cloud.accounting.api.WalletOwner? = null
var units: Long? = null
var periods: Long? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var performedBy: String? = null
var description: String? = null
var transactionId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"payer" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
payer = parseJson<dk.sdu.cloud.accounting.api.WalletOwner>(parser)
} else { throw ParsingException("Wrong type for payer") }
}
"units" -> {
if (prop.element is JsonStreamElement.Number) {
units = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for units") }
}
"periods" -> {
if (prop.element is JsonStreamElement.Number) {
periods = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for periods") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"performedBy" -> {
if (prop.element is JsonStreamElement.Text) {
performedBy = prop.element.value
} else { throw ParsingException("Wrong type for performedBy") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"transactionId" -> {
if (prop.element is JsonStreamElement.Text) {
transactionId = prop.element.value
} else { throw ParsingException("Wrong type for transactionId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.ChargeWalletRequestItem(
payer = payer ?: throw ParsingException("Missing key 'payer'"),
units = units ?: throw ParsingException("Missing key 'units'"),
periods = periods ?: throw ParsingException("Missing key 'periods'"),
product = product ?: throw ParsingException("Missing key 'product'"),
performedBy = performedBy ?: throw ParsingException("Missing key 'performedBy'"),
description = description ?: throw ParsingException("Missing key 'description'"),
transactionId = transactionId ?: throw ParsingException("Missing key 'transactionId'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_DepositToWalletRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.DepositToWalletRequestItem {
var recipient: dk.sdu.cloud.accounting.api.WalletOwner? = null
var sourceAllocation: String? = null
var amount: Long? = null
var description: String? = null
var startDate: Long? = null
var endDate: Long? = null
var transactionId: String? = null
var dry: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"recipient" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
recipient = parseJson<dk.sdu.cloud.accounting.api.WalletOwner>(parser)
} else { throw ParsingException("Wrong type for recipient") }
}
"sourceAllocation" -> {
if (prop.element is JsonStreamElement.Text) {
sourceAllocation = prop.element.value
} else { throw ParsingException("Wrong type for sourceAllocation") }
}
"amount" -> {
if (prop.element is JsonStreamElement.Number) {
amount = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for amount") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"startDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
startDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startDate") }
}
"endDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
endDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for endDate") }
}
"transactionId" -> {
if (prop.element is JsonStreamElement.Text) {
transactionId = prop.element.value
} else { throw ParsingException("Wrong type for transactionId") }
}
"dry" -> {
if (prop.element is JsonStreamElement.Bool) {
dry = prop.element.value
} else { throw ParsingException("Wrong type for dry") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.DepositToWalletRequestItem(
recipient = recipient ?: throw ParsingException("Missing key 'recipient'"),
sourceAllocation = sourceAllocation ?: throw ParsingException("Missing key 'sourceAllocation'"),
amount = amount ?: throw ParsingException("Missing key 'amount'"),
description = description ?: throw ParsingException("Missing key 'description'"),
startDate = startDate,
endDate = endDate,
transactionId = transactionId ?: throw ParsingException("Missing key 'transactionId'"),
dry = dry ?: throw ParsingException("Missing key 'dry'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_TransferToWalletRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.TransferToWalletRequestItem {
var categoryId: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var target: dk.sdu.cloud.accounting.api.WalletOwner? = null
var source: dk.sdu.cloud.accounting.api.WalletOwner? = null
var amount: Long? = null
var startDate: Long? = null
var endDate: Long? = null
var transactionId: String? = null
var dry: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"categoryId" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
categoryId = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for categoryId") }
}
"target" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
target = parseJson<dk.sdu.cloud.accounting.api.WalletOwner>(parser)
} else { throw ParsingException("Wrong type for target") }
}
"source" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
source = parseJson<dk.sdu.cloud.accounting.api.WalletOwner>(parser)
} else { throw ParsingException("Wrong type for source") }
}
"amount" -> {
if (prop.element is JsonStreamElement.Number) {
amount = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for amount") }
}
"startDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
startDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startDate") }
}
"endDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
endDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for endDate") }
}
"transactionId" -> {
if (prop.element is JsonStreamElement.Text) {
transactionId = prop.element.value
} else { throw ParsingException("Wrong type for transactionId") }
}
"dry" -> {
if (prop.element is JsonStreamElement.Bool) {
dry = prop.element.value
} else { throw ParsingException("Wrong type for dry") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.TransferToWalletRequestItem(
categoryId = categoryId ?: throw ParsingException("Missing key 'categoryId'"),
target = target ?: throw ParsingException("Missing key 'target'"),
source = source ?: throw ParsingException("Missing key 'source'"),
amount = amount ?: throw ParsingException("Missing key 'amount'"),
startDate = startDate,
endDate = endDate,
transactionId = transactionId ?: throw ParsingException("Missing key 'transactionId'"),
dry = dry ?: throw ParsingException("Missing key 'dry'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_UpdateAllocationRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.UpdateAllocationRequestItem {
var id: String? = null
var balance: Long? = null
var startDate: Long? = null
var endDate: Long? = null
var reason: String? = null
var transactionId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"balance" -> {
if (prop.element is JsonStreamElement.Number) {
balance = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for balance") }
}
"startDate" -> {
if (prop.element is JsonStreamElement.Number) {
startDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startDate") }
}
"endDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
endDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for endDate") }
}
"reason" -> {
if (prop.element is JsonStreamElement.Text) {
reason = prop.element.value
} else { throw ParsingException("Wrong type for reason") }
}
"transactionId" -> {
if (prop.element is JsonStreamElement.Text) {
transactionId = prop.element.value
} else { throw ParsingException("Wrong type for transactionId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.UpdateAllocationRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
balance = balance ?: throw ParsingException("Missing key 'balance'"),
startDate = startDate ?: throw ParsingException("Missing key 'startDate'"),
endDate = endDate,
reason = reason ?: throw ParsingException("Missing key 'reason'"),
transactionId = transactionId ?: throw ParsingException("Missing key 'transactionId'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_RootDepositRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.RootDepositRequestItem {
var categoryId: dk.sdu.cloud.accounting.api.ProductCategoryId? = null
var recipient: dk.sdu.cloud.accounting.api.WalletOwner? = null
var amount: Long? = null
var description: String? = null
var startDate: Long? = null
var endDate: Long? = null
var transactionId: String? = null
var providerGeneratedId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"categoryId" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
categoryId = parseJson<dk.sdu.cloud.accounting.api.ProductCategoryId>(parser)
} else { throw ParsingException("Wrong type for categoryId") }
}
"recipient" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
recipient = parseJson<dk.sdu.cloud.accounting.api.WalletOwner>(parser)
} else { throw ParsingException("Wrong type for recipient") }
}
"amount" -> {
if (prop.element is JsonStreamElement.Number) {
amount = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for amount") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"startDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
startDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startDate") }
}
"endDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
endDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for endDate") }
}
"transactionId" -> {
if (prop.element is JsonStreamElement.Text) {
transactionId = prop.element.value
} else { throw ParsingException("Wrong type for transactionId") }
}
"providerGeneratedId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
providerGeneratedId = prop.element.value
} else { throw ParsingException("Wrong type for providerGeneratedId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.RootDepositRequestItem(
categoryId = categoryId ?: throw ParsingException("Missing key 'categoryId'"),
recipient = recipient ?: throw ParsingException("Missing key 'recipient'"),
amount = amount ?: throw ParsingException("Missing key 'amount'"),
description = description ?: throw ParsingException("Missing key 'description'"),
startDate = startDate,
endDate = endDate,
transactionId = transactionId ?: throw ParsingException("Missing key 'transactionId'"),
providerGeneratedId = providerGeneratedId,
)
}
inline fun `dk_sdu_cloud_accounting_api_VisualizationRetrieveUsageRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.VisualizationRetrieveUsageRequest {
var filterStartDate: Long? = null
var filterEndDate: Long? = null
var filterType: dk.sdu.cloud.accounting.api.ProductType? = null
var filterProvider: String? = null
var filterProductCategory: String? = null
var filterAllocation: String? = null
var filterWorkspace: String? = null
var filterWorkspaceProject: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterStartDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterStartDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterStartDate") }
}
"filterEndDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterEndDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterEndDate") }
}
"filterType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterType = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for filterType") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterAllocation" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterAllocation = prop.element.value
} else { throw ParsingException("Wrong type for filterAllocation") }
}
"filterWorkspace" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterWorkspace = prop.element.value
} else { throw ParsingException("Wrong type for filterWorkspace") }
}
"filterWorkspaceProject" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
filterWorkspaceProject = prop.element.value
} else { throw ParsingException("Wrong type for filterWorkspaceProject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.VisualizationRetrieveUsageRequest(
filterStartDate = filterStartDate,
filterEndDate = filterEndDate,
filterType = filterType,
filterProvider = filterProvider,
filterProductCategory = filterProductCategory,
filterAllocation = filterAllocation,
filterWorkspace = filterWorkspace,
filterWorkspaceProject = filterWorkspaceProject,
)
}
inline fun `dk_sdu_cloud_accounting_api_VisualizationRetrieveUsageResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.VisualizationRetrieveUsageResponse {
var charts: List<dk.sdu.cloud.accounting.api.UsageChart>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"charts" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val chartsList = ArrayList<dk.sdu.cloud.accounting.api.UsageChart>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val chartsElem: dk.sdu.cloud.accounting.api.UsageChart
if (prop.element is JsonStreamElement.ObjectStart) {
chartsElem = parseJson<dk.sdu.cloud.accounting.api.UsageChart>(parser)
} else { throw ParsingException("Wrong type for chartsElem") }
chartsList.add(chartsElem)
} else { throw ParsingException("Wrong element type for charts") }
}
charts = chartsList
} else { throw ParsingException("Wrong type for charts") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.VisualizationRetrieveUsageResponse(
charts = charts ?: throw ParsingException("Missing key 'charts'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_UsageChart_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.UsageChart {
var type: dk.sdu.cloud.accounting.api.ProductType? = null
var periodUsage: Long? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var unit: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chart: dk.sdu.cloud.accounting.api.LineChart? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"type" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
type = parseJson<dk.sdu.cloud.accounting.api.ProductType>(parser)
} else { throw ParsingException("Wrong type for type") }
}
"periodUsage" -> {
if (prop.element is JsonStreamElement.Number) {
periodUsage = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for periodUsage") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"unit" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unit = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unit") }
}
"chart" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chart = parseJson<dk.sdu.cloud.accounting.api.LineChart>(parser)
} else { throw ParsingException("Wrong type for chart") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.UsageChart(
type = type ?: throw ParsingException("Missing key 'type'"),
periodUsage = periodUsage ?: throw ParsingException("Missing key 'periodUsage'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
unit = unit ?: throw ParsingException("Missing key 'unit'"),
chart = chart ?: throw ParsingException("Missing key 'chart'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_LineChart_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.LineChart {
var lines: List<dk.sdu.cloud.accounting.api.LineChart.Line>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"lines" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val linesList = ArrayList<dk.sdu.cloud.accounting.api.LineChart.Line>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val linesElem: dk.sdu.cloud.accounting.api.LineChart.Line
if (prop.element is JsonStreamElement.ObjectStart) {
linesElem = parseJson<dk.sdu.cloud.accounting.api.LineChart.Line>(parser)
} else { throw ParsingException("Wrong type for linesElem") }
linesList.add(linesElem)
} else { throw ParsingException("Wrong element type for lines") }
}
lines = linesList
} else { throw ParsingException("Wrong type for lines") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.LineChart(
lines = lines ?: throw ParsingException("Missing key 'lines'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_LineChart_Line_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.LineChart.Line {
var name: String? = null
var points: List<dk.sdu.cloud.accounting.api.LineChart.Point>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"points" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val pointsList = ArrayList<dk.sdu.cloud.accounting.api.LineChart.Point>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val pointsElem: dk.sdu.cloud.accounting.api.LineChart.Point
if (prop.element is JsonStreamElement.ObjectStart) {
pointsElem = parseJson<dk.sdu.cloud.accounting.api.LineChart.Point>(parser)
} else { throw ParsingException("Wrong type for pointsElem") }
pointsList.add(pointsElem)
} else { throw ParsingException("Wrong element type for points") }
}
points = pointsList
} else { throw ParsingException("Wrong type for points") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.LineChart.Line(
name = name ?: throw ParsingException("Missing key 'name'"),
points = points ?: throw ParsingException("Missing key 'points'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_LineChart_Point_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.LineChart.Point {
var timestamp: Long? = null
var value: Double? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"value" -> {
if (prop.element is JsonStreamElement.Number) {
value = prop.element.value
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.LineChart.Point(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_VisualizationRetrieveBreakdownRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.VisualizationRetrieveBreakdownRequest {
var filterStartDate: Long? = null
var filterEndDate: Long? = null
var filterType: dk.sdu.cloud.accounting.api.ProductType? = null
var filterProvider: String? = null
var filterProductCategory: String? = null
var filterAllocation: String? = null
var filterWorkspace: String? = null
var filterWorkspaceProject: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterStartDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterStartDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterStartDate") }
}
"filterEndDate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterEndDate = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterEndDate") }
}
"filterType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterType = parseJson<dk.sdu.cloud.accounting.api.ProductType?>(parser)
} else { throw ParsingException("Wrong type for filterType") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterAllocation" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterAllocation = prop.element.value
} else { throw ParsingException("Wrong type for filterAllocation") }
}
"filterWorkspace" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterWorkspace = prop.element.value
} else { throw ParsingException("Wrong type for filterWorkspace") }
}
"filterWorkspaceProject" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
filterWorkspaceProject = prop.element.value
} else { throw ParsingException("Wrong type for filterWorkspaceProject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.VisualizationRetrieveBreakdownRequest(
filterStartDate = filterStartDate,
filterEndDate = filterEndDate,
filterType = filterType,
filterProvider = filterProvider,
filterProductCategory = filterProductCategory,
filterAllocation = filterAllocation,
filterWorkspace = filterWorkspace,
filterWorkspaceProject = filterWorkspaceProject,
)
}
inline fun `dk_sdu_cloud_accounting_api_VisualizationRetrieveBreakdownResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.VisualizationRetrieveBreakdownResponse {
var charts: List<dk.sdu.cloud.accounting.api.BreakdownChart>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"charts" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val chartsList = ArrayList<dk.sdu.cloud.accounting.api.BreakdownChart>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val chartsElem: dk.sdu.cloud.accounting.api.BreakdownChart
if (prop.element is JsonStreamElement.ObjectStart) {
chartsElem = parseJson<dk.sdu.cloud.accounting.api.BreakdownChart>(parser)
} else { throw ParsingException("Wrong type for chartsElem") }
chartsList.add(chartsElem)
} else { throw ParsingException("Wrong element type for charts") }
}
charts = chartsList
} else { throw ParsingException("Wrong type for charts") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.VisualizationRetrieveBreakdownResponse(
charts = charts ?: throw ParsingException("Missing key 'charts'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_BreakdownChart_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.BreakdownChart {
var type: dk.sdu.cloud.accounting.api.ProductType? = null
var chargeType: dk.sdu.cloud.accounting.api.ChargeType? = null
var unit: dk.sdu.cloud.accounting.api.ProductPriceUnit? = null
var chart: dk.sdu.cloud.accounting.api.PieChart? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"type" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
type = parseJson<dk.sdu.cloud.accounting.api.ProductType>(parser)
} else { throw ParsingException("Wrong type for type") }
}
"chargeType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chargeType = parseJson<dk.sdu.cloud.accounting.api.ChargeType>(parser)
} else { throw ParsingException("Wrong type for chargeType") }
}
"unit" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
unit = parseJson<dk.sdu.cloud.accounting.api.ProductPriceUnit>(parser)
} else { throw ParsingException("Wrong type for unit") }
}
"chart" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
chart = parseJson<dk.sdu.cloud.accounting.api.PieChart>(parser)
} else { throw ParsingException("Wrong type for chart") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.BreakdownChart(
type = type ?: throw ParsingException("Missing key 'type'"),
chargeType = chargeType ?: throw ParsingException("Missing key 'chargeType'"),
unit = unit ?: throw ParsingException("Missing key 'unit'"),
chart = chart ?: throw ParsingException("Missing key 'chart'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_PieChart_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.PieChart {
var points: List<dk.sdu.cloud.accounting.api.PieChart.Point>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"points" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val pointsList = ArrayList<dk.sdu.cloud.accounting.api.PieChart.Point>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val pointsElem: dk.sdu.cloud.accounting.api.PieChart.Point
if (prop.element is JsonStreamElement.ObjectStart) {
pointsElem = parseJson<dk.sdu.cloud.accounting.api.PieChart.Point>(parser)
} else { throw ParsingException("Wrong type for pointsElem") }
pointsList.add(pointsElem)
} else { throw ParsingException("Wrong element type for points") }
}
points = pointsList
} else { throw ParsingException("Wrong type for points") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.PieChart(
points = points ?: throw ParsingException("Missing key 'points'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_PieChart_Point_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.PieChart.Point {
var name: String? = null
var value: Double? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"value" -> {
if (prop.element is JsonStreamElement.Number) {
value = prop.element.value
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.PieChart.Point(
name = name ?: throw ParsingException("Missing key 'name'"),
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_grant_api_UploadDescriptionRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.UploadDescriptionRequest {
var projectId: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.UploadDescriptionRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_grant_api_FetchDescriptionRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.FetchDescriptionRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.FetchDescriptionRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_FetchDescriptionResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.FetchDescriptionResponse {
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.FetchDescriptionResponse(
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_grant_api_UploadLogoRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.UploadLogoRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.UploadLogoRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_FetchLogoRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.FetchLogoRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.FetchLogoRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_UploadTemplatesRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.UploadTemplatesRequest {
var personalProject: String? = null
var newProject: String? = null
var existingProject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"personalProject" -> {
if (prop.element is JsonStreamElement.Text) {
personalProject = prop.element.value
} else { throw ParsingException("Wrong type for personalProject") }
}
"newProject" -> {
if (prop.element is JsonStreamElement.Text) {
newProject = prop.element.value
} else { throw ParsingException("Wrong type for newProject") }
}
"existingProject" -> {
if (prop.element is JsonStreamElement.Text) {
existingProject = prop.element.value
} else { throw ParsingException("Wrong type for existingProject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.UploadTemplatesRequest(
personalProject = personalProject ?: throw ParsingException("Missing key 'personalProject'"),
newProject = newProject ?: throw ParsingException("Missing key 'newProject'"),
existingProject = existingProject ?: throw ParsingException("Missing key 'existingProject'"),
)
}
inline fun `dk_sdu_cloud_grant_api_ProjectApplicationSettings_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ProjectApplicationSettings {
var automaticApproval: dk.sdu.cloud.grant.api.AutomaticApprovalSettings? = null
var allowRequestsFrom: List<dk.sdu.cloud.grant.api.UserCriteria>? = null
var excludeRequestsFrom: List<dk.sdu.cloud.grant.api.UserCriteria>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"automaticApproval" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
automaticApproval = parseJson<dk.sdu.cloud.grant.api.AutomaticApprovalSettings>(parser)
} else { throw ParsingException("Wrong type for automaticApproval") }
}
"allowRequestsFrom" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val allowRequestsFromList = ArrayList<dk.sdu.cloud.grant.api.UserCriteria>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val allowRequestsFromElem: dk.sdu.cloud.grant.api.UserCriteria
if (prop.element is JsonStreamElement.ObjectStart) {
allowRequestsFromElem = parseJson<dk.sdu.cloud.grant.api.UserCriteria>(parser)
} else { throw ParsingException("Wrong type for allowRequestsFromElem") }
allowRequestsFromList.add(allowRequestsFromElem)
} else { throw ParsingException("Wrong element type for allowRequestsFrom") }
}
allowRequestsFrom = allowRequestsFromList
} else { throw ParsingException("Wrong type for allowRequestsFrom") }
}
"excludeRequestsFrom" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val excludeRequestsFromList = ArrayList<dk.sdu.cloud.grant.api.UserCriteria>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val excludeRequestsFromElem: dk.sdu.cloud.grant.api.UserCriteria
if (prop.element is JsonStreamElement.ObjectStart) {
excludeRequestsFromElem = parseJson<dk.sdu.cloud.grant.api.UserCriteria>(parser)
} else { throw ParsingException("Wrong type for excludeRequestsFromElem") }
excludeRequestsFromList.add(excludeRequestsFromElem)
} else { throw ParsingException("Wrong element type for excludeRequestsFrom") }
}
excludeRequestsFrom = excludeRequestsFromList
} else { throw ParsingException("Wrong type for excludeRequestsFrom") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ProjectApplicationSettings(
automaticApproval = automaticApproval ?: throw ParsingException("Missing key 'automaticApproval'"),
allowRequestsFrom = allowRequestsFrom ?: throw ParsingException("Missing key 'allowRequestsFrom'"),
excludeRequestsFrom = excludeRequestsFrom ?: throw ParsingException("Missing key 'excludeRequestsFrom'"),
)
}
inline fun `dk_sdu_cloud_grant_api_AutomaticApprovalSettings_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.AutomaticApprovalSettings {
var from: List<dk.sdu.cloud.grant.api.UserCriteria>? = null
var maxResources: List<dk.sdu.cloud.grant.api.ResourceRequest>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"from" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val fromList = ArrayList<dk.sdu.cloud.grant.api.UserCriteria>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val fromElem: dk.sdu.cloud.grant.api.UserCriteria
if (prop.element is JsonStreamElement.ObjectStart) {
fromElem = parseJson<dk.sdu.cloud.grant.api.UserCriteria>(parser)
} else { throw ParsingException("Wrong type for fromElem") }
fromList.add(fromElem)
} else { throw ParsingException("Wrong element type for from") }
}
from = fromList
} else { throw ParsingException("Wrong type for from") }
}
"maxResources" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val maxResourcesList = ArrayList<dk.sdu.cloud.grant.api.ResourceRequest>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val maxResourcesElem: dk.sdu.cloud.grant.api.ResourceRequest
if (prop.element is JsonStreamElement.ObjectStart) {
maxResourcesElem = parseJson<dk.sdu.cloud.grant.api.ResourceRequest>(parser)
} else { throw ParsingException("Wrong type for maxResourcesElem") }
maxResourcesList.add(maxResourcesElem)
} else { throw ParsingException("Wrong element type for maxResources") }
}
maxResources = maxResourcesList
} else { throw ParsingException("Wrong type for maxResources") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.AutomaticApprovalSettings(
from = from ?: throw ParsingException("Missing key 'from'"),
maxResources = maxResources ?: throw ParsingException("Missing key 'maxResources'"),
)
}
inline fun `dk_sdu_cloud_grant_api_UserCriteria_Anyone_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.UserCriteria.Anyone {
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.UserCriteria.Anyone(
)
}
inline fun `dk_sdu_cloud_grant_api_UserCriteria_EmailDomain_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.UserCriteria.EmailDomain {
var domain: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"domain" -> {
if (prop.element is JsonStreamElement.Text) {
domain = prop.element.value
} else { throw ParsingException("Wrong type for domain") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.UserCriteria.EmailDomain(
domain = domain ?: throw ParsingException("Missing key 'domain'"),
)
}
inline fun `dk_sdu_cloud_grant_api_UserCriteria_WayfOrganization_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.UserCriteria.WayfOrganization {
var org: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"org" -> {
if (prop.element is JsonStreamElement.Text) {
org = prop.element.value
} else { throw ParsingException("Wrong type for org") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.UserCriteria.WayfOrganization(
org = org ?: throw ParsingException("Missing key 'org'"),
)
}
inline fun `dk_sdu_cloud_grant_api_ResourceRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ResourceRequest {
var productCategory: String? = null
var productProvider: String? = null
var balanceRequested: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"productCategory" -> {
if (prop.element is JsonStreamElement.Text) {
productCategory = prop.element.value
} else { throw ParsingException("Wrong type for productCategory") }
}
"productProvider" -> {
if (prop.element is JsonStreamElement.Text) {
productProvider = prop.element.value
} else { throw ParsingException("Wrong type for productProvider") }
}
"balanceRequested" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
balanceRequested = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for balanceRequested") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ResourceRequest(
productCategory = productCategory ?: throw ParsingException("Missing key 'productCategory'"),
productProvider = productProvider ?: throw ParsingException("Missing key 'productProvider'"),
balanceRequested = balanceRequested,
)
}
inline fun `dk_sdu_cloud_grant_api_ReadRequestSettingsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ReadRequestSettingsRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ReadRequestSettingsRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_ReadTemplatesRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ReadTemplatesRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ReadTemplatesRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_CreateApplication_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.CreateApplication {
var resourcesOwnedBy: String? = null
var grantRecipient: dk.sdu.cloud.grant.api.GrantRecipient? = null
var document: String? = null
var requestedResources: List<dk.sdu.cloud.grant.api.ResourceRequest>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resourcesOwnedBy" -> {
if (prop.element is JsonStreamElement.Text) {
resourcesOwnedBy = prop.element.value
} else { throw ParsingException("Wrong type for resourcesOwnedBy") }
}
"grantRecipient" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
grantRecipient = parseJson<dk.sdu.cloud.grant.api.GrantRecipient>(parser)
} else { throw ParsingException("Wrong type for grantRecipient") }
}
"document" -> {
if (prop.element is JsonStreamElement.Text) {
document = prop.element.value
} else { throw ParsingException("Wrong type for document") }
}
"requestedResources" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val requestedResourcesList = ArrayList<dk.sdu.cloud.grant.api.ResourceRequest>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val requestedResourcesElem: dk.sdu.cloud.grant.api.ResourceRequest
if (prop.element is JsonStreamElement.ObjectStart) {
requestedResourcesElem = parseJson<dk.sdu.cloud.grant.api.ResourceRequest>(parser)
} else { throw ParsingException("Wrong type for requestedResourcesElem") }
requestedResourcesList.add(requestedResourcesElem)
} else { throw ParsingException("Wrong element type for requestedResources") }
}
requestedResources = requestedResourcesList
} else { throw ParsingException("Wrong type for requestedResources") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.CreateApplication(
resourcesOwnedBy = resourcesOwnedBy ?: throw ParsingException("Missing key 'resourcesOwnedBy'"),
grantRecipient = grantRecipient ?: throw ParsingException("Missing key 'grantRecipient'"),
document = document ?: throw ParsingException("Missing key 'document'"),
requestedResources = requestedResources ?: throw ParsingException("Missing key 'requestedResources'"),
)
}
inline fun `dk_sdu_cloud_grant_api_GrantRecipient_PersonalProject_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.GrantRecipient.PersonalProject {
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.GrantRecipient.PersonalProject(
username = username ?: throw ParsingException("Missing key 'username'"),
)
}
inline fun `dk_sdu_cloud_grant_api_GrantRecipient_ExistingProject_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.GrantRecipient.ExistingProject {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.GrantRecipient.ExistingProject(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_GrantRecipient_NewProject_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.GrantRecipient.NewProject {
var projectTitle: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.GrantRecipient.NewProject(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
)
}
inline fun `dk_sdu_cloud_FindByLongId_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.FindByLongId {
var id: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.FindByLongId(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_grant_api_CommentOnApplicationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.CommentOnApplicationRequest {
var requestId: Long? = null
var comment: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"requestId" -> {
if (prop.element is JsonStreamElement.Number) {
requestId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for requestId") }
}
"comment" -> {
if (prop.element is JsonStreamElement.Text) {
comment = prop.element.value
} else { throw ParsingException("Wrong type for comment") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.CommentOnApplicationRequest(
requestId = requestId ?: throw ParsingException("Missing key 'requestId'"),
comment = comment ?: throw ParsingException("Missing key 'comment'"),
)
}
inline fun `dk_sdu_cloud_grant_api_DeleteCommentRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.DeleteCommentRequest {
var commentId: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"commentId" -> {
if (prop.element is JsonStreamElement.Number) {
commentId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for commentId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.DeleteCommentRequest(
commentId = commentId ?: throw ParsingException("Missing key 'commentId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_ApproveApplicationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ApproveApplicationRequest {
var requestId: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"requestId" -> {
if (prop.element is JsonStreamElement.Number) {
requestId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for requestId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ApproveApplicationRequest(
requestId = requestId ?: throw ParsingException("Missing key 'requestId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_RejectApplicationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.RejectApplicationRequest {
var requestId: Long? = null
var notify: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"requestId" -> {
if (prop.element is JsonStreamElement.Number) {
requestId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for requestId") }
}
"notify" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
notify = prop.element.value
} else { throw ParsingException("Wrong type for notify") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.RejectApplicationRequest(
requestId = requestId ?: throw ParsingException("Missing key 'requestId'"),
notify = notify,
)
}
inline fun `dk_sdu_cloud_grant_api_EditApplicationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.EditApplicationRequest {
var id: Long? = null
var newDocument: String? = null
var newResources: List<dk.sdu.cloud.grant.api.ResourceRequest>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"newDocument" -> {
if (prop.element is JsonStreamElement.Text) {
newDocument = prop.element.value
} else { throw ParsingException("Wrong type for newDocument") }
}
"newResources" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val newResourcesList = ArrayList<dk.sdu.cloud.grant.api.ResourceRequest>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val newResourcesElem: dk.sdu.cloud.grant.api.ResourceRequest
if (prop.element is JsonStreamElement.ObjectStart) {
newResourcesElem = parseJson<dk.sdu.cloud.grant.api.ResourceRequest>(parser)
} else { throw ParsingException("Wrong type for newResourcesElem") }
newResourcesList.add(newResourcesElem)
} else { throw ParsingException("Wrong element type for newResources") }
}
newResources = newResourcesList
} else { throw ParsingException("Wrong type for newResources") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.EditApplicationRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
newDocument = newDocument ?: throw ParsingException("Missing key 'newDocument'"),
newResources = newResources ?: throw ParsingException("Missing key 'newResources'"),
)
}
inline fun `dk_sdu_cloud_grant_api_EditReferenceIdRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.EditReferenceIdRequest {
var id: Long? = null
var newReferenceId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"newReferenceId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
newReferenceId = prop.element.value
} else { throw ParsingException("Wrong type for newReferenceId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.EditReferenceIdRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
newReferenceId = newReferenceId,
)
}
inline fun `dk_sdu_cloud_grant_api_CloseApplicationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.CloseApplicationRequest {
var requestId: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"requestId" -> {
if (prop.element is JsonStreamElement.Number) {
requestId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for requestId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.CloseApplicationRequest(
requestId = requestId ?: throw ParsingException("Missing key 'requestId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_TransferApplicationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.TransferApplicationRequest {
var applicationId: Long? = null
var transferToProjectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"applicationId" -> {
if (prop.element is JsonStreamElement.Number) {
applicationId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for applicationId") }
}
"transferToProjectId" -> {
if (prop.element is JsonStreamElement.Text) {
transferToProjectId = prop.element.value
} else { throw ParsingException("Wrong type for transferToProjectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.TransferApplicationRequest(
applicationId = applicationId ?: throw ParsingException("Missing key 'applicationId'"),
transferToProjectId = transferToProjectId ?: throw ParsingException("Missing key 'transferToProjectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_IngoingApplicationsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.IngoingApplicationsRequest {
var filter: dk.sdu.cloud.grant.api.GrantApplicationFilter? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filter" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
filter = parseJson<dk.sdu.cloud.grant.api.GrantApplicationFilter>(parser)
} else { throw ParsingException("Wrong type for filter") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.IngoingApplicationsRequest(
filter = filter ?: throw ParsingException("Missing key 'filter'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_grant_api_Application_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.Application {
var status: dk.sdu.cloud.grant.api.ApplicationStatus? = null
var resourcesOwnedBy: String? = null
var requestedBy: String? = null
var grantRecipient: dk.sdu.cloud.grant.api.GrantRecipient? = null
var document: String? = null
var requestedResources: List<dk.sdu.cloud.grant.api.ResourceRequest>? = null
var id: Long? = null
var resourcesOwnedByTitle: String? = null
var grantRecipientPi: String? = null
var grantRecipientTitle: String? = null
var createdAt: Long? = null
var updatedAt: Long? = null
var statusChangedBy: String? = null
var referenceId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.grant.api.ApplicationStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"resourcesOwnedBy" -> {
if (prop.element is JsonStreamElement.Text) {
resourcesOwnedBy = prop.element.value
} else { throw ParsingException("Wrong type for resourcesOwnedBy") }
}
"requestedBy" -> {
if (prop.element is JsonStreamElement.Text) {
requestedBy = prop.element.value
} else { throw ParsingException("Wrong type for requestedBy") }
}
"grantRecipient" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
grantRecipient = parseJson<dk.sdu.cloud.grant.api.GrantRecipient>(parser)
} else { throw ParsingException("Wrong type for grantRecipient") }
}
"document" -> {
if (prop.element is JsonStreamElement.Text) {
document = prop.element.value
} else { throw ParsingException("Wrong type for document") }
}
"requestedResources" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val requestedResourcesList = ArrayList<dk.sdu.cloud.grant.api.ResourceRequest>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val requestedResourcesElem: dk.sdu.cloud.grant.api.ResourceRequest
if (prop.element is JsonStreamElement.ObjectStart) {
requestedResourcesElem = parseJson<dk.sdu.cloud.grant.api.ResourceRequest>(parser)
} else { throw ParsingException("Wrong type for requestedResourcesElem") }
requestedResourcesList.add(requestedResourcesElem)
} else { throw ParsingException("Wrong element type for requestedResources") }
}
requestedResources = requestedResourcesList
} else { throw ParsingException("Wrong type for requestedResources") }
}
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"resourcesOwnedByTitle" -> {
if (prop.element is JsonStreamElement.Text) {
resourcesOwnedByTitle = prop.element.value
} else { throw ParsingException("Wrong type for resourcesOwnedByTitle") }
}
"grantRecipientPi" -> {
if (prop.element is JsonStreamElement.Text) {
grantRecipientPi = prop.element.value
} else { throw ParsingException("Wrong type for grantRecipientPi") }
}
"grantRecipientTitle" -> {
if (prop.element is JsonStreamElement.Text) {
grantRecipientTitle = prop.element.value
} else { throw ParsingException("Wrong type for grantRecipientTitle") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"updatedAt" -> {
if (prop.element is JsonStreamElement.Number) {
updatedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for updatedAt") }
}
"statusChangedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
statusChangedBy = prop.element.value
} else { throw ParsingException("Wrong type for statusChangedBy") }
}
"referenceId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
referenceId = prop.element.value
} else { throw ParsingException("Wrong type for referenceId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.Application(
status = status ?: throw ParsingException("Missing key 'status'"),
resourcesOwnedBy = resourcesOwnedBy ?: throw ParsingException("Missing key 'resourcesOwnedBy'"),
requestedBy = requestedBy ?: throw ParsingException("Missing key 'requestedBy'"),
grantRecipient = grantRecipient ?: throw ParsingException("Missing key 'grantRecipient'"),
document = document ?: throw ParsingException("Missing key 'document'"),
requestedResources = requestedResources ?: throw ParsingException("Missing key 'requestedResources'"),
id = id ?: throw ParsingException("Missing key 'id'"),
resourcesOwnedByTitle = resourcesOwnedByTitle ?: throw ParsingException("Missing key 'resourcesOwnedByTitle'"),
grantRecipientPi = grantRecipientPi ?: throw ParsingException("Missing key 'grantRecipientPi'"),
grantRecipientTitle = grantRecipientTitle ?: throw ParsingException("Missing key 'grantRecipientTitle'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
updatedAt = updatedAt ?: throw ParsingException("Missing key 'updatedAt'"),
statusChangedBy = statusChangedBy,
referenceId = referenceId,
)
}
inline fun `dk_sdu_cloud_grant_api_OutgoingApplicationsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.OutgoingApplicationsRequest {
var filter: dk.sdu.cloud.grant.api.GrantApplicationFilter? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filter" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
filter = parseJson<dk.sdu.cloud.grant.api.GrantApplicationFilter>(parser)
} else { throw ParsingException("Wrong type for filter") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.OutgoingApplicationsRequest(
filter = filter ?: throw ParsingException("Missing key 'filter'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_grant_api_SetEnabledStatusRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.SetEnabledStatusRequest {
var projectId: String? = null
var enabledStatus: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"enabledStatus" -> {
if (prop.element is JsonStreamElement.Bool) {
enabledStatus = prop.element.value
} else { throw ParsingException("Wrong type for enabledStatus") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.SetEnabledStatusRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
enabledStatus = enabledStatus ?: throw ParsingException("Missing key 'enabledStatus'"),
)
}
inline fun `dk_sdu_cloud_grant_api_IsEnabledRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.IsEnabledRequest {
var projectId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.IsEnabledRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_IsEnabledResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.IsEnabledResponse {
var enabled: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"enabled" -> {
if (prop.element is JsonStreamElement.Bool) {
enabled = prop.element.value
} else { throw ParsingException("Wrong type for enabled") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.IsEnabledResponse(
enabled = enabled ?: throw ParsingException("Missing key 'enabled'"),
)
}
inline fun `dk_sdu_cloud_grant_api_BrowseProjectsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.BrowseProjectsRequest {
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.BrowseProjectsRequest(
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_grant_api_ProjectWithTitle_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ProjectWithTitle {
var projectId: String? = null
var title: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ProjectWithTitle(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
title = title ?: throw ParsingException("Missing key 'title'"),
)
}
inline fun `dk_sdu_cloud_grant_api_GrantsRetrieveAffiliationsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.GrantsRetrieveAffiliationsRequest {
var grantId: Long? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"grantId" -> {
if (prop.element is JsonStreamElement.Number) {
grantId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for grantId") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.GrantsRetrieveAffiliationsRequest(
grantId = grantId ?: throw ParsingException("Missing key 'grantId'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_grant_api_GrantsRetrieveProductsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.GrantsRetrieveProductsRequest {
var projectId: String? = null
var recipientType: String? = null
var recipientId: String? = null
var showHidden: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectId" -> {
if (prop.element is JsonStreamElement.Text) {
projectId = prop.element.value
} else { throw ParsingException("Wrong type for projectId") }
}
"recipientType" -> {
if (prop.element is JsonStreamElement.Text) {
recipientType = prop.element.value
} else { throw ParsingException("Wrong type for recipientType") }
}
"recipientId" -> {
if (prop.element is JsonStreamElement.Text) {
recipientId = prop.element.value
} else { throw ParsingException("Wrong type for recipientId") }
}
"showHidden" -> {
if (prop.element is JsonStreamElement.Bool) {
showHidden = prop.element.value
} else { throw ParsingException("Wrong type for showHidden") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.GrantsRetrieveProductsRequest(
projectId = projectId ?: throw ParsingException("Missing key 'projectId'"),
recipientType = recipientType ?: throw ParsingException("Missing key 'recipientType'"),
recipientId = recipientId ?: throw ParsingException("Missing key 'recipientId'"),
showHidden = showHidden ?: throw ParsingException("Missing key 'showHidden'"),
)
}
inline fun `dk_sdu_cloud_grant_api_GrantsRetrieveProductsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.GrantsRetrieveProductsResponse {
var availableProducts: List<dk.sdu.cloud.accounting.api.Product>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"availableProducts" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val availableProductsList = ArrayList<dk.sdu.cloud.accounting.api.Product>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val availableProductsElem: dk.sdu.cloud.accounting.api.Product
if (prop.element is JsonStreamElement.ObjectStart) {
availableProductsElem = parseJson<dk.sdu.cloud.accounting.api.Product>(parser)
} else { throw ParsingException("Wrong type for availableProductsElem") }
availableProductsList.add(availableProductsElem)
} else { throw ParsingException("Wrong element type for availableProducts") }
}
availableProducts = availableProductsList
} else { throw ParsingException("Wrong type for availableProducts") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.GrantsRetrieveProductsResponse(
availableProducts = availableProducts ?: throw ParsingException("Missing key 'availableProducts'"),
)
}
inline fun `dk_sdu_cloud_grant_api_ViewApplicationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ViewApplicationRequest {
var id: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ViewApplicationRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_grant_api_ApplicationWithComments_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ApplicationWithComments {
var application: dk.sdu.cloud.grant.api.Application? = null
var comments: List<dk.sdu.cloud.grant.api.Comment>? = null
var approver: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"application" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
application = parseJson<dk.sdu.cloud.grant.api.Application>(parser)
} else { throw ParsingException("Wrong type for application") }
}
"comments" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val commentsList = ArrayList<dk.sdu.cloud.grant.api.Comment>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val commentsElem: dk.sdu.cloud.grant.api.Comment
if (prop.element is JsonStreamElement.ObjectStart) {
commentsElem = parseJson<dk.sdu.cloud.grant.api.Comment>(parser)
} else { throw ParsingException("Wrong type for commentsElem") }
commentsList.add(commentsElem)
} else { throw ParsingException("Wrong element type for comments") }
}
comments = commentsList
} else { throw ParsingException("Wrong type for comments") }
}
"approver" -> {
if (prop.element is JsonStreamElement.Bool) {
approver = prop.element.value
} else { throw ParsingException("Wrong type for approver") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ApplicationWithComments(
application = application ?: throw ParsingException("Missing key 'application'"),
comments = comments ?: throw ParsingException("Missing key 'comments'"),
approver = approver ?: throw ParsingException("Missing key 'approver'"),
)
}
inline fun `dk_sdu_cloud_grant_api_Comment_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.Comment {
var id: Long? = null
var postedBy: String? = null
var postedAt: Long? = null
var comment: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"postedBy" -> {
if (prop.element is JsonStreamElement.Text) {
postedBy = prop.element.value
} else { throw ParsingException("Wrong type for postedBy") }
}
"postedAt" -> {
if (prop.element is JsonStreamElement.Number) {
postedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for postedAt") }
}
"comment" -> {
if (prop.element is JsonStreamElement.Text) {
comment = prop.element.value
} else { throw ParsingException("Wrong type for comment") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.Comment(
id = id ?: throw ParsingException("Missing key 'id'"),
postedBy = postedBy ?: throw ParsingException("Missing key 'postedBy'"),
postedAt = postedAt ?: throw ParsingException("Missing key 'postedAt'"),
comment = comment ?: throw ParsingException("Missing key 'comment'"),
)
}
inline fun `dk_sdu_cloud_grant_api_ClaimGiftRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.ClaimGiftRequest {
var giftId: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"giftId" -> {
if (prop.element is JsonStreamElement.Number) {
giftId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for giftId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.ClaimGiftRequest(
giftId = giftId ?: throw ParsingException("Missing key 'giftId'"),
)
}
inline fun `dk_sdu_cloud_grant_api_AvailableGiftsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.AvailableGiftsResponse {
var gifts: List<dk.sdu.cloud.FindByLongId>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"gifts" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val giftsList = ArrayList<dk.sdu.cloud.FindByLongId>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val giftsElem: dk.sdu.cloud.FindByLongId
if (prop.element is JsonStreamElement.ObjectStart) {
giftsElem = parseJson<dk.sdu.cloud.FindByLongId>(parser)
} else { throw ParsingException("Wrong type for giftsElem") }
giftsList.add(giftsElem)
} else { throw ParsingException("Wrong element type for gifts") }
}
gifts = giftsList
} else { throw ParsingException("Wrong type for gifts") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.AvailableGiftsResponse(
gifts = gifts ?: throw ParsingException("Missing key 'gifts'"),
)
}
inline fun `dk_sdu_cloud_grant_api_GiftWithCriteria_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.GiftWithCriteria {
var id: Long? = null
var resourcesOwnedBy: String? = null
var title: String? = null
var description: String? = null
var resources: List<dk.sdu.cloud.grant.api.ResourceRequest>? = null
var criteria: List<dk.sdu.cloud.grant.api.UserCriteria>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"resourcesOwnedBy" -> {
if (prop.element is JsonStreamElement.Text) {
resourcesOwnedBy = prop.element.value
} else { throw ParsingException("Wrong type for resourcesOwnedBy") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"resources" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val resourcesList = ArrayList<dk.sdu.cloud.grant.api.ResourceRequest>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val resourcesElem: dk.sdu.cloud.grant.api.ResourceRequest
if (prop.element is JsonStreamElement.ObjectStart) {
resourcesElem = parseJson<dk.sdu.cloud.grant.api.ResourceRequest>(parser)
} else { throw ParsingException("Wrong type for resourcesElem") }
resourcesList.add(resourcesElem)
} else { throw ParsingException("Wrong element type for resources") }
}
resources = resourcesList
} else { throw ParsingException("Wrong type for resources") }
}
"criteria" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val criteriaList = ArrayList<dk.sdu.cloud.grant.api.UserCriteria>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val criteriaElem: dk.sdu.cloud.grant.api.UserCriteria
if (prop.element is JsonStreamElement.ObjectStart) {
criteriaElem = parseJson<dk.sdu.cloud.grant.api.UserCriteria>(parser)
} else { throw ParsingException("Wrong type for criteriaElem") }
criteriaList.add(criteriaElem)
} else { throw ParsingException("Wrong element type for criteria") }
}
criteria = criteriaList
} else { throw ParsingException("Wrong type for criteria") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.GiftWithCriteria(
id = id ?: throw ParsingException("Missing key 'id'"),
resourcesOwnedBy = resourcesOwnedBy ?: throw ParsingException("Missing key 'resourcesOwnedBy'"),
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
resources = resources ?: throw ParsingException("Missing key 'resources'"),
criteria = criteria ?: throw ParsingException("Missing key 'criteria'"),
)
}
inline fun `dk_sdu_cloud_grant_api_DeleteGiftRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.grant.api.DeleteGiftRequest {
var giftId: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"giftId" -> {
if (prop.element is JsonStreamElement.Number) {
giftId = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for giftId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.grant.api.DeleteGiftRequest(
giftId = giftId ?: throw ParsingException("Missing key 'giftId'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ExampleResource_Spec_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ExampleResource.Spec {
var start: Int? = null
var target: Int? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"start" -> {
if (prop.element is JsonStreamElement.Number) {
start = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for start") }
}
"target" -> {
if (prop.element is JsonStreamElement.Number) {
target = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for target") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ExampleResource.Spec(
start = start ?: throw ParsingException("Missing key 'start'"),
target = target ?: throw ParsingException("Missing key 'target'"),
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ExampleResource_Update_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ExampleResource.Update {
var timestamp: Long? = null
var status: String? = null
var newState: dk.sdu.cloud.provider.api.ExampleResource.State? = null
var currentValue: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
"newState" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
newState = parseJson<dk.sdu.cloud.provider.api.ExampleResource.State?>(parser)
} else { throw ParsingException("Wrong type for newState") }
}
"currentValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
currentValue = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for currentValue") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ExampleResource.Update(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
status = status,
newState = newState,
currentValue = currentValue,
)
}
inline fun `dk_sdu_cloud_provider_api_ExampleResourceSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ExampleResourceSupport {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var supportsBackwardsCounting: dk.sdu.cloud.provider.api.ExampleResourceSupport.Supported? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"supportsBackwardsCounting" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
supportsBackwardsCounting = parseJson<dk.sdu.cloud.provider.api.ExampleResourceSupport.Supported>(parser)
} else { throw ParsingException("Wrong type for supportsBackwardsCounting") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ExampleResourceSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
supportsBackwardsCounting = supportsBackwardsCounting ?: throw ParsingException("Missing key 'supportsBackwardsCounting'"),
)
}
inline fun `dk_sdu_cloud_provider_api_ExampleResource_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ExampleResource {
var id: String? = null
var specification: dk.sdu.cloud.provider.api.ExampleResource.Spec? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.provider.api.ExampleResource.Status? = null
var updates: List<dk.sdu.cloud.provider.api.ExampleResource.Update>? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.provider.api.ExampleResource.Spec>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.provider.api.ExampleResource.Status>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.provider.api.ExampleResource.Update>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.provider.api.ExampleResource.Update
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.provider.api.ExampleResource.Update>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ExampleResource(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_provider_api_ExampleResource_Status_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ExampleResource.Status {
var state: dk.sdu.cloud.provider.api.ExampleResource.State? = null
var value: Int? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product, dk.sdu.cloud.provider.api.ExampleResourceSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"state" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.provider.api.ExampleResource.State>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"value" -> {
if (prop.element is JsonStreamElement.Number) {
value = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for value") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product, dk.sdu.cloud.provider.api.ExampleResourceSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ExampleResource.Status(
state = state ?: throw ParsingException("Missing key 'state'"),
value = value ?: throw ParsingException("Missing key 'value'"),
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_provider_api_ExampleResourceFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ExampleResourceFlags {
var filterState: dk.sdu.cloud.provider.api.ExampleResource.State? = null
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterState" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterState = parseJson<dk.sdu.cloud.provider.api.ExampleResource.State?>(parser)
} else { throw ParsingException("Wrong type for filterState") }
}
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ExampleResourceFlags(
filterState = filterState,
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileCollection_Spec_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileCollection.Spec {
var title: String? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileCollection.Spec(
title = title ?: throw ParsingException("Missing key 'title'"),
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileCollection_Update_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileCollection.Update {
var timestamp: Long? = null
var status: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileCollection.Update(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
status = status,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FSSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FSSupport {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var stats: dk.sdu.cloud.file.orchestrator.api.FSProductStatsSupport? = null
var collection: dk.sdu.cloud.file.orchestrator.api.FSCollectionSupport? = null
var files: dk.sdu.cloud.file.orchestrator.api.FSFileSupport? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"stats" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
stats = parseJson<dk.sdu.cloud.file.orchestrator.api.FSProductStatsSupport>(parser)
} else { throw ParsingException("Wrong type for stats") }
}
"collection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
collection = parseJson<dk.sdu.cloud.file.orchestrator.api.FSCollectionSupport>(parser)
} else { throw ParsingException("Wrong type for collection") }
}
"files" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
files = parseJson<dk.sdu.cloud.file.orchestrator.api.FSFileSupport>(parser)
} else { throw ParsingException("Wrong type for files") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FSSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
stats = stats ?: throw ParsingException("Missing key 'stats'"),
collection = collection ?: throw ParsingException("Missing key 'collection'"),
files = files ?: throw ParsingException("Missing key 'files'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FSProductStatsSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FSProductStatsSupport {
var sizeInBytes: Boolean? = null
var sizeIncludingChildrenInBytes: Boolean? = null
var modifiedAt: Boolean? = null
var createdAt: Boolean? = null
var accessedAt: Boolean? = null
var unixPermissions: Boolean? = null
var unixOwner: Boolean? = null
var unixGroup: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sizeInBytes" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
sizeInBytes = prop.element.value
} else { throw ParsingException("Wrong type for sizeInBytes") }
}
"sizeIncludingChildrenInBytes" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
sizeIncludingChildrenInBytes = prop.element.value
} else { throw ParsingException("Wrong type for sizeIncludingChildrenInBytes") }
}
"modifiedAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
modifiedAt = prop.element.value
} else { throw ParsingException("Wrong type for modifiedAt") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
createdAt = prop.element.value
} else { throw ParsingException("Wrong type for createdAt") }
}
"accessedAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
accessedAt = prop.element.value
} else { throw ParsingException("Wrong type for accessedAt") }
}
"unixPermissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
unixPermissions = prop.element.value
} else { throw ParsingException("Wrong type for unixPermissions") }
}
"unixOwner" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
unixOwner = prop.element.value
} else { throw ParsingException("Wrong type for unixOwner") }
}
"unixGroup" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
unixGroup = prop.element.value
} else { throw ParsingException("Wrong type for unixGroup") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FSProductStatsSupport(
sizeInBytes = sizeInBytes,
sizeIncludingChildrenInBytes = sizeIncludingChildrenInBytes,
modifiedAt = modifiedAt,
createdAt = createdAt,
accessedAt = accessedAt,
unixPermissions = unixPermissions,
unixOwner = unixOwner,
unixGroup = unixGroup,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FSCollectionSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FSCollectionSupport {
var aclModifiable: Boolean? = null
var usersCanCreate: Boolean? = null
var usersCanDelete: Boolean? = null
var usersCanRename: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"aclModifiable" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
aclModifiable = prop.element.value
} else { throw ParsingException("Wrong type for aclModifiable") }
}
"usersCanCreate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
usersCanCreate = prop.element.value
} else { throw ParsingException("Wrong type for usersCanCreate") }
}
"usersCanDelete" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
usersCanDelete = prop.element.value
} else { throw ParsingException("Wrong type for usersCanDelete") }
}
"usersCanRename" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
usersCanRename = prop.element.value
} else { throw ParsingException("Wrong type for usersCanRename") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FSCollectionSupport(
aclModifiable = aclModifiable,
usersCanCreate = usersCanCreate,
usersCanDelete = usersCanDelete,
usersCanRename = usersCanRename,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FSFileSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FSFileSupport {
var aclModifiable: Boolean? = null
var trashSupported: Boolean? = null
var isReadOnly: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"aclModifiable" -> {
if (prop.element is JsonStreamElement.Bool) {
aclModifiable = prop.element.value
} else { throw ParsingException("Wrong type for aclModifiable") }
}
"trashSupported" -> {
if (prop.element is JsonStreamElement.Bool) {
trashSupported = prop.element.value
} else { throw ParsingException("Wrong type for trashSupported") }
}
"isReadOnly" -> {
if (prop.element is JsonStreamElement.Bool) {
isReadOnly = prop.element.value
} else { throw ParsingException("Wrong type for isReadOnly") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FSFileSupport(
aclModifiable = aclModifiable ?: throw ParsingException("Missing key 'aclModifiable'"),
trashSupported = trashSupported ?: throw ParsingException("Missing key 'trashSupported'"),
isReadOnly = isReadOnly ?: throw ParsingException("Missing key 'isReadOnly'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileCollection_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileCollection {
var id: String? = null
var specification: dk.sdu.cloud.file.orchestrator.api.FileCollection.Spec? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.file.orchestrator.api.FileCollection.Status? = null
var updates: List<dk.sdu.cloud.file.orchestrator.api.FileCollection.Update>? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
var providerGeneratedId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection.Spec>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection.Status>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.file.orchestrator.api.FileCollection.Update>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.file.orchestrator.api.FileCollection.Update
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection.Update>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
"providerGeneratedId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
providerGeneratedId = prop.element.value
} else { throw ParsingException("Wrong type for providerGeneratedId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileCollection(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
permissions = permissions,
providerGeneratedId = providerGeneratedId,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileCollection_Status_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileCollection.Status {
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Storage, dk.sdu.cloud.file.orchestrator.api.FSSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.Storage? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Storage, dk.sdu.cloud.file.orchestrator.api.FSSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.Storage?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileCollection.Status(
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileCollectionIncludeFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileCollectionIncludeFlags {
var filterMemberFiles: dk.sdu.cloud.file.orchestrator.api.MemberFilesFilter? = null
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterMemberFiles" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterMemberFiles = parseJson<dk.sdu.cloud.file.orchestrator.api.MemberFilesFilter?>(parser)
} else { throw ParsingException("Wrong type for filterMemberFiles") }
}
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileCollectionIncludeFlags(
filterMemberFiles = filterMemberFiles,
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileCollectionsRenameRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileCollectionsRenameRequestItem {
var id: String? = null
var newTitle: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"newTitle" -> {
if (prop.element is JsonStreamElement.Text) {
newTitle = prop.element.value
} else { throw ParsingException("Wrong type for newTitle") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileCollectionsRenameRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
newTitle = newTitle ?: throw ParsingException("Missing key 'newTitle'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_UFileSpecification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.UFileSpecification {
var collection: String? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"collection" -> {
if (prop.element is JsonStreamElement.Text) {
collection = prop.element.value
} else { throw ParsingException("Wrong type for collection") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.UFileSpecification(
collection = collection ?: throw ParsingException("Missing key 'collection'"),
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_UFileUpdate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.UFileUpdate {
var timestamp: Long? = null
var status: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.UFileUpdate(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
status = status,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_UFile_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.UFile {
var id: String? = null
var specification: dk.sdu.cloud.file.orchestrator.api.UFileSpecification? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.file.orchestrator.api.UFileStatus? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.file.orchestrator.api.UFileSpecification>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.file.orchestrator.api.UFileStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.UFile(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_UFileStatus_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.UFileStatus {
var type: dk.sdu.cloud.file.orchestrator.api.FileType? = null
var icon: dk.sdu.cloud.file.orchestrator.api.FileIconHint? = null
var sizeInBytes: Long? = null
var sizeIncludingChildrenInBytes: Long? = null
var modifiedAt: Long? = null
var accessedAt: Long? = null
var unixMode: Int? = null
var unixOwner: Int? = null
var unixGroup: Int? = null
var metadata: dk.sdu.cloud.file.orchestrator.api.FileMetadataHistory? = null
var synced: Boolean? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Storage, dk.sdu.cloud.file.orchestrator.api.FSSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.Storage? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"type" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
type = parseJson<dk.sdu.cloud.file.orchestrator.api.FileType>(parser)
} else { throw ParsingException("Wrong type for type") }
}
"icon" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
icon = parseJson<dk.sdu.cloud.file.orchestrator.api.FileIconHint?>(parser)
} else { throw ParsingException("Wrong type for icon") }
}
"sizeInBytes" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
sizeInBytes = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for sizeInBytes") }
}
"sizeIncludingChildrenInBytes" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
sizeIncludingChildrenInBytes = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for sizeIncludingChildrenInBytes") }
}
"modifiedAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
modifiedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for modifiedAt") }
}
"accessedAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
accessedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for accessedAt") }
}
"unixMode" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
unixMode = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for unixMode") }
}
"unixOwner" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
unixOwner = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for unixOwner") }
}
"unixGroup" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
unixGroup = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for unixGroup") }
}
"metadata" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
metadata = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataHistory?>(parser)
} else { throw ParsingException("Wrong type for metadata") }
}
"synced" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
synced = prop.element.value
} else { throw ParsingException("Wrong type for synced") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Storage, dk.sdu.cloud.file.orchestrator.api.FSSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.Storage?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.UFileStatus(
type = type ?: throw ParsingException("Missing key 'type'"),
icon = icon,
sizeInBytes = sizeInBytes,
sizeIncludingChildrenInBytes = sizeIncludingChildrenInBytes,
modifiedAt = modifiedAt,
accessedAt = accessedAt,
unixMode = unixMode,
unixOwner = unixOwner,
unixGroup = unixGroup,
metadata = metadata,
synced = synced,
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataHistory_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataHistory {
var templates: kotlinx.serialization.json.JsonObject? = null
var metadata: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"templates" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for templates") }
}
"metadata" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for metadata") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataHistory(
templates = templates ?: throw ParsingException("Missing key 'templates'"),
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplate {
var namespaceId: String? = null
var title: String? = null
var version: String? = null
var schema: kotlinx.serialization.json.JsonObject? = null
var inheritable: Boolean? = null
var requireApproval: Boolean? = null
var description: String? = null
var changeLog: String? = null
var namespaceType: dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespaceType? = null
var uiSchema: kotlinx.serialization.json.JsonObject? = null
var namespaceName: String? = null
var createdAt: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"namespaceId" -> {
if (prop.element is JsonStreamElement.Text) {
namespaceId = prop.element.value
} else { throw ParsingException("Wrong type for namespaceId") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"version" -> {
if (prop.element is JsonStreamElement.Text) {
version = prop.element.value
} else { throw ParsingException("Wrong type for version") }
}
"schema" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for schema") }
}
"inheritable" -> {
if (prop.element is JsonStreamElement.Bool) {
inheritable = prop.element.value
} else { throw ParsingException("Wrong type for inheritable") }
}
"requireApproval" -> {
if (prop.element is JsonStreamElement.Bool) {
requireApproval = prop.element.value
} else { throw ParsingException("Wrong type for requireApproval") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"changeLog" -> {
if (prop.element is JsonStreamElement.Text) {
changeLog = prop.element.value
} else { throw ParsingException("Wrong type for changeLog") }
}
"namespaceType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
namespaceType = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespaceType>(parser)
} else { throw ParsingException("Wrong type for namespaceType") }
}
"uiSchema" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for uiSchema") }
}
"namespaceName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
namespaceName = prop.element.value
} else { throw ParsingException("Wrong type for namespaceName") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplate(
namespaceId = namespaceId ?: throw ParsingException("Missing key 'namespaceId'"),
title = title ?: throw ParsingException("Missing key 'title'"),
version = version ?: throw ParsingException("Missing key 'version'"),
schema = schema ?: throw ParsingException("Missing key 'schema'"),
inheritable = inheritable ?: throw ParsingException("Missing key 'inheritable'"),
requireApproval = requireApproval ?: throw ParsingException("Missing key 'requireApproval'"),
description = description ?: throw ParsingException("Missing key 'description'"),
changeLog = changeLog ?: throw ParsingException("Missing key 'changeLog'"),
namespaceType = namespaceType ?: throw ParsingException("Missing key 'namespaceType'"),
uiSchema = uiSchema,
namespaceName = namespaceName,
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_Status_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Status {
var approval: dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"approval" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
approval = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus>(parser)
} else { throw ParsingException("Wrong type for approval") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Status(
approval = approval ?: throw ParsingException("Missing key 'approval'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_Approved_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Approved {
var approvedBy: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"approvedBy" -> {
if (prop.element is JsonStreamElement.Text) {
approvedBy = prop.element.value
} else { throw ParsingException("Wrong type for approvedBy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Approved(
approvedBy = approvedBy ?: throw ParsingException("Missing key 'approvedBy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_Pending_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Pending {
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Pending(
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_Rejected_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Rejected {
var rejectedBy: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"rejectedBy" -> {
if (prop.element is JsonStreamElement.Text) {
rejectedBy = prop.element.value
} else { throw ParsingException("Wrong type for rejectedBy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Rejected(
rejectedBy = rejectedBy ?: throw ParsingException("Missing key 'rejectedBy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_NotRequired_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.NotRequired {
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.NotRequired(
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataOrDeleted_Deleted_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataOrDeleted.Deleted {
var id: String? = null
var changeLog: String? = null
var createdAt: Long? = null
var createdBy: String? = null
var status: dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Status? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"changeLog" -> {
if (prop.element is JsonStreamElement.Text) {
changeLog = prop.element.value
} else { throw ParsingException("Wrong type for changeLog") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"createdBy" -> {
if (prop.element is JsonStreamElement.Text) {
createdBy = prop.element.value
} else { throw ParsingException("Wrong type for createdBy") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Status>(parser)
} else { throw ParsingException("Wrong type for status") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataOrDeleted.Deleted(
id = id ?: throw ParsingException("Missing key 'id'"),
changeLog = changeLog ?: throw ParsingException("Missing key 'changeLog'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
createdBy = createdBy ?: throw ParsingException("Missing key 'createdBy'"),
status = status ?: throw ParsingException("Missing key 'status'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument {
var id: String? = null
var specification: dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Spec? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Status? = null
var createdBy: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Spec>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Status>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"createdBy" -> {
if (prop.element is JsonStreamElement.Text) {
createdBy = prop.element.value
} else { throw ParsingException("Wrong type for createdBy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
createdBy = createdBy ?: throw ParsingException("Missing key 'createdBy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_Spec_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Spec {
var templateId: String? = null
var version: String? = null
var document: kotlinx.serialization.json.JsonObject? = null
var changeLog: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"templateId" -> {
if (prop.element is JsonStreamElement.Text) {
templateId = prop.element.value
} else { throw ParsingException("Wrong type for templateId") }
}
"version" -> {
if (prop.element is JsonStreamElement.Text) {
version = prop.element.value
} else { throw ParsingException("Wrong type for version") }
}
"document" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for document") }
}
"changeLog" -> {
if (prop.element is JsonStreamElement.Text) {
changeLog = prop.element.value
} else { throw ParsingException("Wrong type for changeLog") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Spec(
templateId = templateId ?: throw ParsingException("Missing key 'templateId'"),
version = version ?: throw ParsingException("Missing key 'version'"),
document = document ?: throw ParsingException("Missing key 'document'"),
changeLog = changeLog ?: throw ParsingException("Missing key 'changeLog'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_UFileIncludeFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags {
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var includePermissions: Boolean? = null
var includeTimestamps: Boolean? = null
var includeSizes: Boolean? = null
var includeUnixInfo: Boolean? = null
var includeMetadata: Boolean? = null
var includeSyncStatus: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterByFileExtension: String? = null
var path: String? = null
var allowUnsupportedInclude: Boolean? = null
var filterHiddenFiles: Boolean? = null
var filterIds: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"includePermissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includePermissions = prop.element.value
} else { throw ParsingException("Wrong type for includePermissions") }
}
"includeTimestamps" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeTimestamps = prop.element.value
} else { throw ParsingException("Wrong type for includeTimestamps") }
}
"includeSizes" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeSizes = prop.element.value
} else { throw ParsingException("Wrong type for includeSizes") }
}
"includeUnixInfo" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeUnixInfo = prop.element.value
} else { throw ParsingException("Wrong type for includeUnixInfo") }
}
"includeMetadata" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeMetadata = prop.element.value
} else { throw ParsingException("Wrong type for includeMetadata") }
}
"includeSyncStatus" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeSyncStatus = prop.element.value
} else { throw ParsingException("Wrong type for includeSyncStatus") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterByFileExtension" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterByFileExtension = prop.element.value
} else { throw ParsingException("Wrong type for filterByFileExtension") }
}
"path" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
path = prop.element.value
} else { throw ParsingException("Wrong type for path") }
}
"allowUnsupportedInclude" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
allowUnsupportedInclude = prop.element.value
} else { throw ParsingException("Wrong type for allowUnsupportedInclude") }
}
"filterHiddenFiles" -> {
if (prop.element is JsonStreamElement.Bool) {
filterHiddenFiles = prop.element.value
} else { throw ParsingException("Wrong type for filterHiddenFiles") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags(
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
includePermissions = includePermissions,
includeTimestamps = includeTimestamps,
includeSizes = includeSizes,
includeUnixInfo = includeUnixInfo,
includeMetadata = includeMetadata,
includeSyncStatus = includeSyncStatus,
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterByFileExtension = filterByFileExtension,
path = path,
allowUnsupportedInclude = allowUnsupportedInclude,
filterHiddenFiles = filterHiddenFiles ?: throw ParsingException("Missing key 'filterHiddenFiles'"),
filterIds = filterIds,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesMoveRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesMoveRequestItem {
var oldId: String? = null
var newId: String? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"oldId" -> {
if (prop.element is JsonStreamElement.Text) {
oldId = prop.element.value
} else { throw ParsingException("Wrong type for oldId") }
}
"newId" -> {
if (prop.element is JsonStreamElement.Text) {
newId = prop.element.value
} else { throw ParsingException("Wrong type for newId") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesMoveRequestItem(
oldId = oldId ?: throw ParsingException("Missing key 'oldId'"),
newId = newId ?: throw ParsingException("Missing key 'newId'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_LongRunningTask_Complete_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.LongRunningTask.Complete {
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.LongRunningTask.Complete(
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_LongRunningTask_ContinuesInBackground_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.LongRunningTask.ContinuesInBackground {
var taskId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"taskId" -> {
if (prop.element is JsonStreamElement.Text) {
taskId = prop.element.value
} else { throw ParsingException("Wrong type for taskId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.LongRunningTask.ContinuesInBackground(
taskId = taskId ?: throw ParsingException("Missing key 'taskId'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesCopyRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesCopyRequestItem {
var oldId: String? = null
var newId: String? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"oldId" -> {
if (prop.element is JsonStreamElement.Text) {
oldId = prop.element.value
} else { throw ParsingException("Wrong type for oldId") }
}
"newId" -> {
if (prop.element is JsonStreamElement.Text) {
newId = prop.element.value
} else { throw ParsingException("Wrong type for newId") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesCopyRequestItem(
oldId = oldId ?: throw ParsingException("Missing key 'oldId'"),
newId = newId ?: throw ParsingException("Missing key 'newId'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesCreateUploadRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesCreateUploadRequestItem {
var id: String? = null
var supportedProtocols: List<dk.sdu.cloud.file.orchestrator.api.UploadProtocol>? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"supportedProtocols" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val supportedProtocolsList = ArrayList<dk.sdu.cloud.file.orchestrator.api.UploadProtocol>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val supportedProtocolsElem: dk.sdu.cloud.file.orchestrator.api.UploadProtocol
if (prop.element is JsonStreamElement.ObjectStart) {
supportedProtocolsElem = parseJson<dk.sdu.cloud.file.orchestrator.api.UploadProtocol>(parser)
} else { throw ParsingException("Wrong type for supportedProtocolsElem") }
supportedProtocolsList.add(supportedProtocolsElem)
} else { throw ParsingException("Wrong element type for supportedProtocols") }
}
supportedProtocols = supportedProtocolsList
} else { throw ParsingException("Wrong type for supportedProtocols") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesCreateUploadRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
supportedProtocols = supportedProtocols ?: throw ParsingException("Missing key 'supportedProtocols'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesCreateUploadResponseItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesCreateUploadResponseItem {
var endpoint: String? = null
var protocol: dk.sdu.cloud.file.orchestrator.api.UploadProtocol? = null
var token: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"endpoint" -> {
if (prop.element is JsonStreamElement.Text) {
endpoint = prop.element.value
} else { throw ParsingException("Wrong type for endpoint") }
}
"protocol" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
protocol = parseJson<dk.sdu.cloud.file.orchestrator.api.UploadProtocol>(parser)
} else { throw ParsingException("Wrong type for protocol") }
}
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesCreateUploadResponseItem(
endpoint = endpoint ?: throw ParsingException("Missing key 'endpoint'"),
protocol = protocol ?: throw ParsingException("Missing key 'protocol'"),
token = token ?: throw ParsingException("Missing key 'token'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesCreateDownloadRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesCreateDownloadRequestItem {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesCreateDownloadRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesCreateDownloadResponseItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesCreateDownloadResponseItem {
var endpoint: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"endpoint" -> {
if (prop.element is JsonStreamElement.Text) {
endpoint = prop.element.value
} else { throw ParsingException("Wrong type for endpoint") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesCreateDownloadResponseItem(
endpoint = endpoint ?: throw ParsingException("Missing key 'endpoint'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesCreateFolderRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesCreateFolderRequestItem {
var id: String? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesCreateFolderRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FindByPath_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FindByPath {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FindByPath(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_Share_Spec_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.Share.Spec {
var sharedWith: String? = null
var sourceFilePath: String? = null
var permissions: List<dk.sdu.cloud.provider.api.Permission>? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sharedWith" -> {
if (prop.element is JsonStreamElement.Text) {
sharedWith = prop.element.value
} else { throw ParsingException("Wrong type for sharedWith") }
}
"sourceFilePath" -> {
if (prop.element is JsonStreamElement.Text) {
sourceFilePath = prop.element.value
} else { throw ParsingException("Wrong type for sourceFilePath") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val permissionsList = ArrayList<dk.sdu.cloud.provider.api.Permission>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val permissionsElem: dk.sdu.cloud.provider.api.Permission
if (prop.element is JsonStreamElement.ObjectStart) {
permissionsElem = parseJson<dk.sdu.cloud.provider.api.Permission>(parser)
} else { throw ParsingException("Wrong type for permissionsElem") }
permissionsList.add(permissionsElem)
} else { throw ParsingException("Wrong element type for permissions") }
}
permissions = permissionsList
} else { throw ParsingException("Wrong type for permissions") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.Share.Spec(
sharedWith = sharedWith ?: throw ParsingException("Missing key 'sharedWith'"),
sourceFilePath = sourceFilePath ?: throw ParsingException("Missing key 'sourceFilePath'"),
permissions = permissions ?: throw ParsingException("Missing key 'permissions'"),
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_Share_Update_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.Share.Update {
var newState: dk.sdu.cloud.file.orchestrator.api.Share.State? = null
var shareAvailableAt: String? = null
var timestamp: Long? = null
var status: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"newState" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
newState = parseJson<dk.sdu.cloud.file.orchestrator.api.Share.State>(parser)
} else { throw ParsingException("Wrong type for newState") }
}
"shareAvailableAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
shareAvailableAt = prop.element.value
} else { throw ParsingException("Wrong type for shareAvailableAt") }
}
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.Share.Update(
newState = newState ?: throw ParsingException("Missing key 'newState'"),
shareAvailableAt = shareAvailableAt,
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
status = status,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_ShareSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.ShareSupport {
var type: dk.sdu.cloud.file.orchestrator.api.ShareType? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"type" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
type = parseJson<dk.sdu.cloud.file.orchestrator.api.ShareType>(parser)
} else { throw ParsingException("Wrong type for type") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.ShareSupport(
type = type ?: throw ParsingException("Missing key 'type'"),
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_Share_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.Share {
var id: String? = null
var specification: dk.sdu.cloud.file.orchestrator.api.Share.Spec? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.file.orchestrator.api.Share.Status? = null
var updates: List<dk.sdu.cloud.file.orchestrator.api.Share.Update>? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.file.orchestrator.api.Share.Spec>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.file.orchestrator.api.Share.Status>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.file.orchestrator.api.Share.Update>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.file.orchestrator.api.Share.Update
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.file.orchestrator.api.Share.Update>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.Share(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_Share_Status_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.Share.Status {
var shareAvailableAt: String? = null
var state: dk.sdu.cloud.file.orchestrator.api.Share.State? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Storage, dk.sdu.cloud.file.orchestrator.api.ShareSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.Storage? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"shareAvailableAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
shareAvailableAt = prop.element.value
} else { throw ParsingException("Wrong type for shareAvailableAt") }
}
"state" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.file.orchestrator.api.Share.State>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Storage, dk.sdu.cloud.file.orchestrator.api.ShareSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.Storage?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.Share.Status(
shareAvailableAt = shareAvailableAt,
state = state ?: throw ParsingException("Missing key 'state'"),
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_ShareFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.ShareFlags {
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIngoing: Boolean? = null
var filterOriginalPath: String? = null
var filterRejected: String? = null
var filterIds: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIngoing" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
filterIngoing = prop.element.value
} else { throw ParsingException("Wrong type for filterIngoing") }
}
"filterOriginalPath" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterOriginalPath = prop.element.value
} else { throw ParsingException("Wrong type for filterOriginalPath") }
}
"filterRejected" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterRejected = prop.element.value
} else { throw ParsingException("Wrong type for filterRejected") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.ShareFlags(
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIngoing = filterIngoing,
filterOriginalPath = filterOriginalPath,
filterRejected = filterRejected,
filterIds = filterIds,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_SharesUpdatePermissionsRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.SharesUpdatePermissionsRequestItem {
var id: String? = null
var permissions: List<dk.sdu.cloud.provider.api.Permission>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val permissionsList = ArrayList<dk.sdu.cloud.provider.api.Permission>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val permissionsElem: dk.sdu.cloud.provider.api.Permission
if (prop.element is JsonStreamElement.ObjectStart) {
permissionsElem = parseJson<dk.sdu.cloud.provider.api.Permission>(parser)
} else { throw ParsingException("Wrong type for permissionsElem") }
permissionsList.add(permissionsElem)
} else { throw ParsingException("Wrong element type for permissions") }
}
permissions = permissionsList
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.SharesUpdatePermissionsRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
permissions = permissions ?: throw ParsingException("Missing key 'permissions'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_SharesBrowseOutgoingRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.SharesBrowseOutgoingRequest {
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.SharesBrowseOutgoingRequest(
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_OutgoingShareGroup_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup {
var sourceFilePath: String? = null
var storageProduct: dk.sdu.cloud.accounting.api.ProductReference? = null
var sharePreview: List<dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup.Preview>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sourceFilePath" -> {
if (prop.element is JsonStreamElement.Text) {
sourceFilePath = prop.element.value
} else { throw ParsingException("Wrong type for sourceFilePath") }
}
"storageProduct" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
storageProduct = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for storageProduct") }
}
"sharePreview" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val sharePreviewList = ArrayList<dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup.Preview>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val sharePreviewElem: dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup.Preview
if (prop.element is JsonStreamElement.ObjectStart) {
sharePreviewElem = parseJson<dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup.Preview>(parser)
} else { throw ParsingException("Wrong type for sharePreviewElem") }
sharePreviewList.add(sharePreviewElem)
} else { throw ParsingException("Wrong element type for sharePreview") }
}
sharePreview = sharePreviewList
} else { throw ParsingException("Wrong type for sharePreview") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup(
sourceFilePath = sourceFilePath ?: throw ParsingException("Missing key 'sourceFilePath'"),
storageProduct = storageProduct ?: throw ParsingException("Missing key 'storageProduct'"),
sharePreview = sharePreview ?: throw ParsingException("Missing key 'sharePreview'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_OutgoingShareGroup_Preview_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup.Preview {
var sharedWith: String? = null
var permissions: List<dk.sdu.cloud.provider.api.Permission>? = null
var state: dk.sdu.cloud.file.orchestrator.api.Share.State? = null
var shareId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sharedWith" -> {
if (prop.element is JsonStreamElement.Text) {
sharedWith = prop.element.value
} else { throw ParsingException("Wrong type for sharedWith") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val permissionsList = ArrayList<dk.sdu.cloud.provider.api.Permission>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val permissionsElem: dk.sdu.cloud.provider.api.Permission
if (prop.element is JsonStreamElement.ObjectStart) {
permissionsElem = parseJson<dk.sdu.cloud.provider.api.Permission>(parser)
} else { throw ParsingException("Wrong type for permissionsElem") }
permissionsList.add(permissionsElem)
} else { throw ParsingException("Wrong element type for permissions") }
}
permissions = permissionsList
} else { throw ParsingException("Wrong type for permissions") }
}
"state" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.file.orchestrator.api.Share.State>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"shareId" -> {
if (prop.element is JsonStreamElement.Text) {
shareId = prop.element.value
} else { throw ParsingException("Wrong type for shareId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup.Preview(
sharedWith = sharedWith ?: throw ParsingException("Missing key 'sharedWith'"),
permissions = permissions ?: throw ParsingException("Missing key 'permissions'"),
state = state ?: throw ParsingException("Missing key 'state'"),
shareId = shareId ?: throw ParsingException("Missing key 'shareId'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_Spec_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Spec {
var name: String? = null
var namespaceType: dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespaceType? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"namespaceType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
namespaceType = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespaceType>(parser)
} else { throw ParsingException("Wrong type for namespaceType") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Spec(
name = name ?: throw ParsingException("Missing key 'name'"),
namespaceType = namespaceType ?: throw ParsingException("Missing key 'namespaceType'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_Update_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Update {
var timestamp: Long? = null
var status: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Update(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
status = status,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateSupport {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace {
var id: String? = null
var specification: dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Spec? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Status? = null
var updates: List<dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Update>? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Spec>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Status>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Update>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Update
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Update>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_Status_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Status {
var latestTitle: String? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product, dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"latestTitle" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
latestTitle = prop.element.value
} else { throw ParsingException("Wrong type for latestTitle") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product, dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Status(
latestTitle = latestTitle,
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespaceFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespaceFlags {
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var filterName: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"filterName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterName = prop.element.value
} else { throw ParsingException("Wrong type for filterName") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespaceFlags(
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
filterName = filterName,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateAndVersion_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateAndVersion {
var id: String? = null
var version: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"version" -> {
if (prop.element is JsonStreamElement.Text) {
version = prop.element.value
} else { throw ParsingException("Wrong type for version") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateAndVersion(
id = id ?: throw ParsingException("Missing key 'id'"),
version = version ?: throw ParsingException("Missing key 'version'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplatesBrowseTemplatesRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplatesBrowseTemplatesRequest {
var id: String? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplatesBrowseTemplatesRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataAddRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataAddRequestItem {
var fileId: String? = null
var metadata: dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Spec? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"fileId" -> {
if (prop.element is JsonStreamElement.Text) {
fileId = prop.element.value
} else { throw ParsingException("Wrong type for fileId") }
}
"metadata" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
metadata = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Spec>(parser)
} else { throw ParsingException("Wrong type for metadata") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataAddRequestItem(
fileId = fileId ?: throw ParsingException("Missing key 'fileId'"),
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataMoveRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataMoveRequestItem {
var oldFileId: String? = null
var newFileId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"oldFileId" -> {
if (prop.element is JsonStreamElement.Text) {
oldFileId = prop.element.value
} else { throw ParsingException("Wrong type for oldFileId") }
}
"newFileId" -> {
if (prop.element is JsonStreamElement.Text) {
newFileId = prop.element.value
} else { throw ParsingException("Wrong type for newFileId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataMoveRequestItem(
oldFileId = oldFileId ?: throw ParsingException("Missing key 'oldFileId'"),
newFileId = newFileId ?: throw ParsingException("Missing key 'newFileId'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataDeleteRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataDeleteRequestItem {
var id: String? = null
var changeLog: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"changeLog" -> {
if (prop.element is JsonStreamElement.Text) {
changeLog = prop.element.value
} else { throw ParsingException("Wrong type for changeLog") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataDeleteRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
changeLog = changeLog ?: throw ParsingException("Missing key 'changeLog'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataRetrieveAllRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataRetrieveAllRequest {
var fileId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"fileId" -> {
if (prop.element is JsonStreamElement.Text) {
fileId = prop.element.value
} else { throw ParsingException("Wrong type for fileId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataRetrieveAllRequest(
fileId = fileId ?: throw ParsingException("Missing key 'fileId'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataRetrieveAllResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataRetrieveAllResponse {
var metadata: List<dk.sdu.cloud.file.orchestrator.api.FileMetadataAttached>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"metadata" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val metadataList = ArrayList<dk.sdu.cloud.file.orchestrator.api.FileMetadataAttached>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val metadataElem: dk.sdu.cloud.file.orchestrator.api.FileMetadataAttached
if (prop.element is JsonStreamElement.ObjectStart) {
metadataElem = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataAttached>(parser)
} else { throw ParsingException("Wrong type for metadataElem") }
metadataList.add(metadataElem)
} else { throw ParsingException("Wrong element type for metadata") }
}
metadata = metadataList
} else { throw ParsingException("Wrong type for metadata") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataRetrieveAllResponse(
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataAttached_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataAttached {
var path: String? = null
var metadata: dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"path" -> {
if (prop.element is JsonStreamElement.Text) {
path = prop.element.value
} else { throw ParsingException("Wrong type for path") }
}
"metadata" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
metadata = parseJson<dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument>(parser)
} else { throw ParsingException("Wrong type for metadata") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataAttached(
path = path ?: throw ParsingException("Missing key 'path'"),
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileMetadataBrowseRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileMetadataBrowseRequest {
var filterTemplate: String? = null
var filterVersion: String? = null
var filterActive: Boolean? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterTemplate" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterTemplate = prop.element.value
} else { throw ParsingException("Wrong type for filterTemplate") }
}
"filterVersion" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterVersion = prop.element.value
} else { throw ParsingException("Wrong type for filterVersion") }
}
"filterActive" -> {
if (prop.element is JsonStreamElement.Bool) {
filterActive = prop.element.value
} else { throw ParsingException("Wrong type for filterActive") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileMetadataBrowseRequest(
filterTemplate = filterTemplate,
filterVersion = filterVersion,
filterActive = filterActive ?: throw ParsingException("Missing key 'filterActive'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_accounting_api_providers_ResourceInitializationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.ResourceInitializationRequest {
var principal: dk.sdu.cloud.provider.api.ResourceOwner? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"principal" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
principal = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for principal") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.ResourceInitializationRequest(
principal = principal ?: throw ParsingException("Missing key 'principal'"),
)
}
inline fun <reified Res> `dk_sdu_cloud_provider_api_UpdatedAclWithResource_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.UpdatedAclWithResource<Res> {
var resource: Res? = null
var added: List<dk.sdu.cloud.provider.api.ResourceAclEntry>? = null
var deleted: List<dk.sdu.cloud.provider.api.AclEntity>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resource" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resource = parseJson<Res>(parser)
} else { throw ParsingException("Wrong type for resource") }
}
"added" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val addedList = ArrayList<dk.sdu.cloud.provider.api.ResourceAclEntry>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val addedElem: dk.sdu.cloud.provider.api.ResourceAclEntry
if (prop.element is JsonStreamElement.ObjectStart) {
addedElem = parseJson<dk.sdu.cloud.provider.api.ResourceAclEntry>(parser)
} else { throw ParsingException("Wrong type for addedElem") }
addedList.add(addedElem)
} else { throw ParsingException("Wrong element type for added") }
}
added = addedList
} else { throw ParsingException("Wrong type for added") }
}
"deleted" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val deletedList = ArrayList<dk.sdu.cloud.provider.api.AclEntity>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val deletedElem: dk.sdu.cloud.provider.api.AclEntity
if (prop.element is JsonStreamElement.ObjectStart) {
deletedElem = parseJson<dk.sdu.cloud.provider.api.AclEntity>(parser)
} else { throw ParsingException("Wrong type for deletedElem") }
deletedList.add(deletedElem)
} else { throw ParsingException("Wrong element type for deleted") }
}
deleted = deletedList
} else { throw ParsingException("Wrong type for deleted") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.UpdatedAclWithResource(
resource = resource ?: throw ParsingException("Missing key 'resource'"),
added = added ?: throw ParsingException("Missing key 'added'"),
deleted = deleted ?: throw ParsingException("Missing key 'deleted'"),
)
}
inline fun `dk_sdu_cloud_accounting_api_providers_ResourceChargeCredits_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.ResourceChargeCredits {
var id: String? = null
var chargeId: String? = null
var units: Long? = null
var periods: Long? = null
var performedBy: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"chargeId" -> {
if (prop.element is JsonStreamElement.Text) {
chargeId = prop.element.value
} else { throw ParsingException("Wrong type for chargeId") }
}
"units" -> {
if (prop.element is JsonStreamElement.Number) {
units = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for units") }
}
"periods" -> {
if (prop.element is JsonStreamElement.Number) {
periods = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for periods") }
}
"performedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
performedBy = prop.element.value
} else { throw ParsingException("Wrong type for performedBy") }
}
"description" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.ResourceChargeCredits(
id = id ?: throw ParsingException("Missing key 'id'"),
chargeId = chargeId ?: throw ParsingException("Missing key 'chargeId'"),
units = units ?: throw ParsingException("Missing key 'units'"),
periods = periods ?: throw ParsingException("Missing key 'periods'"),
performedBy = performedBy,
description = description,
)
}
inline fun `dk_sdu_cloud_accounting_api_providers_ResourceChargeCreditsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.accounting.api.providers.ResourceChargeCreditsResponse {
var insufficientFunds: List<dk.sdu.cloud.FindByStringId>? = null
var duplicateCharges: List<dk.sdu.cloud.FindByStringId>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"insufficientFunds" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val insufficientFundsList = ArrayList<dk.sdu.cloud.FindByStringId>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val insufficientFundsElem: dk.sdu.cloud.FindByStringId
if (prop.element is JsonStreamElement.ObjectStart) {
insufficientFundsElem = parseJson<dk.sdu.cloud.FindByStringId>(parser)
} else { throw ParsingException("Wrong type for insufficientFundsElem") }
insufficientFundsList.add(insufficientFundsElem)
} else { throw ParsingException("Wrong element type for insufficientFunds") }
}
insufficientFunds = insufficientFundsList
} else { throw ParsingException("Wrong type for insufficientFunds") }
}
"duplicateCharges" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val duplicateChargesList = ArrayList<dk.sdu.cloud.FindByStringId>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val duplicateChargesElem: dk.sdu.cloud.FindByStringId
if (prop.element is JsonStreamElement.ObjectStart) {
duplicateChargesElem = parseJson<dk.sdu.cloud.FindByStringId>(parser)
} else { throw ParsingException("Wrong type for duplicateChargesElem") }
duplicateChargesList.add(duplicateChargesElem)
} else { throw ParsingException("Wrong element type for duplicateCharges") }
}
duplicateCharges = duplicateChargesList
} else { throw ParsingException("Wrong type for duplicateCharges") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.accounting.api.providers.ResourceChargeCreditsResponse(
insufficientFunds = insufficientFunds ?: throw ParsingException("Missing key 'insufficientFunds'"),
duplicateCharges = duplicateCharges ?: throw ParsingException("Missing key 'duplicateCharges'"),
)
}
inline fun <reified U> `dk_sdu_cloud_provider_api_ResourceUpdateAndId_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.provider.api.ResourceUpdateAndId<U> {
var id: String? = null
var update: U? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"update" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
update = parseJson<U>(parser)
} else { throw ParsingException("Wrong type for update") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.provider.api.ResourceUpdateAndId(
id = id ?: throw ParsingException("Missing key 'id'"),
update = update ?: throw ParsingException("Missing key 'update'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FileCollectionsProviderRenameRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FileCollectionsProviderRenameRequestItem {
var id: String? = null
var newTitle: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"newTitle" -> {
if (prop.element is JsonStreamElement.Text) {
newTitle = prop.element.value
} else { throw ParsingException("Wrong type for newTitle") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FileCollectionsProviderRenameRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
newTitle = newTitle ?: throw ParsingException("Missing key 'newTitle'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderBrowseRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderBrowseRequest {
var resolvedCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var browse: dk.sdu.cloud.accounting.api.providers.ResourceBrowseRequest<dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedCollection") }
}
"browse" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
browse = parseJson<dk.sdu.cloud.accounting.api.providers.ResourceBrowseRequest<dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags>>(parser)
} else { throw ParsingException("Wrong type for browse") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderBrowseRequest(
resolvedCollection = resolvedCollection ?: throw ParsingException("Missing key 'resolvedCollection'"),
browse = browse ?: throw ParsingException("Missing key 'browse'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_PartialUFile_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.PartialUFile {
var id: String? = null
var status: dk.sdu.cloud.file.orchestrator.api.UFileStatus? = null
var createdAt: Long? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
var legacySensitivity: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.file.orchestrator.api.UFileStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"owner" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner?>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
"legacySensitivity" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
legacySensitivity = prop.element.value
} else { throw ParsingException("Wrong type for legacySensitivity") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.PartialUFile(
id = id ?: throw ParsingException("Missing key 'id'"),
status = status ?: throw ParsingException("Missing key 'status'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
owner = owner,
permissions = permissions,
legacySensitivity = legacySensitivity,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderRetrieveRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderRetrieveRequest {
var resolvedCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var retrieve: dk.sdu.cloud.accounting.api.providers.ResourceRetrieveRequest<dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedCollection") }
}
"retrieve" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
retrieve = parseJson<dk.sdu.cloud.accounting.api.providers.ResourceRetrieveRequest<dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags>>(parser)
} else { throw ParsingException("Wrong type for retrieve") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderRetrieveRequest(
resolvedCollection = resolvedCollection ?: throw ParsingException("Missing key 'resolvedCollection'"),
retrieve = retrieve ?: throw ParsingException("Missing key 'retrieve'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderMoveRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderMoveRequestItem {
var resolvedOldCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var resolvedNewCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var oldId: String? = null
var newId: String? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedOldCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedOldCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedOldCollection") }
}
"resolvedNewCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedNewCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedNewCollection") }
}
"oldId" -> {
if (prop.element is JsonStreamElement.Text) {
oldId = prop.element.value
} else { throw ParsingException("Wrong type for oldId") }
}
"newId" -> {
if (prop.element is JsonStreamElement.Text) {
newId = prop.element.value
} else { throw ParsingException("Wrong type for newId") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderMoveRequestItem(
resolvedOldCollection = resolvedOldCollection ?: throw ParsingException("Missing key 'resolvedOldCollection'"),
resolvedNewCollection = resolvedNewCollection ?: throw ParsingException("Missing key 'resolvedNewCollection'"),
oldId = oldId ?: throw ParsingException("Missing key 'oldId'"),
newId = newId ?: throw ParsingException("Missing key 'newId'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderCopyRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderCopyRequestItem {
var resolvedOldCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var resolvedNewCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var oldId: String? = null
var newId: String? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedOldCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedOldCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedOldCollection") }
}
"resolvedNewCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedNewCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedNewCollection") }
}
"oldId" -> {
if (prop.element is JsonStreamElement.Text) {
oldId = prop.element.value
} else { throw ParsingException("Wrong type for oldId") }
}
"newId" -> {
if (prop.element is JsonStreamElement.Text) {
newId = prop.element.value
} else { throw ParsingException("Wrong type for newId") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderCopyRequestItem(
resolvedOldCollection = resolvedOldCollection ?: throw ParsingException("Missing key 'resolvedOldCollection'"),
resolvedNewCollection = resolvedNewCollection ?: throw ParsingException("Missing key 'resolvedNewCollection'"),
oldId = oldId ?: throw ParsingException("Missing key 'oldId'"),
newId = newId ?: throw ParsingException("Missing key 'newId'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderCreateFolderRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateFolderRequestItem {
var resolvedCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var id: String? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedCollection") }
}
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateFolderRequestItem(
resolvedCollection = resolvedCollection ?: throw ParsingException("Missing key 'resolvedCollection'"),
id = id ?: throw ParsingException("Missing key 'id'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderTrashRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderTrashRequestItem {
var resolvedCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedCollection") }
}
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderTrashRequestItem(
resolvedCollection = resolvedCollection ?: throw ParsingException("Missing key 'resolvedCollection'"),
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderEmptyTrashRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderEmptyTrashRequestItem {
var resolvedCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedCollection") }
}
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderEmptyTrashRequestItem(
resolvedCollection = resolvedCollection ?: throw ParsingException("Missing key 'resolvedCollection'"),
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderCreateUploadRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateUploadRequestItem {
var resolvedCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var id: String? = null
var supportedProtocols: List<dk.sdu.cloud.file.orchestrator.api.UploadProtocol>? = null
var conflictPolicy: dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedCollection") }
}
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"supportedProtocols" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val supportedProtocolsList = ArrayList<dk.sdu.cloud.file.orchestrator.api.UploadProtocol>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val supportedProtocolsElem: dk.sdu.cloud.file.orchestrator.api.UploadProtocol
if (prop.element is JsonStreamElement.ObjectStart) {
supportedProtocolsElem = parseJson<dk.sdu.cloud.file.orchestrator.api.UploadProtocol>(parser)
} else { throw ParsingException("Wrong type for supportedProtocolsElem") }
supportedProtocolsList.add(supportedProtocolsElem)
} else { throw ParsingException("Wrong element type for supportedProtocols") }
}
supportedProtocols = supportedProtocolsList
} else { throw ParsingException("Wrong type for supportedProtocols") }
}
"conflictPolicy" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
conflictPolicy = parseJson<dk.sdu.cloud.file.orchestrator.api.WriteConflictPolicy>(parser)
} else { throw ParsingException("Wrong type for conflictPolicy") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateUploadRequestItem(
resolvedCollection = resolvedCollection ?: throw ParsingException("Missing key 'resolvedCollection'"),
id = id ?: throw ParsingException("Missing key 'id'"),
supportedProtocols = supportedProtocols ?: throw ParsingException("Missing key 'supportedProtocols'"),
conflictPolicy = conflictPolicy ?: throw ParsingException("Missing key 'conflictPolicy'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderCreateDownloadRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateDownloadRequestItem {
var resolvedCollection: dk.sdu.cloud.file.orchestrator.api.FileCollection? = null
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"resolvedCollection" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
resolvedCollection = parseJson<dk.sdu.cloud.file.orchestrator.api.FileCollection>(parser)
} else { throw ParsingException("Wrong type for resolvedCollection") }
}
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateDownloadRequestItem(
resolvedCollection = resolvedCollection ?: throw ParsingException("Missing key 'resolvedCollection'"),
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesProviderSearchRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesProviderSearchRequest {
var query: String? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var flags: dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"query" -> {
if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"flags" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
flags = parseJson<dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags>(parser)
} else { throw ParsingException("Wrong type for flags") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesProviderSearchRequest(
query = query ?: throw ParsingException("Missing key 'query'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
flags = flags ?: throw ParsingException("Missing key 'flags'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesControlAddUpdateRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesControlAddUpdateRequestItem {
var taskId: String? = null
var update: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"taskId" -> {
if (prop.element is JsonStreamElement.Text) {
taskId = prop.element.value
} else { throw ParsingException("Wrong type for taskId") }
}
"update" -> {
if (prop.element is JsonStreamElement.Text) {
update = prop.element.value
} else { throw ParsingException("Wrong type for update") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesControlAddUpdateRequestItem(
taskId = taskId ?: throw ParsingException("Missing key 'taskId'"),
update = update ?: throw ParsingException("Missing key 'update'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_FilesControlMarkAsCompleteRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.FilesControlMarkAsCompleteRequestItem {
var taskId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"taskId" -> {
if (prop.element is JsonStreamElement.Text) {
taskId = prop.element.value
} else { throw ParsingException("Wrong type for taskId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.FilesControlMarkAsCompleteRequestItem(
taskId = taskId ?: throw ParsingException("Missing key 'taskId'"),
)
}
inline fun `dk_sdu_cloud_file_orchestrator_api_ChunkedUploadProtocolUploadChunkRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.file.orchestrator.api.ChunkedUploadProtocolUploadChunkRequest {
var token: String? = null
var offset: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
"offset" -> {
if (prop.element is JsonStreamElement.Number) {
offset = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for offset") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.file.orchestrator.api.ChunkedUploadProtocolUploadChunkRequest(
token = token ?: throw ParsingException("Missing key 'token'"),
offset = offset ?: throw ParsingException("Missing key 'offset'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_FindByNameAndVersion_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.FindByNameAndVersion {
var name: String? = null
var version: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"version" -> {
if (prop.element is JsonStreamElement.Text) {
version = prop.element.value
} else { throw ParsingException("Wrong type for version") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.FindByNameAndVersion(
name = name ?: throw ParsingException("Missing key 'name'"),
version = version ?: throw ParsingException("Missing key 'version'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_Tool_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.Tool {
var owner: String? = null
var createdAt: Long? = null
var modifiedAt: Long? = null
var description: dk.sdu.cloud.app.store.api.NormalizedToolDescription? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"owner" -> {
if (prop.element is JsonStreamElement.Text) {
owner = prop.element.value
} else { throw ParsingException("Wrong type for owner") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"modifiedAt" -> {
if (prop.element is JsonStreamElement.Number) {
modifiedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for modifiedAt") }
}
"description" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
description = parseJson<dk.sdu.cloud.app.store.api.NormalizedToolDescription>(parser)
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.Tool(
owner = owner ?: throw ParsingException("Missing key 'owner'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
modifiedAt = modifiedAt ?: throw ParsingException("Missing key 'modifiedAt'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_NormalizedToolDescription_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.NormalizedToolDescription {
var info: dk.sdu.cloud.app.store.api.NameAndVersion? = null
var container: String? = null
var defaultNumberOfNodes: Int? = null
var defaultTimeAllocation: dk.sdu.cloud.app.store.api.SimpleDuration? = null
var requiredModules: List<String>? = null
var authors: List<String>? = null
var title: String? = null
var description: String? = null
var backend: dk.sdu.cloud.app.store.api.ToolBackend? = null
var license: String? = null
var image: String? = null
var supportedProviders: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"info" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
info = parseJson<dk.sdu.cloud.app.store.api.NameAndVersion>(parser)
} else { throw ParsingException("Wrong type for info") }
}
"container" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
container = prop.element.value
} else { throw ParsingException("Wrong type for container") }
}
"defaultNumberOfNodes" -> {
if (prop.element is JsonStreamElement.Number) {
defaultNumberOfNodes = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for defaultNumberOfNodes") }
}
"defaultTimeAllocation" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
defaultTimeAllocation = parseJson<dk.sdu.cloud.app.store.api.SimpleDuration>(parser)
} else { throw ParsingException("Wrong type for defaultTimeAllocation") }
}
"requiredModules" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val requiredModulesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val requiredModulesElem: String
if (prop.element is JsonStreamElement.Text) {
requiredModulesElem = prop.element.value
} else { throw ParsingException("Wrong type for requiredModulesElem") }
requiredModulesList.add(requiredModulesElem)
} else { throw ParsingException("Wrong element type for requiredModules") }
}
requiredModules = requiredModulesList
} else { throw ParsingException("Wrong type for requiredModules") }
}
"authors" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val authorsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val authorsElem: String
if (prop.element is JsonStreamElement.Text) {
authorsElem = prop.element.value
} else { throw ParsingException("Wrong type for authorsElem") }
authorsList.add(authorsElem)
} else { throw ParsingException("Wrong element type for authors") }
}
authors = authorsList
} else { throw ParsingException("Wrong type for authors") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"backend" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
backend = parseJson<dk.sdu.cloud.app.store.api.ToolBackend>(parser)
} else { throw ParsingException("Wrong type for backend") }
}
"license" -> {
if (prop.element is JsonStreamElement.Text) {
license = prop.element.value
} else { throw ParsingException("Wrong type for license") }
}
"image" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
image = prop.element.value
} else { throw ParsingException("Wrong type for image") }
}
"supportedProviders" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ArrayStart) {
val supportedProvidersList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val supportedProvidersElem: String
if (prop.element is JsonStreamElement.Text) {
supportedProvidersElem = prop.element.value
} else { throw ParsingException("Wrong type for supportedProvidersElem") }
supportedProvidersList.add(supportedProvidersElem)
} else { throw ParsingException("Wrong element type for supportedProviders") }
}
supportedProviders = supportedProvidersList
} else { throw ParsingException("Wrong type for supportedProviders") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.NormalizedToolDescription(
info = info ?: throw ParsingException("Missing key 'info'"),
container = container,
defaultNumberOfNodes = defaultNumberOfNodes ?: throw ParsingException("Missing key 'defaultNumberOfNodes'"),
defaultTimeAllocation = defaultTimeAllocation ?: throw ParsingException("Missing key 'defaultTimeAllocation'"),
requiredModules = requiredModules ?: throw ParsingException("Missing key 'requiredModules'"),
authors = authors ?: throw ParsingException("Missing key 'authors'"),
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
backend = backend ?: throw ParsingException("Missing key 'backend'"),
license = license ?: throw ParsingException("Missing key 'license'"),
image = image,
supportedProviders = supportedProviders,
)
}
inline fun `dk_sdu_cloud_app_store_api_NameAndVersion_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.NameAndVersion {
var name: String? = null
var version: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"version" -> {
if (prop.element is JsonStreamElement.Text) {
version = prop.element.value
} else { throw ParsingException("Wrong type for version") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.NameAndVersion(
name = name ?: throw ParsingException("Missing key 'name'"),
version = version ?: throw ParsingException("Missing key 'version'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_SimpleDuration_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.SimpleDuration {
var hours: Int? = null
var minutes: Int? = null
var seconds: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"hours" -> {
if (prop.element is JsonStreamElement.Number) {
hours = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for hours") }
}
"minutes" -> {
if (prop.element is JsonStreamElement.Number) {
minutes = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for minutes") }
}
"seconds" -> {
if (prop.element is JsonStreamElement.Number) {
seconds = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for seconds") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.SimpleDuration(
hours = hours ?: throw ParsingException("Missing key 'hours'"),
minutes = minutes ?: throw ParsingException("Missing key 'minutes'"),
seconds = seconds ?: throw ParsingException("Missing key 'seconds'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_FindByNameAndPagination_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.FindByNameAndPagination {
var appName: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"appName" -> {
if (prop.element is JsonStreamElement.Text) {
appName = prop.element.value
} else { throw ParsingException("Wrong type for appName") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.FindByNameAndPagination(
appName = appName ?: throw ParsingException("Missing key 'appName'"),
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_PaginationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.PaginationRequest {
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.PaginationRequest(
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_app_store_api_UploadApplicationLogoRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.UploadApplicationLogoRequest {
var name: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.UploadApplicationLogoRequest(
name = name ?: throw ParsingException("Missing key 'name'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ClearLogoRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ClearLogoRequest {
var name: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ClearLogoRequest(
name = name ?: throw ParsingException("Missing key 'name'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_FetchLogoRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.FetchLogoRequest {
var name: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.FetchLogoRequest(
name = name ?: throw ParsingException("Missing key 'name'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_FavoriteRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.FavoriteRequest {
var appName: String? = null
var appVersion: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"appName" -> {
if (prop.element is JsonStreamElement.Text) {
appName = prop.element.value
} else { throw ParsingException("Wrong type for appName") }
}
"appVersion" -> {
if (prop.element is JsonStreamElement.Text) {
appVersion = prop.element.value
} else { throw ParsingException("Wrong type for appVersion") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.FavoriteRequest(
appName = appName ?: throw ParsingException("Missing key 'appName'"),
appVersion = appVersion ?: throw ParsingException("Missing key 'appVersion'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationSummaryWithFavorite_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationSummaryWithFavorite {
var metadata: dk.sdu.cloud.app.store.api.ApplicationMetadata? = null
var favorite: Boolean? = null
var tags: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"metadata" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
metadata = parseJson<dk.sdu.cloud.app.store.api.ApplicationMetadata>(parser)
} else { throw ParsingException("Wrong type for metadata") }
}
"favorite" -> {
if (prop.element is JsonStreamElement.Bool) {
favorite = prop.element.value
} else { throw ParsingException("Wrong type for favorite") }
}
"tags" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val tagsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val tagsElem: String
if (prop.element is JsonStreamElement.Text) {
tagsElem = prop.element.value
} else { throw ParsingException("Wrong type for tagsElem") }
tagsList.add(tagsElem)
} else { throw ParsingException("Wrong element type for tags") }
}
tags = tagsList
} else { throw ParsingException("Wrong type for tags") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationSummaryWithFavorite(
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
favorite = favorite ?: throw ParsingException("Missing key 'favorite'"),
tags = tags ?: throw ParsingException("Missing key 'tags'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationMetadata_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationMetadata {
var name: String? = null
var version: String? = null
var authors: List<String>? = null
var title: String? = null
var description: String? = null
var website: String? = null
var public: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"version" -> {
if (prop.element is JsonStreamElement.Text) {
version = prop.element.value
} else { throw ParsingException("Wrong type for version") }
}
"authors" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val authorsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val authorsElem: String
if (prop.element is JsonStreamElement.Text) {
authorsElem = prop.element.value
} else { throw ParsingException("Wrong type for authorsElem") }
authorsList.add(authorsElem)
} else { throw ParsingException("Wrong element type for authors") }
}
authors = authorsList
} else { throw ParsingException("Wrong type for authors") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"website" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
website = prop.element.value
} else { throw ParsingException("Wrong type for website") }
}
"public" -> {
if (prop.element is JsonStreamElement.Bool) {
public = prop.element.value
} else { throw ParsingException("Wrong type for public") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationMetadata(
name = name ?: throw ParsingException("Missing key 'name'"),
version = version ?: throw ParsingException("Missing key 'version'"),
authors = authors ?: throw ParsingException("Missing key 'authors'"),
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
website = website,
public = public ?: throw ParsingException("Missing key 'public'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_TagSearchRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.TagSearchRequest {
var query: String? = null
var excludeTools: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"query" -> {
if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
"excludeTools" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
excludeTools = prop.element.value
} else { throw ParsingException("Wrong type for excludeTools") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.TagSearchRequest(
query = query ?: throw ParsingException("Missing key 'query'"),
excludeTools = excludeTools,
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_app_store_api_AppSearchRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppSearchRequest {
var query: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"query" -> {
if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppSearchRequest(
query = query ?: throw ParsingException("Missing key 'query'"),
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_app_store_api_IsPublicRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.IsPublicRequest {
var applications: List<dk.sdu.cloud.app.store.api.NameAndVersion>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"applications" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val applicationsList = ArrayList<dk.sdu.cloud.app.store.api.NameAndVersion>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val applicationsElem: dk.sdu.cloud.app.store.api.NameAndVersion
if (prop.element is JsonStreamElement.ObjectStart) {
applicationsElem = parseJson<dk.sdu.cloud.app.store.api.NameAndVersion>(parser)
} else { throw ParsingException("Wrong type for applicationsElem") }
applicationsList.add(applicationsElem)
} else { throw ParsingException("Wrong element type for applications") }
}
applications = applicationsList
} else { throw ParsingException("Wrong type for applications") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.IsPublicRequest(
applications = applications ?: throw ParsingException("Missing key 'applications'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_IsPublicResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.IsPublicResponse {
var public: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"public" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for public") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.IsPublicResponse(
public = public ?: throw ParsingException("Missing key 'public'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_SetPublicRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.SetPublicRequest {
var appName: String? = null
var appVersion: String? = null
var public: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"appName" -> {
if (prop.element is JsonStreamElement.Text) {
appName = prop.element.value
} else { throw ParsingException("Wrong type for appName") }
}
"appVersion" -> {
if (prop.element is JsonStreamElement.Text) {
appVersion = prop.element.value
} else { throw ParsingException("Wrong type for appVersion") }
}
"public" -> {
if (prop.element is JsonStreamElement.Bool) {
public = prop.element.value
} else { throw ParsingException("Wrong type for public") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.SetPublicRequest(
appName = appName ?: throw ParsingException("Missing key 'appName'"),
appVersion = appVersion ?: throw ParsingException("Missing key 'appVersion'"),
public = public ?: throw ParsingException("Missing key 'public'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AdvancedSearchRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AdvancedSearchRequest {
var query: String? = null
var tags: List<String>? = null
var showAllVersions: Boolean? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"query" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
query = prop.element.value
} else { throw ParsingException("Wrong type for query") }
}
"tags" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ArrayStart) {
val tagsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val tagsElem: String
if (prop.element is JsonStreamElement.Text) {
tagsElem = prop.element.value
} else { throw ParsingException("Wrong type for tagsElem") }
tagsList.add(tagsElem)
} else { throw ParsingException("Wrong element type for tags") }
}
tags = tagsList
} else { throw ParsingException("Wrong type for tags") }
}
"showAllVersions" -> {
if (prop.element is JsonStreamElement.Bool) {
showAllVersions = prop.element.value
} else { throw ParsingException("Wrong type for showAllVersions") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AdvancedSearchRequest(
query = query,
tags = tags,
showAllVersions = showAllVersions ?: throw ParsingException("Missing key 'showAllVersions'"),
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_app_store_api_FindApplicationAndOptionalDependencies_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.FindApplicationAndOptionalDependencies {
var appName: String? = null
var appVersion: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"appName" -> {
if (prop.element is JsonStreamElement.Text) {
appName = prop.element.value
} else { throw ParsingException("Wrong type for appName") }
}
"appVersion" -> {
if (prop.element is JsonStreamElement.Text) {
appVersion = prop.element.value
} else { throw ParsingException("Wrong type for appVersion") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.FindApplicationAndOptionalDependencies(
appName = appName ?: throw ParsingException("Missing key 'appName'"),
appVersion = appVersion ?: throw ParsingException("Missing key 'appVersion'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationWithFavoriteAndTags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationWithFavoriteAndTags {
var metadata: dk.sdu.cloud.app.store.api.ApplicationMetadata? = null
var invocation: dk.sdu.cloud.app.store.api.ApplicationInvocationDescription? = null
var favorite: Boolean? = null
var tags: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"metadata" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
metadata = parseJson<dk.sdu.cloud.app.store.api.ApplicationMetadata>(parser)
} else { throw ParsingException("Wrong type for metadata") }
}
"invocation" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
invocation = parseJson<dk.sdu.cloud.app.store.api.ApplicationInvocationDescription>(parser)
} else { throw ParsingException("Wrong type for invocation") }
}
"favorite" -> {
if (prop.element is JsonStreamElement.Bool) {
favorite = prop.element.value
} else { throw ParsingException("Wrong type for favorite") }
}
"tags" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val tagsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val tagsElem: String
if (prop.element is JsonStreamElement.Text) {
tagsElem = prop.element.value
} else { throw ParsingException("Wrong type for tagsElem") }
tagsList.add(tagsElem)
} else { throw ParsingException("Wrong element type for tags") }
}
tags = tagsList
} else { throw ParsingException("Wrong type for tags") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationWithFavoriteAndTags(
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
invocation = invocation ?: throw ParsingException("Missing key 'invocation'"),
favorite = favorite ?: throw ParsingException("Missing key 'favorite'"),
tags = tags ?: throw ParsingException("Missing key 'tags'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationInvocationDescription_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationInvocationDescription {
var tool: dk.sdu.cloud.app.store.api.ToolReference? = null
var invocation: List<dk.sdu.cloud.app.store.api.InvocationParameter>? = null
var parameters: List<dk.sdu.cloud.app.store.api.ApplicationParameter>? = null
var outputFileGlobs: List<String>? = null
var applicationType: dk.sdu.cloud.app.store.api.ApplicationType? = null
var vnc: dk.sdu.cloud.app.store.api.VncDescription? = null
var web: dk.sdu.cloud.app.store.api.WebDescription? = null
var container: dk.sdu.cloud.app.store.api.ContainerDescription? = null
var environment: kotlinx.serialization.json.JsonObject? = null
var allowAdditionalMounts: Boolean? = null
var allowAdditionalPeers: Boolean? = null
var allowMultiNode: Boolean? = null
var allowPublicIp: Boolean? = null
var allowPublicLink: Boolean? = null
var fileExtensions: List<String>? = null
var licenseServers: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"tool" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
tool = parseJson<dk.sdu.cloud.app.store.api.ToolReference>(parser)
} else { throw ParsingException("Wrong type for tool") }
}
"invocation" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val invocationList = ArrayList<dk.sdu.cloud.app.store.api.InvocationParameter>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val invocationElem: dk.sdu.cloud.app.store.api.InvocationParameter
if (prop.element is JsonStreamElement.ObjectStart) {
invocationElem = parseJson<dk.sdu.cloud.app.store.api.InvocationParameter>(parser)
} else { throw ParsingException("Wrong type for invocationElem") }
invocationList.add(invocationElem)
} else { throw ParsingException("Wrong element type for invocation") }
}
invocation = invocationList
} else { throw ParsingException("Wrong type for invocation") }
}
"parameters" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val parametersList = ArrayList<dk.sdu.cloud.app.store.api.ApplicationParameter>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val parametersElem: dk.sdu.cloud.app.store.api.ApplicationParameter
if (prop.element is JsonStreamElement.ObjectStart) {
parametersElem = parseJson<dk.sdu.cloud.app.store.api.ApplicationParameter>(parser)
} else { throw ParsingException("Wrong type for parametersElem") }
parametersList.add(parametersElem)
} else { throw ParsingException("Wrong element type for parameters") }
}
parameters = parametersList
} else { throw ParsingException("Wrong type for parameters") }
}
"outputFileGlobs" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val outputFileGlobsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val outputFileGlobsElem: String
if (prop.element is JsonStreamElement.Text) {
outputFileGlobsElem = prop.element.value
} else { throw ParsingException("Wrong type for outputFileGlobsElem") }
outputFileGlobsList.add(outputFileGlobsElem)
} else { throw ParsingException("Wrong element type for outputFileGlobs") }
}
outputFileGlobs = outputFileGlobsList
} else { throw ParsingException("Wrong type for outputFileGlobs") }
}
"applicationType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
applicationType = parseJson<dk.sdu.cloud.app.store.api.ApplicationType>(parser)
} else { throw ParsingException("Wrong type for applicationType") }
}
"vnc" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
vnc = parseJson<dk.sdu.cloud.app.store.api.VncDescription?>(parser)
} else { throw ParsingException("Wrong type for vnc") }
}
"web" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
web = parseJson<dk.sdu.cloud.app.store.api.WebDescription?>(parser)
} else { throw ParsingException("Wrong type for web") }
}
"container" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
container = parseJson<dk.sdu.cloud.app.store.api.ContainerDescription?>(parser)
} else { throw ParsingException("Wrong type for container") }
}
"environment" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for environment") }
}
"allowAdditionalMounts" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
allowAdditionalMounts = prop.element.value
} else { throw ParsingException("Wrong type for allowAdditionalMounts") }
}
"allowAdditionalPeers" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
allowAdditionalPeers = prop.element.value
} else { throw ParsingException("Wrong type for allowAdditionalPeers") }
}
"allowMultiNode" -> {
if (prop.element is JsonStreamElement.Bool) {
allowMultiNode = prop.element.value
} else { throw ParsingException("Wrong type for allowMultiNode") }
}
"allowPublicIp" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
allowPublicIp = prop.element.value
} else { throw ParsingException("Wrong type for allowPublicIp") }
}
"allowPublicLink" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
allowPublicLink = prop.element.value
} else { throw ParsingException("Wrong type for allowPublicLink") }
}
"fileExtensions" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val fileExtensionsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val fileExtensionsElem: String
if (prop.element is JsonStreamElement.Text) {
fileExtensionsElem = prop.element.value
} else { throw ParsingException("Wrong type for fileExtensionsElem") }
fileExtensionsList.add(fileExtensionsElem)
} else { throw ParsingException("Wrong element type for fileExtensions") }
}
fileExtensions = fileExtensionsList
} else { throw ParsingException("Wrong type for fileExtensions") }
}
"licenseServers" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val licenseServersList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val licenseServersElem: String
if (prop.element is JsonStreamElement.Text) {
licenseServersElem = prop.element.value
} else { throw ParsingException("Wrong type for licenseServersElem") }
licenseServersList.add(licenseServersElem)
} else { throw ParsingException("Wrong element type for licenseServers") }
}
licenseServers = licenseServersList
} else { throw ParsingException("Wrong type for licenseServers") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationInvocationDescription(
tool = tool ?: throw ParsingException("Missing key 'tool'"),
invocation = invocation ?: throw ParsingException("Missing key 'invocation'"),
parameters = parameters ?: throw ParsingException("Missing key 'parameters'"),
outputFileGlobs = outputFileGlobs ?: throw ParsingException("Missing key 'outputFileGlobs'"),
applicationType = applicationType ?: throw ParsingException("Missing key 'applicationType'"),
vnc = vnc,
web = web,
container = container,
environment = environment,
allowAdditionalMounts = allowAdditionalMounts,
allowAdditionalPeers = allowAdditionalPeers,
allowMultiNode = allowMultiNode ?: throw ParsingException("Missing key 'allowMultiNode'"),
allowPublicIp = allowPublicIp,
allowPublicLink = allowPublicLink,
fileExtensions = fileExtensions ?: throw ParsingException("Missing key 'fileExtensions'"),
licenseServers = licenseServers ?: throw ParsingException("Missing key 'licenseServers'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ToolReference_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ToolReference {
var name: String? = null
var version: String? = null
var tool: dk.sdu.cloud.app.store.api.Tool? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"version" -> {
if (prop.element is JsonStreamElement.Text) {
version = prop.element.value
} else { throw ParsingException("Wrong type for version") }
}
"tool" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
tool = parseJson<dk.sdu.cloud.app.store.api.Tool?>(parser)
} else { throw ParsingException("Wrong type for tool") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ToolReference(
name = name ?: throw ParsingException("Missing key 'name'"),
version = version ?: throw ParsingException("Missing key 'version'"),
tool = tool,
)
}
inline fun `dk_sdu_cloud_app_store_api_EnvironmentVariableParameter_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.EnvironmentVariableParameter {
var variable: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"variable" -> {
if (prop.element is JsonStreamElement.Text) {
variable = prop.element.value
} else { throw ParsingException("Wrong type for variable") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.EnvironmentVariableParameter(
variable = variable ?: throw ParsingException("Missing key 'variable'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_WordInvocationParameter_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.WordInvocationParameter {
var word: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"word" -> {
if (prop.element is JsonStreamElement.Text) {
word = prop.element.value
} else { throw ParsingException("Wrong type for word") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.WordInvocationParameter(
word = word ?: throw ParsingException("Missing key 'word'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_VariableInvocationParameter_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.VariableInvocationParameter {
var variableNames: List<String>? = null
var prefixGlobal: String? = null
var suffixGlobal: String? = null
var prefixVariable: String? = null
var suffixVariable: String? = null
var isPrefixVariablePartOfArg: Boolean? = null
var isSuffixVariablePartOfArg: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"variableNames" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val variableNamesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val variableNamesElem: String
if (prop.element is JsonStreamElement.Text) {
variableNamesElem = prop.element.value
} else { throw ParsingException("Wrong type for variableNamesElem") }
variableNamesList.add(variableNamesElem)
} else { throw ParsingException("Wrong element type for variableNames") }
}
variableNames = variableNamesList
} else { throw ParsingException("Wrong type for variableNames") }
}
"prefixGlobal" -> {
if (prop.element is JsonStreamElement.Text) {
prefixGlobal = prop.element.value
} else { throw ParsingException("Wrong type for prefixGlobal") }
}
"suffixGlobal" -> {
if (prop.element is JsonStreamElement.Text) {
suffixGlobal = prop.element.value
} else { throw ParsingException("Wrong type for suffixGlobal") }
}
"prefixVariable" -> {
if (prop.element is JsonStreamElement.Text) {
prefixVariable = prop.element.value
} else { throw ParsingException("Wrong type for prefixVariable") }
}
"suffixVariable" -> {
if (prop.element is JsonStreamElement.Text) {
suffixVariable = prop.element.value
} else { throw ParsingException("Wrong type for suffixVariable") }
}
"isPrefixVariablePartOfArg" -> {
if (prop.element is JsonStreamElement.Bool) {
isPrefixVariablePartOfArg = prop.element.value
} else { throw ParsingException("Wrong type for isPrefixVariablePartOfArg") }
}
"isSuffixVariablePartOfArg" -> {
if (prop.element is JsonStreamElement.Bool) {
isSuffixVariablePartOfArg = prop.element.value
} else { throw ParsingException("Wrong type for isSuffixVariablePartOfArg") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.VariableInvocationParameter(
variableNames = variableNames ?: throw ParsingException("Missing key 'variableNames'"),
prefixGlobal = prefixGlobal ?: throw ParsingException("Missing key 'prefixGlobal'"),
suffixGlobal = suffixGlobal ?: throw ParsingException("Missing key 'suffixGlobal'"),
prefixVariable = prefixVariable ?: throw ParsingException("Missing key 'prefixVariable'"),
suffixVariable = suffixVariable ?: throw ParsingException("Missing key 'suffixVariable'"),
isPrefixVariablePartOfArg = isPrefixVariablePartOfArg ?: throw ParsingException("Missing key 'isPrefixVariablePartOfArg'"),
isSuffixVariablePartOfArg = isSuffixVariablePartOfArg ?: throw ParsingException("Missing key 'isSuffixVariablePartOfArg'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_BooleanFlagParameter_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.BooleanFlagParameter {
var variableName: String? = null
var flag: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"variableName" -> {
if (prop.element is JsonStreamElement.Text) {
variableName = prop.element.value
} else { throw ParsingException("Wrong type for variableName") }
}
"flag" -> {
if (prop.element is JsonStreamElement.Text) {
flag = prop.element.value
} else { throw ParsingException("Wrong type for flag") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.BooleanFlagParameter(
variableName = variableName ?: throw ParsingException("Missing key 'variableName'"),
flag = flag ?: throw ParsingException("Missing key 'flag'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_InputFile_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.InputFile {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.InputFile(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_InputDirectory_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.InputDirectory {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.InputDirectory(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_Text_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.Text {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.Text(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_TextArea_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.TextArea {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.TextArea(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_Integer_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.Integer {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
var min: Long? = null
var max: Long? = null
var step: Long? = null
var unitName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"min" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
min = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for min") }
}
"max" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
max = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for max") }
}
"step" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
step = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for step") }
}
"unitName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
unitName = prop.element.value
} else { throw ParsingException("Wrong type for unitName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.Integer(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
min = min,
max = max,
step = step,
unitName = unitName,
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_FloatingPoint_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.FloatingPoint {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
var min: Double? = null
var max: Double? = null
var step: Double? = null
var unitName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"min" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
min = prop.element.value
} else { throw ParsingException("Wrong type for min") }
}
"max" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
max = prop.element.value
} else { throw ParsingException("Wrong type for max") }
}
"step" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
step = prop.element.value
} else { throw ParsingException("Wrong type for step") }
}
"unitName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
unitName = prop.element.value
} else { throw ParsingException("Wrong type for unitName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.FloatingPoint(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
min = min,
max = max,
step = step,
unitName = unitName,
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_Bool_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.Bool {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
var trueValue: String? = null
var falseValue: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"trueValue" -> {
if (prop.element is JsonStreamElement.Text) {
trueValue = prop.element.value
} else { throw ParsingException("Wrong type for trueValue") }
}
"falseValue" -> {
if (prop.element is JsonStreamElement.Text) {
falseValue = prop.element.value
} else { throw ParsingException("Wrong type for falseValue") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.Bool(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
trueValue = trueValue ?: throw ParsingException("Missing key 'trueValue'"),
falseValue = falseValue ?: throw ParsingException("Missing key 'falseValue'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_Enumeration_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.Enumeration {
var name: String? = null
var optional: Boolean? = null
var defaultValue: Any? = null
var title: String? = null
var description: String? = null
var options: List<dk.sdu.cloud.app.store.api.ApplicationParameter.EnumOption>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"defaultValue" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is TODO()) {
} else { throw ParsingException("Wrong type for defaultValue") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"options" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val optionsList = ArrayList<dk.sdu.cloud.app.store.api.ApplicationParameter.EnumOption>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val optionsElem: dk.sdu.cloud.app.store.api.ApplicationParameter.EnumOption
if (prop.element is JsonStreamElement.ObjectStart) {
optionsElem = parseJson<dk.sdu.cloud.app.store.api.ApplicationParameter.EnumOption>(parser)
} else { throw ParsingException("Wrong type for optionsElem") }
optionsList.add(optionsElem)
} else { throw ParsingException("Wrong element type for options") }
}
options = optionsList
} else { throw ParsingException("Wrong type for options") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.Enumeration(
name = name ?: throw ParsingException("Missing key 'name'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
defaultValue = defaultValue,
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
options = options ?: throw ParsingException("Missing key 'options'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_EnumOption_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.EnumOption {
var name: String? = null
var value: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"value" -> {
if (prop.element is JsonStreamElement.Text) {
value = prop.element.value
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.EnumOption(
name = name ?: throw ParsingException("Missing key 'name'"),
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_Peer_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.Peer {
var name: String? = null
var title: String? = null
var description: String? = null
var suggestedApplication: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"suggestedApplication" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
suggestedApplication = prop.element.value
} else { throw ParsingException("Wrong type for suggestedApplication") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.Peer(
name = name ?: throw ParsingException("Missing key 'name'"),
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
suggestedApplication = suggestedApplication,
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_Ingress_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.Ingress {
var name: String? = null
var title: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.Ingress(
name = name ?: throw ParsingException("Missing key 'name'"),
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_LicenseServer_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.LicenseServer {
var name: String? = null
var title: String? = null
var optional: Boolean? = null
var description: String? = null
var tagged: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"optional" -> {
if (prop.element is JsonStreamElement.Bool) {
optional = prop.element.value
} else { throw ParsingException("Wrong type for optional") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
"tagged" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val taggedList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val taggedElem: String
if (prop.element is JsonStreamElement.Text) {
taggedElem = prop.element.value
} else { throw ParsingException("Wrong type for taggedElem") }
taggedList.add(taggedElem)
} else { throw ParsingException("Wrong element type for tagged") }
}
tagged = taggedList
} else { throw ParsingException("Wrong type for tagged") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.LicenseServer(
name = name ?: throw ParsingException("Missing key 'name'"),
title = title ?: throw ParsingException("Missing key 'title'"),
optional = optional ?: throw ParsingException("Missing key 'optional'"),
description = description ?: throw ParsingException("Missing key 'description'"),
tagged = tagged ?: throw ParsingException("Missing key 'tagged'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationParameter_NetworkIP_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationParameter.NetworkIP {
var name: String? = null
var title: String? = null
var description: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"name" -> {
if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"description" -> {
if (prop.element is JsonStreamElement.Text) {
description = prop.element.value
} else { throw ParsingException("Wrong type for description") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationParameter.NetworkIP(
name = name ?: throw ParsingException("Missing key 'name'"),
title = title ?: throw ParsingException("Missing key 'title'"),
description = description ?: throw ParsingException("Missing key 'description'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_VncDescription_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.VncDescription {
var password: String? = null
var port: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"password" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
password = prop.element.value
} else { throw ParsingException("Wrong type for password") }
}
"port" -> {
if (prop.element is JsonStreamElement.Number) {
port = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for port") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.VncDescription(
password = password,
port = port ?: throw ParsingException("Missing key 'port'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_WebDescription_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.WebDescription {
var port: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"port" -> {
if (prop.element is JsonStreamElement.Number) {
port = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for port") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.WebDescription(
port = port ?: throw ParsingException("Missing key 'port'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ContainerDescription_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ContainerDescription {
var changeWorkingDirectory: Boolean? = null
var runAsRoot: Boolean? = null
var runAsRealUser: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"changeWorkingDirectory" -> {
if (prop.element is JsonStreamElement.Bool) {
changeWorkingDirectory = prop.element.value
} else { throw ParsingException("Wrong type for changeWorkingDirectory") }
}
"runAsRoot" -> {
if (prop.element is JsonStreamElement.Bool) {
runAsRoot = prop.element.value
} else { throw ParsingException("Wrong type for runAsRoot") }
}
"runAsRealUser" -> {
if (prop.element is JsonStreamElement.Bool) {
runAsRealUser = prop.element.value
} else { throw ParsingException("Wrong type for runAsRealUser") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ContainerDescription(
changeWorkingDirectory = changeWorkingDirectory ?: throw ParsingException("Missing key 'changeWorkingDirectory'"),
runAsRoot = runAsRoot ?: throw ParsingException("Missing key 'runAsRoot'"),
runAsRealUser = runAsRealUser ?: throw ParsingException("Missing key 'runAsRealUser'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_HasPermissionRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.HasPermissionRequest {
var appName: String? = null
var appVersion: String? = null
var permission: List<dk.sdu.cloud.app.store.api.ApplicationAccessRight>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"appName" -> {
if (prop.element is JsonStreamElement.Text) {
appName = prop.element.value
} else { throw ParsingException("Wrong type for appName") }
}
"appVersion" -> {
if (prop.element is JsonStreamElement.Text) {
appVersion = prop.element.value
} else { throw ParsingException("Wrong type for appVersion") }
}
"permission" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val permissionList = ArrayList<dk.sdu.cloud.app.store.api.ApplicationAccessRight>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val permissionElem: dk.sdu.cloud.app.store.api.ApplicationAccessRight
if (prop.element is JsonStreamElement.ObjectStart) {
permissionElem = parseJson<dk.sdu.cloud.app.store.api.ApplicationAccessRight>(parser)
} else { throw ParsingException("Wrong type for permissionElem") }
permissionList.add(permissionElem)
} else { throw ParsingException("Wrong element type for permission") }
}
permission = permissionList
} else { throw ParsingException("Wrong type for permission") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.HasPermissionRequest(
appName = appName ?: throw ParsingException("Missing key 'appName'"),
appVersion = appVersion ?: throw ParsingException("Missing key 'appVersion'"),
permission = permission ?: throw ParsingException("Missing key 'permission'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ListAclRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ListAclRequest {
var appName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"appName" -> {
if (prop.element is JsonStreamElement.Text) {
appName = prop.element.value
} else { throw ParsingException("Wrong type for appName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ListAclRequest(
appName = appName ?: throw ParsingException("Missing key 'appName'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_DetailedEntityWithPermission_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.DetailedEntityWithPermission {
var entity: dk.sdu.cloud.app.store.api.DetailedAccessEntity? = null
var permission: dk.sdu.cloud.app.store.api.ApplicationAccessRight? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"entity" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
entity = parseJson<dk.sdu.cloud.app.store.api.DetailedAccessEntity>(parser)
} else { throw ParsingException("Wrong type for entity") }
}
"permission" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
permission = parseJson<dk.sdu.cloud.app.store.api.ApplicationAccessRight>(parser)
} else { throw ParsingException("Wrong type for permission") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.DetailedEntityWithPermission(
entity = entity ?: throw ParsingException("Missing key 'entity'"),
permission = permission ?: throw ParsingException("Missing key 'permission'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_DetailedAccessEntity_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.DetailedAccessEntity {
var user: String? = null
var project: dk.sdu.cloud.app.store.api.Project? = null
var group: dk.sdu.cloud.app.store.api.Project? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"user" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
user = prop.element.value
} else { throw ParsingException("Wrong type for user") }
}
"project" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
project = parseJson<dk.sdu.cloud.app.store.api.Project?>(parser)
} else { throw ParsingException("Wrong type for project") }
}
"group" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
group = parseJson<dk.sdu.cloud.app.store.api.Project?>(parser)
} else { throw ParsingException("Wrong type for group") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.DetailedAccessEntity(
user = user,
project = project,
group = group,
)
}
inline fun `dk_sdu_cloud_app_store_api_Project_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.Project {
var id: String? = null
var title: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.Project(
id = id ?: throw ParsingException("Missing key 'id'"),
title = title ?: throw ParsingException("Missing key 'title'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_UpdateAclRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.UpdateAclRequest {
var applicationName: String? = null
var changes: List<dk.sdu.cloud.app.store.api.ACLEntryRequest>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"applicationName" -> {
if (prop.element is JsonStreamElement.Text) {
applicationName = prop.element.value
} else { throw ParsingException("Wrong type for applicationName") }
}
"changes" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val changesList = ArrayList<dk.sdu.cloud.app.store.api.ACLEntryRequest>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val changesElem: dk.sdu.cloud.app.store.api.ACLEntryRequest
if (prop.element is JsonStreamElement.ObjectStart) {
changesElem = parseJson<dk.sdu.cloud.app.store.api.ACLEntryRequest>(parser)
} else { throw ParsingException("Wrong type for changesElem") }
changesList.add(changesElem)
} else { throw ParsingException("Wrong element type for changes") }
}
changes = changesList
} else { throw ParsingException("Wrong type for changes") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.UpdateAclRequest(
applicationName = applicationName ?: throw ParsingException("Missing key 'applicationName'"),
changes = changes ?: throw ParsingException("Missing key 'changes'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_ACLEntryRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ACLEntryRequest {
var entity: dk.sdu.cloud.app.store.api.AccessEntity? = null
var rights: dk.sdu.cloud.app.store.api.ApplicationAccessRight? = null
var revoke: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"entity" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
entity = parseJson<dk.sdu.cloud.app.store.api.AccessEntity>(parser)
} else { throw ParsingException("Wrong type for entity") }
}
"rights" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
rights = parseJson<dk.sdu.cloud.app.store.api.ApplicationAccessRight>(parser)
} else { throw ParsingException("Wrong type for rights") }
}
"revoke" -> {
if (prop.element is JsonStreamElement.Bool) {
revoke = prop.element.value
} else { throw ParsingException("Wrong type for revoke") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ACLEntryRequest(
entity = entity ?: throw ParsingException("Missing key 'entity'"),
rights = rights ?: throw ParsingException("Missing key 'rights'"),
revoke = revoke ?: throw ParsingException("Missing key 'revoke'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AccessEntity_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AccessEntity {
var user: String? = null
var project: String? = null
var group: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"user" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
user = prop.element.value
} else { throw ParsingException("Wrong type for user") }
}
"project" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
project = prop.element.value
} else { throw ParsingException("Wrong type for project") }
}
"group" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
group = prop.element.value
} else { throw ParsingException("Wrong type for group") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AccessEntity(
user = user,
project = project,
group = group,
)
}
inline fun `dk_sdu_cloud_app_store_api_FindBySupportedFileExtension_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.FindBySupportedFileExtension {
var files: List<String>? = null
var itemsPerPage: Int? = null
var next: String? = null
var consistency: dk.sdu.cloud.PaginationRequestV2Consistency? = null
var itemsToSkip: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"files" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val filesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val filesElem: String
if (prop.element is JsonStreamElement.Text) {
filesElem = prop.element.value
} else { throw ParsingException("Wrong type for filesElem") }
filesList.add(filesElem)
} else { throw ParsingException("Wrong element type for files") }
}
files = filesList
} else { throw ParsingException("Wrong type for files") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"next" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
next = prop.element.value
} else { throw ParsingException("Wrong type for next") }
}
"consistency" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
consistency = parseJson<dk.sdu.cloud.PaginationRequestV2Consistency?>(parser)
} else { throw ParsingException("Wrong type for consistency") }
}
"itemsToSkip" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsToSkip = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for itemsToSkip") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.FindBySupportedFileExtension(
files = files ?: throw ParsingException("Missing key 'files'"),
itemsPerPage = itemsPerPage,
next = next,
consistency = consistency,
itemsToSkip = itemsToSkip,
)
}
inline fun `dk_sdu_cloud_app_store_api_ApplicationWithExtension_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.ApplicationWithExtension {
var metadata: dk.sdu.cloud.app.store.api.ApplicationMetadata? = null
var extensions: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"metadata" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
metadata = parseJson<dk.sdu.cloud.app.store.api.ApplicationMetadata>(parser)
} else { throw ParsingException("Wrong type for metadata") }
}
"extensions" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val extensionsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val extensionsElem: String
if (prop.element is JsonStreamElement.Text) {
extensionsElem = prop.element.value
} else { throw ParsingException("Wrong type for extensionsElem") }
extensionsList.add(extensionsElem)
} else { throw ParsingException("Wrong element type for extensions") }
}
extensions = extensionsList
} else { throw ParsingException("Wrong type for extensions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.ApplicationWithExtension(
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
extensions = extensions ?: throw ParsingException("Missing key 'extensions'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_FindLatestByToolRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.FindLatestByToolRequest {
var tool: String? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"tool" -> {
if (prop.element is JsonStreamElement.Text) {
tool = prop.element.value
} else { throw ParsingException("Wrong type for tool") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.FindLatestByToolRequest(
tool = tool ?: throw ParsingException("Missing key 'tool'"),
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_app_store_api_Application_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.Application {
var metadata: dk.sdu.cloud.app.store.api.ApplicationMetadata? = null
var invocation: dk.sdu.cloud.app.store.api.ApplicationInvocationDescription? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"metadata" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
metadata = parseJson<dk.sdu.cloud.app.store.api.ApplicationMetadata>(parser)
} else { throw ParsingException("Wrong type for metadata") }
}
"invocation" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
invocation = parseJson<dk.sdu.cloud.app.store.api.ApplicationInvocationDescription>(parser)
} else { throw ParsingException("Wrong type for invocation") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.Application(
metadata = metadata ?: throw ParsingException("Missing key 'metadata'"),
invocation = invocation ?: throw ParsingException("Missing key 'invocation'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_DeleteAppRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.DeleteAppRequest {
var appName: String? = null
var appVersion: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"appName" -> {
if (prop.element is JsonStreamElement.Text) {
appName = prop.element.value
} else { throw ParsingException("Wrong type for appName") }
}
"appVersion" -> {
if (prop.element is JsonStreamElement.Text) {
appVersion = prop.element.value
} else { throw ParsingException("Wrong type for appVersion") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.DeleteAppRequest(
appName = appName ?: throw ParsingException("Missing key 'appName'"),
appVersion = appVersion ?: throw ParsingException("Missing key 'appVersion'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_CreateTagsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.CreateTagsRequest {
var tags: List<String>? = null
var applicationName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"tags" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val tagsList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val tagsElem: String
if (prop.element is JsonStreamElement.Text) {
tagsElem = prop.element.value
} else { throw ParsingException("Wrong type for tagsElem") }
tagsList.add(tagsElem)
} else { throw ParsingException("Wrong element type for tags") }
}
tags = tagsList
} else { throw ParsingException("Wrong type for tags") }
}
"applicationName" -> {
if (prop.element is JsonStreamElement.Text) {
applicationName = prop.element.value
} else { throw ParsingException("Wrong type for applicationName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.CreateTagsRequest(
tags = tags ?: throw ParsingException("Missing key 'tags'"),
applicationName = applicationName ?: throw ParsingException("Missing key 'applicationName'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobSpecification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobSpecification {
var application: dk.sdu.cloud.app.store.api.NameAndVersion? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var name: String? = null
var replicas: Int? = null
var allowDuplicateJob: Boolean? = null
var parameters: kotlinx.serialization.json.JsonObject? = null
var resources: List<dk.sdu.cloud.app.store.api.AppParameterValue>? = null
var timeAllocation: dk.sdu.cloud.app.store.api.SimpleDuration? = null
var openedFile: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"application" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
application = parseJson<dk.sdu.cloud.app.store.api.NameAndVersion>(parser)
} else { throw ParsingException("Wrong type for application") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"name" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"replicas" -> {
if (prop.element is JsonStreamElement.Number) {
replicas = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for replicas") }
}
"allowDuplicateJob" -> {
if (prop.element is JsonStreamElement.Bool) {
allowDuplicateJob = prop.element.value
} else { throw ParsingException("Wrong type for allowDuplicateJob") }
}
"parameters" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for parameters") }
}
"resources" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ArrayStart) {
val resourcesList = ArrayList<dk.sdu.cloud.app.store.api.AppParameterValue>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val resourcesElem: dk.sdu.cloud.app.store.api.AppParameterValue
if (prop.element is JsonStreamElement.ObjectStart) {
resourcesElem = parseJson<dk.sdu.cloud.app.store.api.AppParameterValue>(parser)
} else { throw ParsingException("Wrong type for resourcesElem") }
resourcesList.add(resourcesElem)
} else { throw ParsingException("Wrong element type for resources") }
}
resources = resourcesList
} else { throw ParsingException("Wrong type for resources") }
}
"timeAllocation" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
timeAllocation = parseJson<dk.sdu.cloud.app.store.api.SimpleDuration?>(parser)
} else { throw ParsingException("Wrong type for timeAllocation") }
}
"openedFile" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
openedFile = prop.element.value
} else { throw ParsingException("Wrong type for openedFile") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobSpecification(
application = application ?: throw ParsingException("Missing key 'application'"),
product = product ?: throw ParsingException("Missing key 'product'"),
name = name,
replicas = replicas ?: throw ParsingException("Missing key 'replicas'"),
allowDuplicateJob = allowDuplicateJob ?: throw ParsingException("Missing key 'allowDuplicateJob'"),
parameters = parameters,
resources = resources,
timeAllocation = timeAllocation,
openedFile = openedFile,
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_File_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.File {
var path: String? = null
var readOnly: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"path" -> {
if (prop.element is JsonStreamElement.Text) {
path = prop.element.value
} else { throw ParsingException("Wrong type for path") }
}
"readOnly" -> {
if (prop.element is JsonStreamElement.Bool) {
readOnly = prop.element.value
} else { throw ParsingException("Wrong type for readOnly") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.File(
path = path ?: throw ParsingException("Missing key 'path'"),
readOnly = readOnly ?: throw ParsingException("Missing key 'readOnly'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_Bool_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.Bool {
var value: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"value" -> {
if (prop.element is JsonStreamElement.Bool) {
value = prop.element.value
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.Bool(
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_TextArea_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.TextArea {
var value: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"value" -> {
if (prop.element is JsonStreamElement.Text) {
value = prop.element.value
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.TextArea(
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_Text_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.Text {
var value: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"value" -> {
if (prop.element is JsonStreamElement.Text) {
value = prop.element.value
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.Text(
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_Integer_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.Integer {
var value: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"value" -> {
if (prop.element is JsonStreamElement.Number) {
value = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.Integer(
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_FloatingPoint_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.FloatingPoint {
var value: Double? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"value" -> {
if (prop.element is JsonStreamElement.Number) {
value = prop.element.value
} else { throw ParsingException("Wrong type for value") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.FloatingPoint(
value = value ?: throw ParsingException("Missing key 'value'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_Peer_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.Peer {
var hostname: String? = null
var jobId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"hostname" -> {
if (prop.element is JsonStreamElement.Text) {
hostname = prop.element.value
} else { throw ParsingException("Wrong type for hostname") }
}
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.Peer(
hostname = hostname ?: throw ParsingException("Missing key 'hostname'"),
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_License_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.License {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.License(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_BlockStorage_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.BlockStorage {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.BlockStorage(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_Network_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.Network {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.Network(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_app_store_api_AppParameterValue_Ingress_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.store.api.AppParameterValue.Ingress {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.store.api.AppParameterValue.Ingress(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobUpdate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobUpdate {
var state: dk.sdu.cloud.app.orchestrator.api.JobState? = null
var outputFolder: String? = null
var status: String? = null
var expectedState: dk.sdu.cloud.app.orchestrator.api.JobState? = null
var expectedDifferentState: Boolean? = null
var newTimeAllocation: Long? = null
var timestamp: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"state" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.JobState?>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"outputFolder" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
outputFolder = prop.element.value
} else { throw ParsingException("Wrong type for outputFolder") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
"expectedState" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
expectedState = parseJson<dk.sdu.cloud.app.orchestrator.api.JobState?>(parser)
} else { throw ParsingException("Wrong type for expectedState") }
}
"expectedDifferentState" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
expectedDifferentState = prop.element.value
} else { throw ParsingException("Wrong type for expectedDifferentState") }
}
"newTimeAllocation" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
newTimeAllocation = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for newTimeAllocation") }
}
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobUpdate(
state = state,
outputFolder = outputFolder,
status = status,
expectedState = expectedState,
expectedDifferentState = expectedDifferentState,
newTimeAllocation = newTimeAllocation,
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ComputeSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ComputeSupport {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var docker: dk.sdu.cloud.app.orchestrator.api.ComputeSupport.Docker? = null
var virtualMachine: dk.sdu.cloud.app.orchestrator.api.ComputeSupport.VirtualMachine? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"docker" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
docker = parseJson<dk.sdu.cloud.app.orchestrator.api.ComputeSupport.Docker>(parser)
} else { throw ParsingException("Wrong type for docker") }
}
"virtualMachine" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
virtualMachine = parseJson<dk.sdu.cloud.app.orchestrator.api.ComputeSupport.VirtualMachine>(parser)
} else { throw ParsingException("Wrong type for virtualMachine") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ComputeSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
docker = docker ?: throw ParsingException("Missing key 'docker'"),
virtualMachine = virtualMachine ?: throw ParsingException("Missing key 'virtualMachine'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ComputeSupport_Docker_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ComputeSupport.Docker {
var enabled: Boolean? = null
var web: Boolean? = null
var vnc: Boolean? = null
var logs: Boolean? = null
var terminal: Boolean? = null
var peers: Boolean? = null
var timeExtension: Boolean? = null
var utilization: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"enabled" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
enabled = prop.element.value
} else { throw ParsingException("Wrong type for enabled") }
}
"web" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
web = prop.element.value
} else { throw ParsingException("Wrong type for web") }
}
"vnc" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
vnc = prop.element.value
} else { throw ParsingException("Wrong type for vnc") }
}
"logs" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
logs = prop.element.value
} else { throw ParsingException("Wrong type for logs") }
}
"terminal" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
terminal = prop.element.value
} else { throw ParsingException("Wrong type for terminal") }
}
"peers" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
peers = prop.element.value
} else { throw ParsingException("Wrong type for peers") }
}
"timeExtension" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
timeExtension = prop.element.value
} else { throw ParsingException("Wrong type for timeExtension") }
}
"utilization" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
utilization = prop.element.value
} else { throw ParsingException("Wrong type for utilization") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ComputeSupport.Docker(
enabled = enabled,
web = web,
vnc = vnc,
logs = logs,
terminal = terminal,
peers = peers,
timeExtension = timeExtension,
utilization = utilization,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ComputeSupport_VirtualMachine_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ComputeSupport.VirtualMachine {
var enabled: Boolean? = null
var logs: Boolean? = null
var vnc: Boolean? = null
var terminal: Boolean? = null
var timeExtension: Boolean? = null
var suspension: Boolean? = null
var utilization: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"enabled" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
enabled = prop.element.value
} else { throw ParsingException("Wrong type for enabled") }
}
"logs" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
logs = prop.element.value
} else { throw ParsingException("Wrong type for logs") }
}
"vnc" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
vnc = prop.element.value
} else { throw ParsingException("Wrong type for vnc") }
}
"terminal" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
terminal = prop.element.value
} else { throw ParsingException("Wrong type for terminal") }
}
"timeExtension" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
timeExtension = prop.element.value
} else { throw ParsingException("Wrong type for timeExtension") }
}
"suspension" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
suspension = prop.element.value
} else { throw ParsingException("Wrong type for suspension") }
}
"utilization" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
utilization = prop.element.value
} else { throw ParsingException("Wrong type for utilization") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ComputeSupport.VirtualMachine(
enabled = enabled,
logs = logs,
vnc = vnc,
terminal = terminal,
timeExtension = timeExtension,
suspension = suspension,
utilization = utilization,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_Job_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.Job {
var id: String? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var updates: List<dk.sdu.cloud.app.orchestrator.api.JobUpdate>? = null
var specification: dk.sdu.cloud.app.orchestrator.api.JobSpecification? = null
var status: dk.sdu.cloud.app.orchestrator.api.JobStatus? = null
var createdAt: Long? = null
var output: dk.sdu.cloud.app.orchestrator.api.JobOutput? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.app.orchestrator.api.JobUpdate>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.app.orchestrator.api.JobUpdate
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.app.orchestrator.api.JobUpdate>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.app.orchestrator.api.JobSpecification>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.app.orchestrator.api.JobStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"output" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
output = parseJson<dk.sdu.cloud.app.orchestrator.api.JobOutput?>(parser)
} else { throw ParsingException("Wrong type for output") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.Job(
id = id ?: throw ParsingException("Missing key 'id'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
status = status ?: throw ParsingException("Missing key 'status'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
output = output,
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobStatus_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobStatus {
var state: dk.sdu.cloud.app.orchestrator.api.JobState? = null
var jobParametersJson: dk.sdu.cloud.app.orchestrator.api.ExportedParameters? = null
var startedAt: Long? = null
var expiresAt: Long? = null
var resolvedApplication: dk.sdu.cloud.app.store.api.Application? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Compute, dk.sdu.cloud.app.orchestrator.api.ComputeSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.Compute? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"state" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.JobState>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"jobParametersJson" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
jobParametersJson = parseJson<dk.sdu.cloud.app.orchestrator.api.ExportedParameters?>(parser)
} else { throw ParsingException("Wrong type for jobParametersJson") }
}
"startedAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
startedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startedAt") }
}
"expiresAt" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
expiresAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for expiresAt") }
}
"resolvedApplication" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedApplication = parseJson<dk.sdu.cloud.app.store.api.Application?>(parser)
} else { throw ParsingException("Wrong type for resolvedApplication") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Compute, dk.sdu.cloud.app.orchestrator.api.ComputeSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.Compute?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobStatus(
state = state ?: throw ParsingException("Missing key 'state'"),
jobParametersJson = jobParametersJson,
startedAt = startedAt,
expiresAt = expiresAt,
resolvedApplication = resolvedApplication,
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ExportedParameters_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ExportedParameters {
var siteVersion: Int? = null
var request: dk.sdu.cloud.app.orchestrator.api.ExportedParametersRequest? = null
var machineType: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"siteVersion" -> {
if (prop.element is JsonStreamElement.Number) {
siteVersion = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for siteVersion") }
}
"request" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
request = parseJson<dk.sdu.cloud.app.orchestrator.api.ExportedParametersRequest>(parser)
} else { throw ParsingException("Wrong type for request") }
}
"machineType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for machineType") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ExportedParameters(
siteVersion = siteVersion ?: throw ParsingException("Missing key 'siteVersion'"),
request = request ?: throw ParsingException("Missing key 'request'"),
machineType = machineType ?: throw ParsingException("Missing key 'machineType'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ExportedParametersRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ExportedParametersRequest {
var application: dk.sdu.cloud.app.store.api.NameAndVersion? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var name: String? = null
var replicas: Int? = null
var parameters: kotlinx.serialization.json.JsonObject? = null
var resources: List<kotlinx.serialization.json.JsonObject>? = null
var timeAllocation: dk.sdu.cloud.app.store.api.SimpleDuration? = null
var resolvedProduct: kotlinx.serialization.json.JsonObject? = null
var resolvedApplication: kotlinx.serialization.json.JsonObject? = null
var resolvedSupport: kotlinx.serialization.json.JsonObject? = null
var allowDuplicateJob: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"application" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
application = parseJson<dk.sdu.cloud.app.store.api.NameAndVersion>(parser)
} else { throw ParsingException("Wrong type for application") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"name" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
name = prop.element.value
} else { throw ParsingException("Wrong type for name") }
}
"replicas" -> {
if (prop.element is JsonStreamElement.Number) {
replicas = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for replicas") }
}
"parameters" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for parameters") }
}
"resources" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val resourcesList = ArrayList<kotlinx.serialization.json.JsonObject>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val resourcesElem: kotlinx.serialization.json.JsonObject
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for resourcesElem") }
resourcesList.add(resourcesElem)
} else { throw ParsingException("Wrong element type for resources") }
}
resources = resourcesList
} else { throw ParsingException("Wrong type for resources") }
}
"timeAllocation" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
timeAllocation = parseJson<dk.sdu.cloud.app.store.api.SimpleDuration?>(parser)
} else { throw ParsingException("Wrong type for timeAllocation") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
"resolvedApplication" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for resolvedApplication") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"allowDuplicateJob" -> {
if (prop.element is JsonStreamElement.Bool) {
allowDuplicateJob = prop.element.value
} else { throw ParsingException("Wrong type for allowDuplicateJob") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ExportedParametersRequest(
application = application ?: throw ParsingException("Missing key 'application'"),
product = product ?: throw ParsingException("Missing key 'product'"),
name = name,
replicas = replicas ?: throw ParsingException("Missing key 'replicas'"),
parameters = parameters ?: throw ParsingException("Missing key 'parameters'"),
resources = resources ?: throw ParsingException("Missing key 'resources'"),
timeAllocation = timeAllocation,
resolvedProduct = resolvedProduct,
resolvedApplication = resolvedApplication,
resolvedSupport = resolvedSupport,
allowDuplicateJob = allowDuplicateJob ?: throw ParsingException("Missing key 'allowDuplicateJob'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobOutput_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobOutput {
var outputFolder: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"outputFolder" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
outputFolder = prop.element.value
} else { throw ParsingException("Wrong type for outputFolder") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobOutput(
outputFolder = outputFolder,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobIncludeFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobIncludeFlags {
var filterApplication: String? = null
var filterState: dk.sdu.cloud.app.orchestrator.api.JobState? = null
var includeParameters: Boolean? = null
var includeApplication: Boolean? = null
var includeProduct: Boolean? = null
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterApplication" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterApplication = prop.element.value
} else { throw ParsingException("Wrong type for filterApplication") }
}
"filterState" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterState = parseJson<dk.sdu.cloud.app.orchestrator.api.JobState?>(parser)
} else { throw ParsingException("Wrong type for filterState") }
}
"includeParameters" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeParameters = prop.element.value
} else { throw ParsingException("Wrong type for includeParameters") }
}
"includeApplication" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
includeApplication = prop.element.value
} else { throw ParsingException("Wrong type for includeApplication") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobIncludeFlags(
filterApplication = filterApplication,
filterState = filterState,
includeParameters = includeParameters,
includeApplication = includeApplication,
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsRetrieveUtilizationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsRetrieveUtilizationRequest {
var jobId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsRetrieveUtilizationRequest(
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsRetrieveUtilizationResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsRetrieveUtilizationResponse {
var capacity: dk.sdu.cloud.app.orchestrator.api.CpuAndMemory? = null
var usedCapacity: dk.sdu.cloud.app.orchestrator.api.CpuAndMemory? = null
var queueStatus: dk.sdu.cloud.app.orchestrator.api.QueueStatus? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"capacity" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
capacity = parseJson<dk.sdu.cloud.app.orchestrator.api.CpuAndMemory>(parser)
} else { throw ParsingException("Wrong type for capacity") }
}
"usedCapacity" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
usedCapacity = parseJson<dk.sdu.cloud.app.orchestrator.api.CpuAndMemory>(parser)
} else { throw ParsingException("Wrong type for usedCapacity") }
}
"queueStatus" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
queueStatus = parseJson<dk.sdu.cloud.app.orchestrator.api.QueueStatus>(parser)
} else { throw ParsingException("Wrong type for queueStatus") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsRetrieveUtilizationResponse(
capacity = capacity ?: throw ParsingException("Missing key 'capacity'"),
usedCapacity = usedCapacity ?: throw ParsingException("Missing key 'usedCapacity'"),
queueStatus = queueStatus ?: throw ParsingException("Missing key 'queueStatus'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_CpuAndMemory_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.CpuAndMemory {
var cpu: Double? = null
var memory: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"cpu" -> {
if (prop.element is JsonStreamElement.Number) {
cpu = prop.element.value
} else { throw ParsingException("Wrong type for cpu") }
}
"memory" -> {
if (prop.element is JsonStreamElement.Number) {
memory = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for memory") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.CpuAndMemory(
cpu = cpu ?: throw ParsingException("Missing key 'cpu'"),
memory = memory ?: throw ParsingException("Missing key 'memory'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_QueueStatus_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.QueueStatus {
var running: Int? = null
var pending: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"running" -> {
if (prop.element is JsonStreamElement.Number) {
running = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for running") }
}
"pending" -> {
if (prop.element is JsonStreamElement.Number) {
pending = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for pending") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.QueueStatus(
running = running ?: throw ParsingException("Missing key 'running'"),
pending = pending ?: throw ParsingException("Missing key 'pending'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsFollowResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsFollowResponse {
var updates: List<dk.sdu.cloud.app.orchestrator.api.JobUpdate>? = null
var log: List<dk.sdu.cloud.app.orchestrator.api.JobsLog>? = null
var newStatus: dk.sdu.cloud.app.orchestrator.api.JobStatus? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.app.orchestrator.api.JobUpdate>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.app.orchestrator.api.JobUpdate
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.app.orchestrator.api.JobUpdate>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"log" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val logList = ArrayList<dk.sdu.cloud.app.orchestrator.api.JobsLog>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val logElem: dk.sdu.cloud.app.orchestrator.api.JobsLog
if (prop.element is JsonStreamElement.ObjectStart) {
logElem = parseJson<dk.sdu.cloud.app.orchestrator.api.JobsLog>(parser)
} else { throw ParsingException("Wrong type for logElem") }
logList.add(logElem)
} else { throw ParsingException("Wrong element type for log") }
}
log = logList
} else { throw ParsingException("Wrong type for log") }
}
"newStatus" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
newStatus = parseJson<dk.sdu.cloud.app.orchestrator.api.JobStatus?>(parser)
} else { throw ParsingException("Wrong type for newStatus") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsFollowResponse(
updates = updates ?: throw ParsingException("Missing key 'updates'"),
log = log ?: throw ParsingException("Missing key 'log'"),
newStatus = newStatus,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsLog_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsLog {
var rank: Int? = null
var stdout: String? = null
var stderr: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"rank" -> {
if (prop.element is JsonStreamElement.Number) {
rank = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rank") }
}
"stdout" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
stdout = prop.element.value
} else { throw ParsingException("Wrong type for stdout") }
}
"stderr" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
stderr = prop.element.value
} else { throw ParsingException("Wrong type for stderr") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsLog(
rank = rank ?: throw ParsingException("Missing key 'rank'"),
stdout = stdout,
stderr = stderr,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsExtendRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsExtendRequestItem {
var jobId: String? = null
var requestedTime: dk.sdu.cloud.app.store.api.SimpleDuration? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
"requestedTime" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
requestedTime = parseJson<dk.sdu.cloud.app.store.api.SimpleDuration>(parser)
} else { throw ParsingException("Wrong type for requestedTime") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsExtendRequestItem(
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
requestedTime = requestedTime ?: throw ParsingException("Missing key 'requestedTime'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsOpenInteractiveSessionRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsOpenInteractiveSessionRequestItem {
var id: String? = null
var rank: Int? = null
var sessionType: dk.sdu.cloud.app.orchestrator.api.InteractiveSessionType? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"rank" -> {
if (prop.element is JsonStreamElement.Number) {
rank = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rank") }
}
"sessionType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
sessionType = parseJson<dk.sdu.cloud.app.orchestrator.api.InteractiveSessionType>(parser)
} else { throw ParsingException("Wrong type for sessionType") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsOpenInteractiveSessionRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
rank = rank ?: throw ParsingException("Missing key 'rank'"),
sessionType = sessionType ?: throw ParsingException("Missing key 'sessionType'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_OpenSessionWithProvider_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.OpenSessionWithProvider {
var providerDomain: String? = null
var providerId: String? = null
var session: dk.sdu.cloud.app.orchestrator.api.OpenSession? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"providerDomain" -> {
if (prop.element is JsonStreamElement.Text) {
providerDomain = prop.element.value
} else { throw ParsingException("Wrong type for providerDomain") }
}
"providerId" -> {
if (prop.element is JsonStreamElement.Text) {
providerId = prop.element.value
} else { throw ParsingException("Wrong type for providerId") }
}
"session" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
session = parseJson<dk.sdu.cloud.app.orchestrator.api.OpenSession>(parser)
} else { throw ParsingException("Wrong type for session") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.OpenSessionWithProvider(
providerDomain = providerDomain ?: throw ParsingException("Missing key 'providerDomain'"),
providerId = providerId ?: throw ParsingException("Missing key 'providerId'"),
session = session ?: throw ParsingException("Missing key 'session'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_OpenSession_Shell_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.OpenSession.Shell {
var jobId: String? = null
var rank: Int? = null
var sessionIdentifier: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
"rank" -> {
if (prop.element is JsonStreamElement.Number) {
rank = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rank") }
}
"sessionIdentifier" -> {
if (prop.element is JsonStreamElement.Text) {
sessionIdentifier = prop.element.value
} else { throw ParsingException("Wrong type for sessionIdentifier") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.OpenSession.Shell(
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
rank = rank ?: throw ParsingException("Missing key 'rank'"),
sessionIdentifier = sessionIdentifier ?: throw ParsingException("Missing key 'sessionIdentifier'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_OpenSession_Web_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.OpenSession.Web {
var jobId: String? = null
var rank: Int? = null
var redirectClientTo: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
"rank" -> {
if (prop.element is JsonStreamElement.Number) {
rank = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rank") }
}
"redirectClientTo" -> {
if (prop.element is JsonStreamElement.Text) {
redirectClientTo = prop.element.value
} else { throw ParsingException("Wrong type for redirectClientTo") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.OpenSession.Web(
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
rank = rank ?: throw ParsingException("Missing key 'rank'"),
redirectClientTo = redirectClientTo ?: throw ParsingException("Missing key 'redirectClientTo'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_OpenSession_Vnc_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.OpenSession.Vnc {
var jobId: String? = null
var rank: Int? = null
var url: String? = null
var password: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
"rank" -> {
if (prop.element is JsonStreamElement.Number) {
rank = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rank") }
}
"url" -> {
if (prop.element is JsonStreamElement.Text) {
url = prop.element.value
} else { throw ParsingException("Wrong type for url") }
}
"password" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
password = prop.element.value
} else { throw ParsingException("Wrong type for password") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.OpenSession.Vnc(
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
rank = rank ?: throw ParsingException("Missing key 'rank'"),
url = url ?: throw ParsingException("Missing key 'url'"),
password = password,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIPSpecification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var firewall: dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"firewall" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
firewall = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall?>(parser)
} else { throw ParsingException("Wrong type for firewall") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification(
product = product ?: throw ParsingException("Missing key 'product'"),
firewall = firewall,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIPSpecification_Firewall_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall {
var openPorts: List<dk.sdu.cloud.app.orchestrator.api.PortRangeAndProto>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"openPorts" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val openPortsList = ArrayList<dk.sdu.cloud.app.orchestrator.api.PortRangeAndProto>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val openPortsElem: dk.sdu.cloud.app.orchestrator.api.PortRangeAndProto
if (prop.element is JsonStreamElement.ObjectStart) {
openPortsElem = parseJson<dk.sdu.cloud.app.orchestrator.api.PortRangeAndProto>(parser)
} else { throw ParsingException("Wrong type for openPortsElem") }
openPortsList.add(openPortsElem)
} else { throw ParsingException("Wrong element type for openPorts") }
}
openPorts = openPortsList
} else { throw ParsingException("Wrong type for openPorts") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall(
openPorts = openPorts ?: throw ParsingException("Missing key 'openPorts'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_PortRangeAndProto_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.PortRangeAndProto {
var start: Int? = null
var end: Int? = null
var protocol: dk.sdu.cloud.app.orchestrator.api.IPProtocol? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"start" -> {
if (prop.element is JsonStreamElement.Number) {
start = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for start") }
}
"end" -> {
if (prop.element is JsonStreamElement.Number) {
end = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for end") }
}
"protocol" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
protocol = parseJson<dk.sdu.cloud.app.orchestrator.api.IPProtocol>(parser)
} else { throw ParsingException("Wrong type for protocol") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.PortRangeAndProto(
start = start ?: throw ParsingException("Missing key 'start'"),
end = end ?: throw ParsingException("Missing key 'end'"),
protocol = protocol ?: throw ParsingException("Missing key 'protocol'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIPUpdate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIPUpdate {
var timestamp: Long? = null
var state: dk.sdu.cloud.app.orchestrator.api.NetworkIPState? = null
var status: String? = null
var changeIpAddress: Boolean? = null
var newIpAddress: String? = null
var binding: dk.sdu.cloud.app.orchestrator.api.JobBinding? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"state" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPState?>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
"changeIpAddress" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
changeIpAddress = prop.element.value
} else { throw ParsingException("Wrong type for changeIpAddress") }
}
"newIpAddress" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
newIpAddress = prop.element.value
} else { throw ParsingException("Wrong type for newIpAddress") }
}
"binding" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
binding = parseJson<dk.sdu.cloud.app.orchestrator.api.JobBinding?>(parser)
} else { throw ParsingException("Wrong type for binding") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIPUpdate(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
state = state,
status = status,
changeIpAddress = changeIpAddress,
newIpAddress = newIpAddress,
binding = binding,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobBinding_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobBinding {
var kind: dk.sdu.cloud.app.orchestrator.api.JobBindKind? = null
var job: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"kind" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
kind = parseJson<dk.sdu.cloud.app.orchestrator.api.JobBindKind>(parser)
} else { throw ParsingException("Wrong type for kind") }
}
"job" -> {
if (prop.element is JsonStreamElement.Text) {
job = prop.element.value
} else { throw ParsingException("Wrong type for job") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobBinding(
kind = kind ?: throw ParsingException("Missing key 'kind'"),
job = job ?: throw ParsingException("Missing key 'job'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIPSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
var firewall: dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport.Firewall? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
"firewall" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
firewall = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport.Firewall>(parser)
} else { throw ParsingException("Wrong type for firewall") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
firewall = firewall ?: throw ParsingException("Missing key 'firewall'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIPSupport_Firewall_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport.Firewall {
var enabled: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"enabled" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
enabled = prop.element.value
} else { throw ParsingException("Wrong type for enabled") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport.Firewall(
enabled = enabled,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIP_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIP {
var id: String? = null
var specification: dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.app.orchestrator.api.NetworkIPStatus? = null
var updates: List<dk.sdu.cloud.app.orchestrator.api.NetworkIPUpdate>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.NetworkIP? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.app.orchestrator.api.NetworkIPUpdate>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.app.orchestrator.api.NetworkIPUpdate
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPUpdate>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.NetworkIP?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIP(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
resolvedProduct = resolvedProduct,
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIPStatus_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIPStatus {
var state: dk.sdu.cloud.app.orchestrator.api.NetworkIPState? = null
var boundTo: List<String>? = null
var ipAddress: String? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.NetworkIP, dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.NetworkIP? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"state" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPState>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"boundTo" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val boundToList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val boundToElem: String
if (prop.element is JsonStreamElement.Text) {
boundToElem = prop.element.value
} else { throw ParsingException("Wrong type for boundToElem") }
boundToList.add(boundToElem)
} else { throw ParsingException("Wrong element type for boundTo") }
}
boundTo = boundToList
} else { throw ParsingException("Wrong type for boundTo") }
}
"ipAddress" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
ipAddress = prop.element.value
} else { throw ParsingException("Wrong type for ipAddress") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.NetworkIP, dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.NetworkIP?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIPStatus(
state = state ?: throw ParsingException("Missing key 'state'"),
boundTo = boundTo ?: throw ParsingException("Missing key 'boundTo'"),
ipAddress = ipAddress,
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_NetworkIPFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.NetworkIPFlags {
var filterState: dk.sdu.cloud.app.orchestrator.api.NetworkIPState? = null
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filterState" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterState = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPState?>(parser)
} else { throw ParsingException("Wrong type for filterState") }
}
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.NetworkIPFlags(
filterState = filterState,
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_FirewallAndId_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.FirewallAndId {
var id: String? = null
var firewall: dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"firewall" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
firewall = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall>(parser)
} else { throw ParsingException("Wrong type for firewall") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.FirewallAndId(
id = id ?: throw ParsingException("Missing key 'id'"),
firewall = firewall ?: throw ParsingException("Missing key 'firewall'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_IngressSpecification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.IngressSpecification {
var domain: String? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"domain" -> {
if (prop.element is JsonStreamElement.Text) {
domain = prop.element.value
} else { throw ParsingException("Wrong type for domain") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.IngressSpecification(
domain = domain ?: throw ParsingException("Missing key 'domain'"),
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_IngressUpdate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.IngressUpdate {
var state: dk.sdu.cloud.app.orchestrator.api.IngressState? = null
var status: String? = null
var timestamp: Long? = null
var binding: dk.sdu.cloud.app.orchestrator.api.JobBinding? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"state" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.IngressState?>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"binding" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
binding = parseJson<dk.sdu.cloud.app.orchestrator.api.JobBinding?>(parser)
} else { throw ParsingException("Wrong type for binding") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.IngressUpdate(
state = state,
status = status,
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
binding = binding,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_IngressSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.IngressSupport {
var domainPrefix: String? = null
var domainSuffix: String? = null
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"domainPrefix" -> {
if (prop.element is JsonStreamElement.Text) {
domainPrefix = prop.element.value
} else { throw ParsingException("Wrong type for domainPrefix") }
}
"domainSuffix" -> {
if (prop.element is JsonStreamElement.Text) {
domainSuffix = prop.element.value
} else { throw ParsingException("Wrong type for domainSuffix") }
}
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.IngressSupport(
domainPrefix = domainPrefix ?: throw ParsingException("Missing key 'domainPrefix'"),
domainSuffix = domainSuffix ?: throw ParsingException("Missing key 'domainSuffix'"),
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_Ingress_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.Ingress {
var id: String? = null
var specification: dk.sdu.cloud.app.orchestrator.api.IngressSpecification? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.app.orchestrator.api.IngressStatus? = null
var updates: List<dk.sdu.cloud.app.orchestrator.api.IngressUpdate>? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.app.orchestrator.api.IngressSpecification>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.app.orchestrator.api.IngressStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.app.orchestrator.api.IngressUpdate>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.app.orchestrator.api.IngressUpdate
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.app.orchestrator.api.IngressUpdate>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.Ingress(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_IngressStatus_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.IngressStatus {
var boundTo: List<String>? = null
var state: dk.sdu.cloud.app.orchestrator.api.IngressState? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Ingress, dk.sdu.cloud.app.orchestrator.api.IngressSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.Ingress? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"boundTo" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val boundToList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val boundToElem: String
if (prop.element is JsonStreamElement.Text) {
boundToElem = prop.element.value
} else { throw ParsingException("Wrong type for boundToElem") }
boundToList.add(boundToElem)
} else { throw ParsingException("Wrong element type for boundTo") }
}
boundTo = boundToList
} else { throw ParsingException("Wrong type for boundTo") }
}
"state" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.IngressState>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.Ingress, dk.sdu.cloud.app.orchestrator.api.IngressSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.Ingress?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.IngressStatus(
boundTo = boundTo ?: throw ParsingException("Missing key 'boundTo'"),
state = state ?: throw ParsingException("Missing key 'state'"),
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_IngressIncludeFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.IngressIncludeFlags {
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var filterState: dk.sdu.cloud.app.orchestrator.api.IngressState? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"filterState" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
filterState = parseJson<dk.sdu.cloud.app.orchestrator.api.IngressState?>(parser)
} else { throw ParsingException("Wrong type for filterState") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.IngressIncludeFlags(
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
filterState = filterState,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_LicenseSpecification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.LicenseSpecification {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.LicenseSpecification(
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_LicenseUpdate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.LicenseUpdate {
var timestamp: Long? = null
var state: dk.sdu.cloud.app.orchestrator.api.LicenseState? = null
var status: String? = null
var binding: dk.sdu.cloud.app.orchestrator.api.JobBinding? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"timestamp" -> {
if (prop.element is JsonStreamElement.Number) {
timestamp = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for timestamp") }
}
"state" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.LicenseState?>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
"binding" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
binding = parseJson<dk.sdu.cloud.app.orchestrator.api.JobBinding?>(parser)
} else { throw ParsingException("Wrong type for binding") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.LicenseUpdate(
timestamp = timestamp ?: throw ParsingException("Missing key 'timestamp'"),
state = state,
status = status,
binding = binding,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_LicenseSupport_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.LicenseSupport {
var product: dk.sdu.cloud.accounting.api.ProductReference? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"product" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
product = parseJson<dk.sdu.cloud.accounting.api.ProductReference>(parser)
} else { throw ParsingException("Wrong type for product") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.LicenseSupport(
product = product ?: throw ParsingException("Missing key 'product'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_License_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.License {
var id: String? = null
var specification: dk.sdu.cloud.app.orchestrator.api.LicenseSpecification? = null
var owner: dk.sdu.cloud.provider.api.ResourceOwner? = null
var createdAt: Long? = null
var status: dk.sdu.cloud.app.orchestrator.api.LicenseStatus? = null
var updates: List<dk.sdu.cloud.app.orchestrator.api.LicenseUpdate>? = null
var permissions: dk.sdu.cloud.provider.api.ResourcePermissions? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"specification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
specification = parseJson<dk.sdu.cloud.app.orchestrator.api.LicenseSpecification>(parser)
} else { throw ParsingException("Wrong type for specification") }
}
"owner" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
owner = parseJson<dk.sdu.cloud.provider.api.ResourceOwner>(parser)
} else { throw ParsingException("Wrong type for owner") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
"status" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
status = parseJson<dk.sdu.cloud.app.orchestrator.api.LicenseStatus>(parser)
} else { throw ParsingException("Wrong type for status") }
}
"updates" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val updatesList = ArrayList<dk.sdu.cloud.app.orchestrator.api.LicenseUpdate>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val updatesElem: dk.sdu.cloud.app.orchestrator.api.LicenseUpdate
if (prop.element is JsonStreamElement.ObjectStart) {
updatesElem = parseJson<dk.sdu.cloud.app.orchestrator.api.LicenseUpdate>(parser)
} else { throw ParsingException("Wrong type for updatesElem") }
updatesList.add(updatesElem)
} else { throw ParsingException("Wrong element type for updates") }
}
updates = updatesList
} else { throw ParsingException("Wrong type for updates") }
}
"permissions" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
permissions = parseJson<dk.sdu.cloud.provider.api.ResourcePermissions?>(parser)
} else { throw ParsingException("Wrong type for permissions") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.License(
id = id ?: throw ParsingException("Missing key 'id'"),
specification = specification ?: throw ParsingException("Missing key 'specification'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
status = status ?: throw ParsingException("Missing key 'status'"),
updates = updates ?: throw ParsingException("Missing key 'updates'"),
permissions = permissions,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_LicenseStatus_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.LicenseStatus {
var state: dk.sdu.cloud.app.orchestrator.api.LicenseState? = null
var resolvedSupport: dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.License, dk.sdu.cloud.app.orchestrator.api.LicenseSupport>? = null
var resolvedProduct: dk.sdu.cloud.accounting.api.Product.License? = null
var boundTo: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"state" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
state = parseJson<dk.sdu.cloud.app.orchestrator.api.LicenseState>(parser)
} else { throw ParsingException("Wrong type for state") }
}
"resolvedSupport" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedSupport = parseJson<dk.sdu.cloud.accounting.api.providers.ResolvedSupport<dk.sdu.cloud.accounting.api.Product.License, dk.sdu.cloud.app.orchestrator.api.LicenseSupport>?>(parser)
} else { throw ParsingException("Wrong type for resolvedSupport") }
}
"resolvedProduct" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
resolvedProduct = parseJson<dk.sdu.cloud.accounting.api.Product.License?>(parser)
} else { throw ParsingException("Wrong type for resolvedProduct") }
}
"boundTo" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val boundToList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val boundToElem: String
if (prop.element is JsonStreamElement.Text) {
boundToElem = prop.element.value
} else { throw ParsingException("Wrong type for boundToElem") }
boundToList.add(boundToElem)
} else { throw ParsingException("Wrong element type for boundTo") }
}
boundTo = boundToList
} else { throw ParsingException("Wrong type for boundTo") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.LicenseStatus(
state = state ?: throw ParsingException("Missing key 'state'"),
resolvedSupport = resolvedSupport,
resolvedProduct = resolvedProduct,
boundTo = boundTo ?: throw ParsingException("Missing key 'boundTo'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_LicenseIncludeFlags_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.LicenseIncludeFlags {
var includeOthers: Boolean? = null
var includeUpdates: Boolean? = null
var includeSupport: Boolean? = null
var includeProduct: Boolean? = null
var filterCreatedBy: String? = null
var filterCreatedAfter: Long? = null
var filterCreatedBefore: Long? = null
var filterProvider: String? = null
var filterProductId: String? = null
var filterProductCategory: String? = null
var filterProviderIds: String? = null
var filterIds: String? = null
var hideProductId: String? = null
var hideProductCategory: String? = null
var hideProvider: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"includeOthers" -> {
if (prop.element is JsonStreamElement.Bool) {
includeOthers = prop.element.value
} else { throw ParsingException("Wrong type for includeOthers") }
}
"includeUpdates" -> {
if (prop.element is JsonStreamElement.Bool) {
includeUpdates = prop.element.value
} else { throw ParsingException("Wrong type for includeUpdates") }
}
"includeSupport" -> {
if (prop.element is JsonStreamElement.Bool) {
includeSupport = prop.element.value
} else { throw ParsingException("Wrong type for includeSupport") }
}
"includeProduct" -> {
if (prop.element is JsonStreamElement.Bool) {
includeProduct = prop.element.value
} else { throw ParsingException("Wrong type for includeProduct") }
}
"filterCreatedBy" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterCreatedBy = prop.element.value
} else { throw ParsingException("Wrong type for filterCreatedBy") }
}
"filterCreatedAfter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedAfter = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedAfter") }
}
"filterCreatedBefore" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
filterCreatedBefore = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for filterCreatedBefore") }
}
"filterProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProvider = prop.element.value
} else { throw ParsingException("Wrong type for filterProvider") }
}
"filterProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductId = prop.element.value
} else { throw ParsingException("Wrong type for filterProductId") }
}
"filterProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for filterProductCategory") }
}
"filterProviderIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterProviderIds = prop.element.value
} else { throw ParsingException("Wrong type for filterProviderIds") }
}
"filterIds" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filterIds = prop.element.value
} else { throw ParsingException("Wrong type for filterIds") }
}
"hideProductId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductId = prop.element.value
} else { throw ParsingException("Wrong type for hideProductId") }
}
"hideProductCategory" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProductCategory = prop.element.value
} else { throw ParsingException("Wrong type for hideProductCategory") }
}
"hideProvider" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
hideProvider = prop.element.value
} else { throw ParsingException("Wrong type for hideProvider") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.LicenseIncludeFlags(
includeOthers = includeOthers ?: throw ParsingException("Missing key 'includeOthers'"),
includeUpdates = includeUpdates ?: throw ParsingException("Missing key 'includeUpdates'"),
includeSupport = includeSupport ?: throw ParsingException("Missing key 'includeSupport'"),
includeProduct = includeProduct ?: throw ParsingException("Missing key 'includeProduct'"),
filterCreatedBy = filterCreatedBy,
filterCreatedAfter = filterCreatedAfter,
filterCreatedBefore = filterCreatedBefore,
filterProvider = filterProvider,
filterProductId = filterProductId,
filterProductCategory = filterProductCategory,
filterProviderIds = filterProviderIds,
filterIds = filterIds,
hideProductId = hideProductId,
hideProductCategory = hideProductCategory,
hideProvider = hideProvider,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsProviderExtendRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsProviderExtendRequestItem {
var job: dk.sdu.cloud.app.orchestrator.api.Job? = null
var requestedTime: dk.sdu.cloud.app.store.api.SimpleDuration? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"job" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
job = parseJson<dk.sdu.cloud.app.orchestrator.api.Job>(parser)
} else { throw ParsingException("Wrong type for job") }
}
"requestedTime" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
requestedTime = parseJson<dk.sdu.cloud.app.store.api.SimpleDuration>(parser)
} else { throw ParsingException("Wrong type for requestedTime") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsProviderExtendRequestItem(
job = job ?: throw ParsingException("Missing key 'job'"),
requestedTime = requestedTime ?: throw ParsingException("Missing key 'requestedTime'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsProviderFollowRequest_Init_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowRequest.Init {
var job: dk.sdu.cloud.app.orchestrator.api.Job? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"job" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
job = parseJson<dk.sdu.cloud.app.orchestrator.api.Job>(parser)
} else { throw ParsingException("Wrong type for job") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowRequest.Init(
job = job ?: throw ParsingException("Missing key 'job'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsProviderFollowRequest_CancelStream_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowRequest.CancelStream {
var streamId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"streamId" -> {
if (prop.element is JsonStreamElement.Text) {
streamId = prop.element.value
} else { throw ParsingException("Wrong type for streamId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowRequest.CancelStream(
streamId = streamId ?: throw ParsingException("Missing key 'streamId'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsProviderFollowResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowResponse {
var streamId: String? = null
var rank: Int? = null
var stdout: String? = null
var stderr: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"streamId" -> {
if (prop.element is JsonStreamElement.Text) {
streamId = prop.element.value
} else { throw ParsingException("Wrong type for streamId") }
}
"rank" -> {
if (prop.element is JsonStreamElement.Number) {
rank = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rank") }
}
"stdout" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
stdout = prop.element.value
} else { throw ParsingException("Wrong type for stdout") }
}
"stderr" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
stderr = prop.element.value
} else { throw ParsingException("Wrong type for stderr") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowResponse(
streamId = streamId ?: throw ParsingException("Missing key 'streamId'"),
rank = rank ?: throw ParsingException("Missing key 'rank'"),
stdout = stdout,
stderr = stderr,
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_JobsProviderOpenInteractiveSessionRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.JobsProviderOpenInteractiveSessionRequestItem {
var job: dk.sdu.cloud.app.orchestrator.api.Job? = null
var rank: Int? = null
var sessionType: dk.sdu.cloud.app.orchestrator.api.InteractiveSessionType? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"job" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
job = parseJson<dk.sdu.cloud.app.orchestrator.api.Job>(parser)
} else { throw ParsingException("Wrong type for job") }
}
"rank" -> {
if (prop.element is JsonStreamElement.Number) {
rank = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rank") }
}
"sessionType" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
sessionType = parseJson<dk.sdu.cloud.app.orchestrator.api.InteractiveSessionType>(parser)
} else { throw ParsingException("Wrong type for sessionType") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.JobsProviderOpenInteractiveSessionRequestItem(
job = job ?: throw ParsingException("Missing key 'job'"),
rank = rank ?: throw ParsingException("Missing key 'rank'"),
sessionType = sessionType ?: throw ParsingException("Missing key 'sessionType'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ShellRequest_Initialize_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ShellRequest.Initialize {
var sessionIdentifier: String? = null
var cols: Int? = null
var rows: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sessionIdentifier" -> {
if (prop.element is JsonStreamElement.Text) {
sessionIdentifier = prop.element.value
} else { throw ParsingException("Wrong type for sessionIdentifier") }
}
"cols" -> {
if (prop.element is JsonStreamElement.Number) {
cols = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for cols") }
}
"rows" -> {
if (prop.element is JsonStreamElement.Number) {
rows = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rows") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ShellRequest.Initialize(
sessionIdentifier = sessionIdentifier ?: throw ParsingException("Missing key 'sessionIdentifier'"),
cols = cols ?: throw ParsingException("Missing key 'cols'"),
rows = rows ?: throw ParsingException("Missing key 'rows'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ShellRequest_Input_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ShellRequest.Input {
var data: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"data" -> {
if (prop.element is JsonStreamElement.Text) {
data = prop.element.value
} else { throw ParsingException("Wrong type for data") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ShellRequest.Input(
data = data ?: throw ParsingException("Missing key 'data'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ShellRequest_Resize_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ShellRequest.Resize {
var cols: Int? = null
var rows: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"cols" -> {
if (prop.element is JsonStreamElement.Number) {
cols = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for cols") }
}
"rows" -> {
if (prop.element is JsonStreamElement.Number) {
rows = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for rows") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ShellRequest.Resize(
cols = cols ?: throw ParsingException("Missing key 'cols'"),
rows = rows ?: throw ParsingException("Missing key 'rows'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ShellResponse_Initialized_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ShellResponse.Initialized {
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ShellResponse.Initialized(
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ShellResponse_Data_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ShellResponse.Data {
var data: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"data" -> {
if (prop.element is JsonStreamElement.Text) {
data = prop.element.value
} else { throw ParsingException("Wrong type for data") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ShellResponse.Data(
data = data ?: throw ParsingException("Missing key 'data'"),
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_ShellResponse_Acknowledged_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.ShellResponse.Acknowledged {
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.ShellResponse.Acknowledged(
)
}
inline fun `dk_sdu_cloud_app_orchestrator_api_FirewallAndIP_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.app.orchestrator.api.FirewallAndIP {
var networkIp: dk.sdu.cloud.app.orchestrator.api.NetworkIP? = null
var firewall: dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"networkIp" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
networkIp = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIP>(parser)
} else { throw ParsingException("Wrong type for networkIp") }
}
"firewall" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
firewall = parseJson<dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall>(parser)
} else { throw ParsingException("Wrong type for firewall") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.app.orchestrator.api.FirewallAndIP(
networkIp = networkIp ?: throw ParsingException("Missing key 'networkIp'"),
firewall = firewall ?: throw ParsingException("Missing key 'firewall'"),
)
}
inline fun `dk_sdu_cloud_auth_api_CreateSingleUserRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.CreateSingleUserRequest {
var username: String? = null
var password: String? = null
var email: String? = null
var role: dk.sdu.cloud.Role? = null
var firstnames: String? = null
var lastname: String? = null
var orgId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
"password" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
password = prop.element.value
} else { throw ParsingException("Wrong type for password") }
}
"email" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
"role" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.Role?>(parser)
} else { throw ParsingException("Wrong type for role") }
}
"firstnames" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
firstnames = prop.element.value
} else { throw ParsingException("Wrong type for firstnames") }
}
"lastname" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
lastname = prop.element.value
} else { throw ParsingException("Wrong type for lastname") }
}
"orgId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
orgId = prop.element.value
} else { throw ParsingException("Wrong type for orgId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.CreateSingleUserRequest(
username = username ?: throw ParsingException("Missing key 'username'"),
password = password,
email = email,
role = role,
firstnames = firstnames,
lastname = lastname,
orgId = orgId,
)
}
inline fun `dk_sdu_cloud_auth_api_AuthenticationTokens_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AuthenticationTokens {
var accessToken: String? = null
var refreshToken: String? = null
var csrfToken: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"accessToken" -> {
if (prop.element is JsonStreamElement.Text) {
accessToken = prop.element.value
} else { throw ParsingException("Wrong type for accessToken") }
}
"refreshToken" -> {
if (prop.element is JsonStreamElement.Text) {
refreshToken = prop.element.value
} else { throw ParsingException("Wrong type for refreshToken") }
}
"csrfToken" -> {
if (prop.element is JsonStreamElement.Text) {
csrfToken = prop.element.value
} else { throw ParsingException("Wrong type for csrfToken") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AuthenticationTokens(
accessToken = accessToken ?: throw ParsingException("Missing key 'accessToken'"),
refreshToken = refreshToken ?: throw ParsingException("Missing key 'refreshToken'"),
csrfToken = csrfToken ?: throw ParsingException("Missing key 'csrfToken'"),
)
}
inline fun `dk_sdu_cloud_auth_api_UpdateUserInfoRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.UpdateUserInfoRequest {
var email: String? = null
var firstNames: String? = null
var lastName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"email" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
"firstNames" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
firstNames = prop.element.value
} else { throw ParsingException("Wrong type for firstNames") }
}
"lastName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
lastName = prop.element.value
} else { throw ParsingException("Wrong type for lastName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.UpdateUserInfoRequest(
email = email,
firstNames = firstNames,
lastName = lastName,
)
}
inline fun `dk_sdu_cloud_auth_api_GetUserInfoResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.GetUserInfoResponse {
var email: String? = null
var firstNames: String? = null
var lastName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"email" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
"firstNames" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
firstNames = prop.element.value
} else { throw ParsingException("Wrong type for firstNames") }
}
"lastName" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
lastName = prop.element.value
} else { throw ParsingException("Wrong type for lastName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.GetUserInfoResponse(
email = email,
firstNames = firstNames,
lastName = lastName,
)
}
inline fun `dk_sdu_cloud_auth_api_GetPrincipalRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.GetPrincipalRequest {
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.GetPrincipalRequest(
username = username ?: throw ParsingException("Missing key 'username'"),
)
}
inline fun `dk_sdu_cloud_auth_api_Person_ByWAYF_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.Person.ByWAYF {
var id: String? = null
var role: dk.sdu.cloud.Role? = null
var title: String? = null
var firstNames: String? = null
var lastName: String? = null
var phoneNumber: String? = null
var orcId: String? = null
var email: String? = null
var uid: Long? = null
var serviceLicenseAgreement: Int? = null
var organizationId: String? = null
var wayfId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"role" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.Role>(parser)
} else { throw ParsingException("Wrong type for role") }
}
"title" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"firstNames" -> {
if (prop.element is JsonStreamElement.Text) {
firstNames = prop.element.value
} else { throw ParsingException("Wrong type for firstNames") }
}
"lastName" -> {
if (prop.element is JsonStreamElement.Text) {
lastName = prop.element.value
} else { throw ParsingException("Wrong type for lastName") }
}
"phoneNumber" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
phoneNumber = prop.element.value
} else { throw ParsingException("Wrong type for phoneNumber") }
}
"orcId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
orcId = prop.element.value
} else { throw ParsingException("Wrong type for orcId") }
}
"email" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
"uid" -> {
if (prop.element is JsonStreamElement.Number) {
uid = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for uid") }
}
"serviceLicenseAgreement" -> {
if (prop.element is JsonStreamElement.Number) {
serviceLicenseAgreement = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for serviceLicenseAgreement") }
}
"organizationId" -> {
if (prop.element is JsonStreamElement.Text) {
organizationId = prop.element.value
} else { throw ParsingException("Wrong type for organizationId") }
}
"wayfId" -> {
if (prop.element is JsonStreamElement.Text) {
wayfId = prop.element.value
} else { throw ParsingException("Wrong type for wayfId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.Person.ByWAYF(
id = id ?: throw ParsingException("Missing key 'id'"),
role = role ?: throw ParsingException("Missing key 'role'"),
title = title,
firstNames = firstNames ?: throw ParsingException("Missing key 'firstNames'"),
lastName = lastName ?: throw ParsingException("Missing key 'lastName'"),
phoneNumber = phoneNumber,
orcId = orcId,
email = email,
uid = uid ?: throw ParsingException("Missing key 'uid'"),
serviceLicenseAgreement = serviceLicenseAgreement ?: throw ParsingException("Missing key 'serviceLicenseAgreement'"),
organizationId = organizationId ?: throw ParsingException("Missing key 'organizationId'"),
wayfId = wayfId ?: throw ParsingException("Missing key 'wayfId'"),
)
}
inline fun `dk_sdu_cloud_auth_api_Person_ByPassword_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.Person.ByPassword {
var id: String? = null
var role: dk.sdu.cloud.Role? = null
var title: String? = null
var firstNames: String? = null
var lastName: String? = null
var phoneNumber: String? = null
var orcId: String? = null
var email: String? = null
var uid: Long? = null
var twoFactorAuthentication: Boolean? = null
var serviceLicenseAgreement: Int? = null
var organizationId: String? = null
var password: List<Byte>? = null
var salt: List<Byte>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"role" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.Role>(parser)
} else { throw ParsingException("Wrong type for role") }
}
"title" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"firstNames" -> {
if (prop.element is JsonStreamElement.Text) {
firstNames = prop.element.value
} else { throw ParsingException("Wrong type for firstNames") }
}
"lastName" -> {
if (prop.element is JsonStreamElement.Text) {
lastName = prop.element.value
} else { throw ParsingException("Wrong type for lastName") }
}
"phoneNumber" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
phoneNumber = prop.element.value
} else { throw ParsingException("Wrong type for phoneNumber") }
}
"orcId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
orcId = prop.element.value
} else { throw ParsingException("Wrong type for orcId") }
}
"email" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
"uid" -> {
if (prop.element is JsonStreamElement.Number) {
uid = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for uid") }
}
"twoFactorAuthentication" -> {
if (prop.element is JsonStreamElement.Bool) {
twoFactorAuthentication = prop.element.value
} else { throw ParsingException("Wrong type for twoFactorAuthentication") }
}
"serviceLicenseAgreement" -> {
if (prop.element is JsonStreamElement.Number) {
serviceLicenseAgreement = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for serviceLicenseAgreement") }
}
"organizationId" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
organizationId = prop.element.value
} else { throw ParsingException("Wrong type for organizationId") }
}
"password" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val passwordList = ArrayList<Byte>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val passwordElem: Byte
if (prop.element is JsonStreamElement.Number) {
passwordElem = prop.element.value.toInt().toByte()
} else { throw ParsingException("Wrong type for passwordElem") }
passwordList.add(passwordElem)
} else { throw ParsingException("Wrong element type for password") }
}
password = passwordList
} else { throw ParsingException("Wrong type for password") }
}
"salt" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val saltList = ArrayList<Byte>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val saltElem: Byte
if (prop.element is JsonStreamElement.Number) {
saltElem = prop.element.value.toInt().toByte()
} else { throw ParsingException("Wrong type for saltElem") }
saltList.add(saltElem)
} else { throw ParsingException("Wrong element type for salt") }
}
salt = saltList
} else { throw ParsingException("Wrong type for salt") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.Person.ByPassword(
id = id ?: throw ParsingException("Missing key 'id'"),
role = role ?: throw ParsingException("Missing key 'role'"),
title = title,
firstNames = firstNames ?: throw ParsingException("Missing key 'firstNames'"),
lastName = lastName ?: throw ParsingException("Missing key 'lastName'"),
phoneNumber = phoneNumber,
orcId = orcId,
email = email,
uid = uid ?: throw ParsingException("Missing key 'uid'"),
twoFactorAuthentication = twoFactorAuthentication ?: throw ParsingException("Missing key 'twoFactorAuthentication'"),
serviceLicenseAgreement = serviceLicenseAgreement ?: throw ParsingException("Missing key 'serviceLicenseAgreement'"),
organizationId = organizationId,
password = password ?: throw ParsingException("Missing key 'password'"),
salt = salt ?: throw ParsingException("Missing key 'salt'"),
)
}
inline fun `dk_sdu_cloud_auth_api_ServicePrincipal_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.ServicePrincipal {
var id: String? = null
var role: dk.sdu.cloud.Role? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
"role" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.Role>(parser)
} else { throw ParsingException("Wrong type for role") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.ServicePrincipal(
id = id ?: throw ParsingException("Missing key 'id'"),
role = role ?: throw ParsingException("Missing key 'role'"),
)
}
inline fun `dk_sdu_cloud_auth_api_ProviderPrincipal_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.ProviderPrincipal {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.ProviderPrincipal(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_auth_api_ChangePasswordRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.ChangePasswordRequest {
var currentPassword: String? = null
var newPassword: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"currentPassword" -> {
if (prop.element is JsonStreamElement.Text) {
currentPassword = prop.element.value
} else { throw ParsingException("Wrong type for currentPassword") }
}
"newPassword" -> {
if (prop.element is JsonStreamElement.Text) {
newPassword = prop.element.value
} else { throw ParsingException("Wrong type for newPassword") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.ChangePasswordRequest(
currentPassword = currentPassword ?: throw ParsingException("Missing key 'currentPassword'"),
newPassword = newPassword ?: throw ParsingException("Missing key 'newPassword'"),
)
}
inline fun `dk_sdu_cloud_auth_api_ChangePasswordWithResetRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.ChangePasswordWithResetRequest {
var userId: String? = null
var newPassword: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"userId" -> {
if (prop.element is JsonStreamElement.Text) {
userId = prop.element.value
} else { throw ParsingException("Wrong type for userId") }
}
"newPassword" -> {
if (prop.element is JsonStreamElement.Text) {
newPassword = prop.element.value
} else { throw ParsingException("Wrong type for newPassword") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.ChangePasswordWithResetRequest(
userId = userId ?: throw ParsingException("Missing key 'userId'"),
newPassword = newPassword ?: throw ParsingException("Missing key 'newPassword'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupUsersRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupUsersRequest {
var users: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"users" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val usersList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val usersElem: String
if (prop.element is JsonStreamElement.Text) {
usersElem = prop.element.value
} else { throw ParsingException("Wrong type for usersElem") }
usersList.add(usersElem)
} else { throw ParsingException("Wrong element type for users") }
}
users = usersList
} else { throw ParsingException("Wrong type for users") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupUsersRequest(
users = users ?: throw ParsingException("Missing key 'users'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupUsersResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupUsersResponse {
var results: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"results" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for results") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupUsersResponse(
results = results ?: throw ParsingException("Missing key 'results'"),
)
}
inline fun `dk_sdu_cloud_auth_api_UserLookup_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.UserLookup {
var subject: String? = null
var uid: Long? = null
var role: dk.sdu.cloud.Role? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
"uid" -> {
if (prop.element is JsonStreamElement.Number) {
uid = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for uid") }
}
"role" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.Role>(parser)
} else { throw ParsingException("Wrong type for role") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.UserLookup(
subject = subject ?: throw ParsingException("Missing key 'subject'"),
uid = uid ?: throw ParsingException("Missing key 'uid'"),
role = role ?: throw ParsingException("Missing key 'role'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupEmailRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupEmailRequest {
var userId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"userId" -> {
if (prop.element is JsonStreamElement.Text) {
userId = prop.element.value
} else { throw ParsingException("Wrong type for userId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupEmailRequest(
userId = userId ?: throw ParsingException("Missing key 'userId'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupEmailResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupEmailResponse {
var email: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"email" -> {
if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupEmailResponse(
email = email ?: throw ParsingException("Missing key 'email'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupUserWithEmailRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupUserWithEmailRequest {
var email: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"email" -> {
if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupUserWithEmailRequest(
email = email ?: throw ParsingException("Missing key 'email'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupUserWithEmailResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupUserWithEmailResponse {
var userId: String? = null
var firstNames: String? = null
var lastName: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"userId" -> {
if (prop.element is JsonStreamElement.Text) {
userId = prop.element.value
} else { throw ParsingException("Wrong type for userId") }
}
"firstNames" -> {
if (prop.element is JsonStreamElement.Text) {
firstNames = prop.element.value
} else { throw ParsingException("Wrong type for firstNames") }
}
"lastName" -> {
if (prop.element is JsonStreamElement.Text) {
lastName = prop.element.value
} else { throw ParsingException("Wrong type for lastName") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupUserWithEmailResponse(
userId = userId ?: throw ParsingException("Missing key 'userId'"),
firstNames = firstNames ?: throw ParsingException("Missing key 'firstNames'"),
lastName = lastName ?: throw ParsingException("Missing key 'lastName'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupUIDRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupUIDRequest {
var uids: List<Long>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"uids" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val uidsList = ArrayList<Long>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val uidsElem: Long
if (prop.element is JsonStreamElement.Number) {
uidsElem = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for uidsElem") }
uidsList.add(uidsElem)
} else { throw ParsingException("Wrong element type for uids") }
}
uids = uidsList
} else { throw ParsingException("Wrong type for uids") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupUIDRequest(
uids = uids ?: throw ParsingException("Missing key 'uids'"),
)
}
inline fun `dk_sdu_cloud_auth_api_LookupUIDResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.LookupUIDResponse {
var users: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"users" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for users") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.LookupUIDResponse(
users = users ?: throw ParsingException("Missing key 'users'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AccessToken_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AccessToken {
var accessToken: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"accessToken" -> {
if (prop.element is JsonStreamElement.Text) {
accessToken = prop.element.value
} else { throw ParsingException("Wrong type for accessToken") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AccessToken(
accessToken = accessToken ?: throw ParsingException("Missing key 'accessToken'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AccessTokenAndCsrf_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AccessTokenAndCsrf {
var accessToken: String? = null
var csrfToken: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"accessToken" -> {
if (prop.element is JsonStreamElement.Text) {
accessToken = prop.element.value
} else { throw ParsingException("Wrong type for accessToken") }
}
"csrfToken" -> {
if (prop.element is JsonStreamElement.Text) {
csrfToken = prop.element.value
} else { throw ParsingException("Wrong type for csrfToken") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AccessTokenAndCsrf(
accessToken = accessToken ?: throw ParsingException("Missing key 'accessToken'"),
csrfToken = csrfToken ?: throw ParsingException("Missing key 'csrfToken'"),
)
}
inline fun `dk_sdu_cloud_auth_api_BulkInvalidateRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.BulkInvalidateRequest {
var tokens: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"tokens" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val tokensList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val tokensElem: String
if (prop.element is JsonStreamElement.Text) {
tokensElem = prop.element.value
} else { throw ParsingException("Wrong type for tokensElem") }
tokensList.add(tokensElem)
} else { throw ParsingException("Wrong element type for tokens") }
}
tokens = tokensList
} else { throw ParsingException("Wrong type for tokens") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.BulkInvalidateRequest(
tokens = tokens ?: throw ParsingException("Missing key 'tokens'"),
)
}
inline fun `dk_sdu_cloud_auth_api_ClaimOneTimeToken_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.ClaimOneTimeToken {
var jti: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jti" -> {
if (prop.element is JsonStreamElement.Text) {
jti = prop.element.value
} else { throw ParsingException("Wrong type for jti") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.ClaimOneTimeToken(
jti = jti ?: throw ParsingException("Missing key 'jti'"),
)
}
inline fun `dk_sdu_cloud_auth_api_RequestOneTimeToken_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.RequestOneTimeToken {
var audience: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"audience" -> {
if (prop.element is JsonStreamElement.Text) {
audience = prop.element.value
} else { throw ParsingException("Wrong type for audience") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.RequestOneTimeToken(
audience = audience ?: throw ParsingException("Missing key 'audience'"),
)
}
inline fun `dk_sdu_cloud_auth_api_OneTimeAccessToken_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.OneTimeAccessToken {
var accessToken: String? = null
var jti: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"accessToken" -> {
if (prop.element is JsonStreamElement.Text) {
accessToken = prop.element.value
} else { throw ParsingException("Wrong type for accessToken") }
}
"jti" -> {
if (prop.element is JsonStreamElement.Text) {
jti = prop.element.value
} else { throw ParsingException("Wrong type for jti") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.OneTimeAccessToken(
accessToken = accessToken ?: throw ParsingException("Missing key 'accessToken'"),
jti = jti ?: throw ParsingException("Missing key 'jti'"),
)
}
inline fun `dk_sdu_cloud_auth_api_TokenExtensionRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.TokenExtensionRequest {
var validJWT: String? = null
var requestedScopes: List<String>? = null
var expiresIn: Long? = null
var allowRefreshes: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"validJWT" -> {
if (prop.element is JsonStreamElement.Text) {
validJWT = prop.element.value
} else { throw ParsingException("Wrong type for validJWT") }
}
"requestedScopes" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val requestedScopesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val requestedScopesElem: String
if (prop.element is JsonStreamElement.Text) {
requestedScopesElem = prop.element.value
} else { throw ParsingException("Wrong type for requestedScopesElem") }
requestedScopesList.add(requestedScopesElem)
} else { throw ParsingException("Wrong element type for requestedScopes") }
}
requestedScopes = requestedScopesList
} else { throw ParsingException("Wrong type for requestedScopes") }
}
"expiresIn" -> {
if (prop.element is JsonStreamElement.Number) {
expiresIn = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for expiresIn") }
}
"allowRefreshes" -> {
if (prop.element is JsonStreamElement.Bool) {
allowRefreshes = prop.element.value
} else { throw ParsingException("Wrong type for allowRefreshes") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.TokenExtensionRequest(
validJWT = validJWT ?: throw ParsingException("Missing key 'validJWT'"),
requestedScopes = requestedScopes ?: throw ParsingException("Missing key 'requestedScopes'"),
expiresIn = expiresIn ?: throw ParsingException("Missing key 'expiresIn'"),
allowRefreshes = allowRefreshes ?: throw ParsingException("Missing key 'allowRefreshes'"),
)
}
inline fun `dk_sdu_cloud_auth_api_OptionalAuthenticationTokens_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.OptionalAuthenticationTokens {
var accessToken: String? = null
var csrfToken: String? = null
var refreshToken: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"accessToken" -> {
if (prop.element is JsonStreamElement.Text) {
accessToken = prop.element.value
} else { throw ParsingException("Wrong type for accessToken") }
}
"csrfToken" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
csrfToken = prop.element.value
} else { throw ParsingException("Wrong type for csrfToken") }
}
"refreshToken" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
refreshToken = prop.element.value
} else { throw ParsingException("Wrong type for refreshToken") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.OptionalAuthenticationTokens(
accessToken = accessToken ?: throw ParsingException("Missing key 'accessToken'"),
csrfToken = csrfToken,
refreshToken = refreshToken,
)
}
inline fun `dk_sdu_cloud_auth_api_ListUserSessionsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.ListUserSessionsRequest {
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.ListUserSessionsRequest(
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_auth_api_Session_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.Session {
var ipAddress: String? = null
var userAgent: String? = null
var createdAt: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"ipAddress" -> {
if (prop.element is JsonStreamElement.Text) {
ipAddress = prop.element.value
} else { throw ParsingException("Wrong type for ipAddress") }
}
"userAgent" -> {
if (prop.element is JsonStreamElement.Text) {
userAgent = prop.element.value
} else { throw ParsingException("Wrong type for userAgent") }
}
"createdAt" -> {
if (prop.element is JsonStreamElement.Number) {
createdAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for createdAt") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.Session(
ipAddress = ipAddress ?: throw ParsingException("Missing key 'ipAddress'"),
userAgent = userAgent ?: throw ParsingException("Missing key 'userAgent'"),
createdAt = createdAt ?: throw ParsingException("Missing key 'createdAt'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AuthProvidersRegisterRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AuthProvidersRegisterRequestItem {
var id: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Text) {
id = prop.element.value
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AuthProvidersRegisterRequestItem(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AuthProvidersRegisterResponseItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AuthProvidersRegisterResponseItem {
var claimToken: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"claimToken" -> {
if (prop.element is JsonStreamElement.Text) {
claimToken = prop.element.value
} else { throw ParsingException("Wrong type for claimToken") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AuthProvidersRegisterResponseItem(
claimToken = claimToken ?: throw ParsingException("Missing key 'claimToken'"),
)
}
inline fun `dk_sdu_cloud_auth_api_PublicKeyAndRefreshToken_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.PublicKeyAndRefreshToken {
var providerId: String? = null
var publicKey: String? = null
var refreshToken: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"providerId" -> {
if (prop.element is JsonStreamElement.Text) {
providerId = prop.element.value
} else { throw ParsingException("Wrong type for providerId") }
}
"publicKey" -> {
if (prop.element is JsonStreamElement.Text) {
publicKey = prop.element.value
} else { throw ParsingException("Wrong type for publicKey") }
}
"refreshToken" -> {
if (prop.element is JsonStreamElement.Text) {
refreshToken = prop.element.value
} else { throw ParsingException("Wrong type for refreshToken") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.PublicKeyAndRefreshToken(
providerId = providerId ?: throw ParsingException("Missing key 'providerId'"),
publicKey = publicKey ?: throw ParsingException("Missing key 'publicKey'"),
refreshToken = refreshToken ?: throw ParsingException("Missing key 'refreshToken'"),
)
}
inline fun `dk_sdu_cloud_auth_api_RefreshToken_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.RefreshToken {
var refreshToken: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"refreshToken" -> {
if (prop.element is JsonStreamElement.Text) {
refreshToken = prop.element.value
} else { throw ParsingException("Wrong type for refreshToken") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.RefreshToken(
refreshToken = refreshToken ?: throw ParsingException("Missing key 'refreshToken'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AuthProvidersRetrievePublicKeyResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AuthProvidersRetrievePublicKeyResponse {
var publicKey: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"publicKey" -> {
if (prop.element is JsonStreamElement.Text) {
publicKey = prop.element.value
} else { throw ParsingException("Wrong type for publicKey") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AuthProvidersRetrievePublicKeyResponse(
publicKey = publicKey ?: throw ParsingException("Missing key 'publicKey'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AuthProvidersRefreshAsProviderRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AuthProvidersRefreshAsProviderRequestItem {
var providerId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"providerId" -> {
if (prop.element is JsonStreamElement.Text) {
providerId = prop.element.value
} else { throw ParsingException("Wrong type for providerId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AuthProvidersRefreshAsProviderRequestItem(
providerId = providerId ?: throw ParsingException("Missing key 'providerId'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AuthProvidersGenerateKeyPairResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AuthProvidersGenerateKeyPairResponse {
var publicKey: String? = null
var privateKey: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"publicKey" -> {
if (prop.element is JsonStreamElement.Text) {
publicKey = prop.element.value
} else { throw ParsingException("Wrong type for publicKey") }
}
"privateKey" -> {
if (prop.element is JsonStreamElement.Text) {
privateKey = prop.element.value
} else { throw ParsingException("Wrong type for privateKey") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AuthProvidersGenerateKeyPairResponse(
publicKey = publicKey ?: throw ParsingException("Missing key 'publicKey'"),
privateKey = privateKey ?: throw ParsingException("Missing key 'privateKey'"),
)
}
inline fun `dk_sdu_cloud_password_reset_api_PasswordResetRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.password.reset.api.PasswordResetRequest {
var email: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"email" -> {
if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.password.reset.api.PasswordResetRequest(
email = email ?: throw ParsingException("Missing key 'email'"),
)
}
inline fun `dk_sdu_cloud_password_reset_api_NewPasswordRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.password.reset.api.NewPasswordRequest {
var token: String? = null
var newPassword: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
"newPassword" -> {
if (prop.element is JsonStreamElement.Text) {
newPassword = prop.element.value
} else { throw ParsingException("Wrong type for newPassword") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.password.reset.api.NewPasswordRequest(
token = token ?: throw ParsingException("Missing key 'token'"),
newPassword = newPassword ?: throw ParsingException("Missing key 'newPassword'"),
)
}
inline fun `dk_sdu_cloud_auth_api_ServiceAgreementText_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.ServiceAgreementText {
var version: Int? = null
var text: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
"text" -> {
if (prop.element is JsonStreamElement.Text) {
text = prop.element.value
} else { throw ParsingException("Wrong type for text") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.ServiceAgreementText(
version = version ?: throw ParsingException("Missing key 'version'"),
text = text ?: throw ParsingException("Missing key 'text'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AcceptSLARequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AcceptSLARequest {
var version: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"version" -> {
if (prop.element is JsonStreamElement.Number) {
version = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for version") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AcceptSLARequest(
version = version ?: throw ParsingException("Missing key 'version'"),
)
}
inline fun `dk_sdu_cloud_auth_api_Create2FACredentialsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.Create2FACredentialsResponse {
var otpAuthUri: String? = null
var qrCodeB64Data: String? = null
var secret: String? = null
var challengeId: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"otpAuthUri" -> {
if (prop.element is JsonStreamElement.Text) {
otpAuthUri = prop.element.value
} else { throw ParsingException("Wrong type for otpAuthUri") }
}
"qrCodeB64Data" -> {
if (prop.element is JsonStreamElement.Text) {
qrCodeB64Data = prop.element.value
} else { throw ParsingException("Wrong type for qrCodeB64Data") }
}
"secret" -> {
if (prop.element is JsonStreamElement.Text) {
secret = prop.element.value
} else { throw ParsingException("Wrong type for secret") }
}
"challengeId" -> {
if (prop.element is JsonStreamElement.Text) {
challengeId = prop.element.value
} else { throw ParsingException("Wrong type for challengeId") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.Create2FACredentialsResponse(
otpAuthUri = otpAuthUri ?: throw ParsingException("Missing key 'otpAuthUri'"),
qrCodeB64Data = qrCodeB64Data ?: throw ParsingException("Missing key 'qrCodeB64Data'"),
secret = secret ?: throw ParsingException("Missing key 'secret'"),
challengeId = challengeId ?: throw ParsingException("Missing key 'challengeId'"),
)
}
inline fun `dk_sdu_cloud_auth_api_AnswerChallengeRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.AnswerChallengeRequest {
var challengeId: String? = null
var verificationCode: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"challengeId" -> {
if (prop.element is JsonStreamElement.Text) {
challengeId = prop.element.value
} else { throw ParsingException("Wrong type for challengeId") }
}
"verificationCode" -> {
if (prop.element is JsonStreamElement.Number) {
verificationCode = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for verificationCode") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.AnswerChallengeRequest(
challengeId = challengeId ?: throw ParsingException("Missing key 'challengeId'"),
verificationCode = verificationCode ?: throw ParsingException("Missing key 'verificationCode'"),
)
}
inline fun `dk_sdu_cloud_auth_api_TwoFactorStatusResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.auth.api.TwoFactorStatusResponse {
var connected: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"connected" -> {
if (prop.element is JsonStreamElement.Bool) {
connected = prop.element.value
} else { throw ParsingException("Wrong type for connected") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.auth.api.TwoFactorStatusResponse(
connected = connected ?: throw ParsingException("Missing key 'connected'"),
)
}
inline fun `dk_sdu_cloud_avatar_api_SerializedAvatar_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.avatar.api.SerializedAvatar {
var top: String? = null
var topAccessory: String? = null
var hairColor: String? = null
var facialHair: String? = null
var facialHairColor: String? = null
var clothes: String? = null
var colorFabric: String? = null
var eyes: String? = null
var eyebrows: String? = null
var mouthTypes: String? = null
var skinColors: String? = null
var clothesGraphic: String? = null
var hatColor: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"top" -> {
if (prop.element is JsonStreamElement.Text) {
top = prop.element.value
} else { throw ParsingException("Wrong type for top") }
}
"topAccessory" -> {
if (prop.element is JsonStreamElement.Text) {
topAccessory = prop.element.value
} else { throw ParsingException("Wrong type for topAccessory") }
}
"hairColor" -> {
if (prop.element is JsonStreamElement.Text) {
hairColor = prop.element.value
} else { throw ParsingException("Wrong type for hairColor") }
}
"facialHair" -> {
if (prop.element is JsonStreamElement.Text) {
facialHair = prop.element.value
} else { throw ParsingException("Wrong type for facialHair") }
}
"facialHairColor" -> {
if (prop.element is JsonStreamElement.Text) {
facialHairColor = prop.element.value
} else { throw ParsingException("Wrong type for facialHairColor") }
}
"clothes" -> {
if (prop.element is JsonStreamElement.Text) {
clothes = prop.element.value
} else { throw ParsingException("Wrong type for clothes") }
}
"colorFabric" -> {
if (prop.element is JsonStreamElement.Text) {
colorFabric = prop.element.value
} else { throw ParsingException("Wrong type for colorFabric") }
}
"eyes" -> {
if (prop.element is JsonStreamElement.Text) {
eyes = prop.element.value
} else { throw ParsingException("Wrong type for eyes") }
}
"eyebrows" -> {
if (prop.element is JsonStreamElement.Text) {
eyebrows = prop.element.value
} else { throw ParsingException("Wrong type for eyebrows") }
}
"mouthTypes" -> {
if (prop.element is JsonStreamElement.Text) {
mouthTypes = prop.element.value
} else { throw ParsingException("Wrong type for mouthTypes") }
}
"skinColors" -> {
if (prop.element is JsonStreamElement.Text) {
skinColors = prop.element.value
} else { throw ParsingException("Wrong type for skinColors") }
}
"clothesGraphic" -> {
if (prop.element is JsonStreamElement.Text) {
clothesGraphic = prop.element.value
} else { throw ParsingException("Wrong type for clothesGraphic") }
}
"hatColor" -> {
if (prop.element is JsonStreamElement.Text) {
hatColor = prop.element.value
} else { throw ParsingException("Wrong type for hatColor") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.avatar.api.SerializedAvatar(
top = top ?: throw ParsingException("Missing key 'top'"),
topAccessory = topAccessory ?: throw ParsingException("Missing key 'topAccessory'"),
hairColor = hairColor ?: throw ParsingException("Missing key 'hairColor'"),
facialHair = facialHair ?: throw ParsingException("Missing key 'facialHair'"),
facialHairColor = facialHairColor ?: throw ParsingException("Missing key 'facialHairColor'"),
clothes = clothes ?: throw ParsingException("Missing key 'clothes'"),
colorFabric = colorFabric ?: throw ParsingException("Missing key 'colorFabric'"),
eyes = eyes ?: throw ParsingException("Missing key 'eyes'"),
eyebrows = eyebrows ?: throw ParsingException("Missing key 'eyebrows'"),
mouthTypes = mouthTypes ?: throw ParsingException("Missing key 'mouthTypes'"),
skinColors = skinColors ?: throw ParsingException("Missing key 'skinColors'"),
clothesGraphic = clothesGraphic ?: throw ParsingException("Missing key 'clothesGraphic'"),
hatColor = hatColor ?: throw ParsingException("Missing key 'hatColor'"),
)
}
inline fun `dk_sdu_cloud_avatar_api_FindBulkRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.avatar.api.FindBulkRequest {
var usernames: List<String>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"usernames" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val usernamesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val usernamesElem: String
if (prop.element is JsonStreamElement.Text) {
usernamesElem = prop.element.value
} else { throw ParsingException("Wrong type for usernamesElem") }
usernamesList.add(usernamesElem)
} else { throw ParsingException("Wrong element type for usernames") }
}
usernames = usernamesList
} else { throw ParsingException("Wrong type for usernames") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.avatar.api.FindBulkRequest(
usernames = usernames ?: throw ParsingException("Missing key 'usernames'"),
)
}
inline fun `dk_sdu_cloud_avatar_api_FindBulkResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.avatar.api.FindBulkResponse {
var avatars: kotlinx.serialization.json.JsonObject? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"avatars" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for avatars") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.avatar.api.FindBulkResponse(
avatars = avatars ?: throw ParsingException("Missing key 'avatars'"),
)
}
inline fun `dk_sdu_cloud_news_api_NewPostRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.news.api.NewPostRequest {
var title: String? = null
var subtitle: String? = null
var body: String? = null
var showFrom: Long? = null
var category: String? = null
var hideFrom: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"subtitle" -> {
if (prop.element is JsonStreamElement.Text) {
subtitle = prop.element.value
} else { throw ParsingException("Wrong type for subtitle") }
}
"body" -> {
if (prop.element is JsonStreamElement.Text) {
body = prop.element.value
} else { throw ParsingException("Wrong type for body") }
}
"showFrom" -> {
if (prop.element is JsonStreamElement.Number) {
showFrom = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for showFrom") }
}
"category" -> {
if (prop.element is JsonStreamElement.Text) {
category = prop.element.value
} else { throw ParsingException("Wrong type for category") }
}
"hideFrom" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
hideFrom = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for hideFrom") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.news.api.NewPostRequest(
title = title ?: throw ParsingException("Missing key 'title'"),
subtitle = subtitle ?: throw ParsingException("Missing key 'subtitle'"),
body = body ?: throw ParsingException("Missing key 'body'"),
showFrom = showFrom ?: throw ParsingException("Missing key 'showFrom'"),
category = category ?: throw ParsingException("Missing key 'category'"),
hideFrom = hideFrom,
)
}
inline fun `dk_sdu_cloud_news_api_UpdatePostRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.news.api.UpdatePostRequest {
var id: Long? = null
var title: String? = null
var subtitle: String? = null
var body: String? = null
var showFrom: Long? = null
var hideFrom: Long? = null
var category: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"subtitle" -> {
if (prop.element is JsonStreamElement.Text) {
subtitle = prop.element.value
} else { throw ParsingException("Wrong type for subtitle") }
}
"body" -> {
if (prop.element is JsonStreamElement.Text) {
body = prop.element.value
} else { throw ParsingException("Wrong type for body") }
}
"showFrom" -> {
if (prop.element is JsonStreamElement.Number) {
showFrom = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for showFrom") }
}
"hideFrom" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
hideFrom = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for hideFrom") }
}
"category" -> {
if (prop.element is JsonStreamElement.Text) {
category = prop.element.value
} else { throw ParsingException("Wrong type for category") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.news.api.UpdatePostRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
title = title ?: throw ParsingException("Missing key 'title'"),
subtitle = subtitle ?: throw ParsingException("Missing key 'subtitle'"),
body = body ?: throw ParsingException("Missing key 'body'"),
showFrom = showFrom ?: throw ParsingException("Missing key 'showFrom'"),
hideFrom = hideFrom,
category = category ?: throw ParsingException("Missing key 'category'"),
)
}
inline fun `dk_sdu_cloud_news_api_DeleteNewsPostRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.news.api.DeleteNewsPostRequest {
var id: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.news.api.DeleteNewsPostRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_news_api_TogglePostHiddenRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.news.api.TogglePostHiddenRequest {
var id: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.news.api.TogglePostHiddenRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_news_api_ListPostsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.news.api.ListPostsRequest {
var filter: String? = null
var withHidden: Boolean? = null
var page: Int? = null
var itemsPerPage: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"filter" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
filter = prop.element.value
} else { throw ParsingException("Wrong type for filter") }
}
"withHidden" -> {
if (prop.element is JsonStreamElement.Bool) {
withHidden = prop.element.value
} else { throw ParsingException("Wrong type for withHidden") }
}
"page" -> {
if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.news.api.ListPostsRequest(
filter = filter,
withHidden = withHidden ?: throw ParsingException("Missing key 'withHidden'"),
page = page ?: throw ParsingException("Missing key 'page'"),
itemsPerPage = itemsPerPage ?: throw ParsingException("Missing key 'itemsPerPage'"),
)
}
inline fun `dk_sdu_cloud_news_api_NewsPost_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.news.api.NewsPost {
var id: Long? = null
var title: String? = null
var subtitle: String? = null
var body: String? = null
var postedBy: String? = null
var showFrom: Long? = null
var hideFrom: Long? = null
var hidden: Boolean? = null
var category: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"subtitle" -> {
if (prop.element is JsonStreamElement.Text) {
subtitle = prop.element.value
} else { throw ParsingException("Wrong type for subtitle") }
}
"body" -> {
if (prop.element is JsonStreamElement.Text) {
body = prop.element.value
} else { throw ParsingException("Wrong type for body") }
}
"postedBy" -> {
if (prop.element is JsonStreamElement.Text) {
postedBy = prop.element.value
} else { throw ParsingException("Wrong type for postedBy") }
}
"showFrom" -> {
if (prop.element is JsonStreamElement.Number) {
showFrom = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for showFrom") }
}
"hideFrom" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
hideFrom = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for hideFrom") }
}
"hidden" -> {
if (prop.element is JsonStreamElement.Bool) {
hidden = prop.element.value
} else { throw ParsingException("Wrong type for hidden") }
}
"category" -> {
if (prop.element is JsonStreamElement.Text) {
category = prop.element.value
} else { throw ParsingException("Wrong type for category") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.news.api.NewsPost(
id = id ?: throw ParsingException("Missing key 'id'"),
title = title ?: throw ParsingException("Missing key 'title'"),
subtitle = subtitle ?: throw ParsingException("Missing key 'subtitle'"),
body = body ?: throw ParsingException("Missing key 'body'"),
postedBy = postedBy ?: throw ParsingException("Missing key 'postedBy'"),
showFrom = showFrom ?: throw ParsingException("Missing key 'showFrom'"),
hideFrom = hideFrom,
hidden = hidden ?: throw ParsingException("Missing key 'hidden'"),
category = category ?: throw ParsingException("Missing key 'category'"),
)
}
inline fun `dk_sdu_cloud_news_api_GetPostByIdRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.news.api.GetPostByIdRequest {
var id: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"id" -> {
if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.news.api.GetPostByIdRequest(
id = id ?: throw ParsingException("Missing key 'id'"),
)
}
inline fun `dk_sdu_cloud_notification_api_ListNotificationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.notification.api.ListNotificationRequest {
var type: String? = null
var since: Long? = null
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"type" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
type = prop.element.value
} else { throw ParsingException("Wrong type for type") }
}
"since" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
since = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for since") }
}
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.notification.api.ListNotificationRequest(
type = type,
since = since,
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_notification_api_Notification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.notification.api.Notification {
var type: String? = null
var message: String? = null
var id: Long? = null
var meta: kotlinx.serialization.json.JsonObject? = null
var ts: Long? = null
var read: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"type" -> {
if (prop.element is JsonStreamElement.Text) {
type = prop.element.value
} else { throw ParsingException("Wrong type for type") }
}
"message" -> {
if (prop.element is JsonStreamElement.Text) {
message = prop.element.value
} else { throw ParsingException("Wrong type for message") }
}
"id" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
id = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for id") }
}
"meta" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
} else { throw ParsingException("Wrong type for meta") }
}
"ts" -> {
if (prop.element is JsonStreamElement.Number) {
ts = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for ts") }
}
"read" -> {
if (prop.element is JsonStreamElement.Bool) {
read = prop.element.value
} else { throw ParsingException("Wrong type for read") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.notification.api.Notification(
type = type ?: throw ParsingException("Missing key 'type'"),
message = message ?: throw ParsingException("Missing key 'message'"),
id = id,
meta = meta ?: throw ParsingException("Missing key 'meta'"),
ts = ts ?: throw ParsingException("Missing key 'ts'"),
read = read ?: throw ParsingException("Missing key 'read'"),
)
}
inline fun `dk_sdu_cloud_notification_api_FindByNotificationIdBulk_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.notification.api.FindByNotificationIdBulk {
var ids: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"ids" -> {
if (prop.element is JsonStreamElement.Text) {
ids = prop.element.value
} else { throw ParsingException("Wrong type for ids") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.notification.api.FindByNotificationIdBulk(
ids = ids ?: throw ParsingException("Missing key 'ids'"),
)
}
inline fun `dk_sdu_cloud_notification_api_MarkResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.notification.api.MarkResponse {
var failures: List<Long>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"failures" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val failuresList = ArrayList<Long>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val failuresElem: Long
if (prop.element is JsonStreamElement.Number) {
failuresElem = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for failuresElem") }
failuresList.add(failuresElem)
} else { throw ParsingException("Wrong element type for failures") }
}
failures = failuresList
} else { throw ParsingException("Wrong type for failures") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.notification.api.MarkResponse(
failures = failures ?: throw ParsingException("Missing key 'failures'"),
)
}
inline fun `dk_sdu_cloud_notification_api_CreateNotification_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.notification.api.CreateNotification {
var user: String? = null
var notification: dk.sdu.cloud.notification.api.Notification? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"user" -> {
if (prop.element is JsonStreamElement.Text) {
user = prop.element.value
} else { throw ParsingException("Wrong type for user") }
}
"notification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
notification = parseJson<dk.sdu.cloud.notification.api.Notification>(parser)
} else { throw ParsingException("Wrong type for notification") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.notification.api.CreateNotification(
user = user ?: throw ParsingException("Missing key 'user'"),
notification = notification ?: throw ParsingException("Missing key 'notification'"),
)
}
inline fun `dk_sdu_cloud_notification_api_DeleteResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.notification.api.DeleteResponse {
var failures: List<Long>? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"failures" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val failuresList = ArrayList<Long>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val failuresElem: Long
if (prop.element is JsonStreamElement.Number) {
failuresElem = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for failuresElem") }
failuresList.add(failuresElem)
} else { throw ParsingException("Wrong element type for failures") }
}
failures = failuresList
} else { throw ParsingException("Wrong type for failures") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.notification.api.DeleteResponse(
failures = failures ?: throw ParsingException("Missing key 'failures'"),
)
}
inline fun `dk_sdu_cloud_notification_api_InternalNotificationRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.notification.api.InternalNotificationRequest {
var user: String? = null
var notification: dk.sdu.cloud.notification.api.Notification? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"user" -> {
if (prop.element is JsonStreamElement.Text) {
user = prop.element.value
} else { throw ParsingException("Wrong type for user") }
}
"notification" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
notification = parseJson<dk.sdu.cloud.notification.api.Notification>(parser)
} else { throw ParsingException("Wrong type for notification") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.notification.api.InternalNotificationRequest(
user = user ?: throw ParsingException("Missing key 'user'"),
notification = notification ?: throw ParsingException("Missing key 'notification'"),
)
}
inline fun `dk_sdu_cloud_task_api_ListRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.task.api.ListRequest {
var itemsPerPage: Int? = null
var page: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"itemsPerPage" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
itemsPerPage = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for itemsPerPage") }
}
"page" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Number) {
page = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for page") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.task.api.ListRequest(
itemsPerPage = itemsPerPage,
page = page,
)
}
inline fun `dk_sdu_cloud_task_api_Task_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.task.api.Task {
var jobId: String? = null
var owner: String? = null
var processor: String? = null
var title: String? = null
var status: String? = null
var complete: Boolean? = null
var startedAt: Long? = null
var modifiedAt: Long? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
"owner" -> {
if (prop.element is JsonStreamElement.Text) {
owner = prop.element.value
} else { throw ParsingException("Wrong type for owner") }
}
"processor" -> {
if (prop.element is JsonStreamElement.Text) {
processor = prop.element.value
} else { throw ParsingException("Wrong type for processor") }
}
"title" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"status" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
"complete" -> {
if (prop.element is JsonStreamElement.Bool) {
complete = prop.element.value
} else { throw ParsingException("Wrong type for complete") }
}
"startedAt" -> {
if (prop.element is JsonStreamElement.Number) {
startedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for startedAt") }
}
"modifiedAt" -> {
if (prop.element is JsonStreamElement.Number) {
modifiedAt = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for modifiedAt") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.task.api.Task(
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
processor = processor ?: throw ParsingException("Missing key 'processor'"),
title = title,
status = status,
complete = complete ?: throw ParsingException("Missing key 'complete'"),
startedAt = startedAt ?: throw ParsingException("Missing key 'startedAt'"),
modifiedAt = modifiedAt ?: throw ParsingException("Missing key 'modifiedAt'"),
)
}
inline fun `dk_sdu_cloud_task_api_TaskUpdate_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.task.api.TaskUpdate {
var jobId: String? = null
var newTitle: String? = null
var speeds: List<dk.sdu.cloud.task.api.Speed>? = null
var progress: dk.sdu.cloud.task.api.Progress? = null
var complete: Boolean? = null
var messageToAppend: String? = null
var newStatus: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"jobId" -> {
if (prop.element is JsonStreamElement.Text) {
jobId = prop.element.value
} else { throw ParsingException("Wrong type for jobId") }
}
"newTitle" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
newTitle = prop.element.value
} else { throw ParsingException("Wrong type for newTitle") }
}
"speeds" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val speedsList = ArrayList<dk.sdu.cloud.task.api.Speed>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val speedsElem: dk.sdu.cloud.task.api.Speed
if (prop.element is JsonStreamElement.ObjectStart) {
speedsElem = parseJson<dk.sdu.cloud.task.api.Speed>(parser)
} else { throw ParsingException("Wrong type for speedsElem") }
speedsList.add(speedsElem)
} else { throw ParsingException("Wrong element type for speeds") }
}
speeds = speedsList
} else { throw ParsingException("Wrong type for speeds") }
}
"progress" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.ObjectStart) {
progress = parseJson<dk.sdu.cloud.task.api.Progress?>(parser)
} else { throw ParsingException("Wrong type for progress") }
}
"complete" -> {
if (prop.element is JsonStreamElement.Bool) {
complete = prop.element.value
} else { throw ParsingException("Wrong type for complete") }
}
"messageToAppend" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
messageToAppend = prop.element.value
} else { throw ParsingException("Wrong type for messageToAppend") }
}
"newStatus" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
newStatus = prop.element.value
} else { throw ParsingException("Wrong type for newStatus") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.task.api.TaskUpdate(
jobId = jobId ?: throw ParsingException("Missing key 'jobId'"),
newTitle = newTitle,
speeds = speeds ?: throw ParsingException("Missing key 'speeds'"),
progress = progress,
complete = complete ?: throw ParsingException("Missing key 'complete'"),
messageToAppend = messageToAppend,
newStatus = newStatus,
)
}
inline fun `dk_sdu_cloud_task_api_Speed_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.task.api.Speed {
var title: String? = null
var speed: Double? = null
var unit: String? = null
var asText: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"speed" -> {
if (prop.element is JsonStreamElement.Number) {
speed = prop.element.value
} else { throw ParsingException("Wrong type for speed") }
}
"unit" -> {
if (prop.element is JsonStreamElement.Text) {
unit = prop.element.value
} else { throw ParsingException("Wrong type for unit") }
}
"asText" -> {
if (prop.element is JsonStreamElement.Text) {
asText = prop.element.value
} else { throw ParsingException("Wrong type for asText") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.task.api.Speed(
title = title ?: throw ParsingException("Missing key 'title'"),
speed = speed ?: throw ParsingException("Missing key 'speed'"),
unit = unit ?: throw ParsingException("Missing key 'unit'"),
asText = asText ?: throw ParsingException("Missing key 'asText'"),
)
}
inline fun `dk_sdu_cloud_task_api_Progress_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.task.api.Progress {
var title: String? = null
var current: Int? = null
var maximum: Int? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"current" -> {
if (prop.element is JsonStreamElement.Number) {
current = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for current") }
}
"maximum" -> {
if (prop.element is JsonStreamElement.Number) {
maximum = prop.element.value.toInt()
} else { throw ParsingException("Wrong type for maximum") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.task.api.Progress(
title = title ?: throw ParsingException("Missing key 'title'"),
current = current ?: throw ParsingException("Missing key 'current'"),
maximum = maximum ?: throw ParsingException("Missing key 'maximum'"),
)
}
inline fun `dk_sdu_cloud_task_api_CreateRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.task.api.CreateRequest {
var title: String? = null
var owner: String? = null
var initialStatus: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"title" -> {
if (prop.element is JsonStreamElement.Text) {
title = prop.element.value
} else { throw ParsingException("Wrong type for title") }
}
"owner" -> {
if (prop.element is JsonStreamElement.Text) {
owner = prop.element.value
} else { throw ParsingException("Wrong type for owner") }
}
"initialStatus" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
initialStatus = prop.element.value
} else { throw ParsingException("Wrong type for initialStatus") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.task.api.CreateRequest(
title = title ?: throw ParsingException("Missing key 'title'"),
owner = owner ?: throw ParsingException("Missing key 'owner'"),
initialStatus = initialStatus,
)
}
inline fun `dk_sdu_cloud_task_api_PostStatusRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.task.api.PostStatusRequest {
var update: dk.sdu.cloud.task.api.TaskUpdate? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"update" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
update = parseJson<dk.sdu.cloud.task.api.TaskUpdate>(parser)
} else { throw ParsingException("Wrong type for update") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.task.api.PostStatusRequest(
update = update ?: throw ParsingException("Missing key 'update'"),
)
}
inline fun `dk_sdu_cloud_support_api_CreateTicketRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.support.api.CreateTicketRequest {
var subject: String? = null
var message: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
"message" -> {
if (prop.element is JsonStreamElement.Text) {
message = prop.element.value
} else { throw ParsingException("Wrong type for message") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.support.api.CreateTicketRequest(
subject = subject ?: throw ParsingException("Missing key 'subject'"),
message = message ?: throw ParsingException("Missing key 'message'"),
)
}
inline fun `dk_sdu_cloud_slack_api_Alert_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.slack.api.Alert {
var message: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"message" -> {
if (prop.element is JsonStreamElement.Text) {
message = prop.element.value
} else { throw ParsingException("Wrong type for message") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.slack.api.Alert(
message = message ?: throw ParsingException("Missing key 'message'"),
)
}
inline fun `dk_sdu_cloud_slack_api_Ticket_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.slack.api.Ticket {
var requestId: String? = null
var principal: dk.sdu.cloud.SecurityPrincipal? = null
var userAgent: String? = null
var subject: String? = null
var message: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"requestId" -> {
if (prop.element is JsonStreamElement.Text) {
requestId = prop.element.value
} else { throw ParsingException("Wrong type for requestId") }
}
"principal" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
principal = parseJson<dk.sdu.cloud.SecurityPrincipal>(parser)
} else { throw ParsingException("Wrong type for principal") }
}
"userAgent" -> {
if (prop.element is JsonStreamElement.Text) {
userAgent = prop.element.value
} else { throw ParsingException("Wrong type for userAgent") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
"message" -> {
if (prop.element is JsonStreamElement.Text) {
message = prop.element.value
} else { throw ParsingException("Wrong type for message") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.slack.api.Ticket(
requestId = requestId ?: throw ParsingException("Missing key 'requestId'"),
principal = principal ?: throw ParsingException("Missing key 'principal'"),
userAgent = userAgent ?: throw ParsingException("Missing key 'userAgent'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
message = message ?: throw ParsingException("Missing key 'message'"),
)
}
inline fun `dk_sdu_cloud_SecurityPrincipal_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.SecurityPrincipal {
var username: String? = null
var role: dk.sdu.cloud.Role? = null
var firstName: String? = null
var lastName: String? = null
var uid: Long? = null
var email: String? = null
var twoFactorAuthentication: Boolean? = null
var principalType: String? = null
var serviceAgreementAccepted: Boolean? = null
var organization: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
"role" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
role = parseJson<dk.sdu.cloud.Role>(parser)
} else { throw ParsingException("Wrong type for role") }
}
"firstName" -> {
if (prop.element is JsonStreamElement.Text) {
firstName = prop.element.value
} else { throw ParsingException("Wrong type for firstName") }
}
"lastName" -> {
if (prop.element is JsonStreamElement.Text) {
lastName = prop.element.value
} else { throw ParsingException("Wrong type for lastName") }
}
"uid" -> {
if (prop.element is JsonStreamElement.Number) {
uid = prop.element.value.toLong()
} else { throw ParsingException("Wrong type for uid") }
}
"email" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
email = prop.element.value
} else { throw ParsingException("Wrong type for email") }
}
"twoFactorAuthentication" -> {
if (prop.element is JsonStreamElement.Bool) {
twoFactorAuthentication = prop.element.value
} else { throw ParsingException("Wrong type for twoFactorAuthentication") }
}
"principalType" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
principalType = prop.element.value
} else { throw ParsingException("Wrong type for principalType") }
}
"serviceAgreementAccepted" -> {
if (prop.element is JsonStreamElement.Bool) {
serviceAgreementAccepted = prop.element.value
} else { throw ParsingException("Wrong type for serviceAgreementAccepted") }
}
"organization" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
organization = prop.element.value
} else { throw ParsingException("Wrong type for organization") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.SecurityPrincipal(
username = username ?: throw ParsingException("Missing key 'username'"),
role = role ?: throw ParsingException("Missing key 'role'"),
firstName = firstName ?: throw ParsingException("Missing key 'firstName'"),
lastName = lastName ?: throw ParsingException("Missing key 'lastName'"),
uid = uid ?: throw ParsingException("Missing key 'uid'"),
email = email,
twoFactorAuthentication = twoFactorAuthentication ?: throw ParsingException("Missing key 'twoFactorAuthentication'"),
principalType = principalType,
serviceAgreementAccepted = serviceAgreementAccepted ?: throw ParsingException("Missing key 'serviceAgreementAccepted'"),
organization = organization,
)
}
inline fun `dk_sdu_cloud_mail_api_SendSupportEmailRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.SendSupportEmailRequest {
var fromEmail: String? = null
var subject: String? = null
var message: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"fromEmail" -> {
if (prop.element is JsonStreamElement.Text) {
fromEmail = prop.element.value
} else { throw ParsingException("Wrong type for fromEmail") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
"message" -> {
if (prop.element is JsonStreamElement.Text) {
message = prop.element.value
} else { throw ParsingException("Wrong type for message") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.SendSupportEmailRequest(
fromEmail = fromEmail ?: throw ParsingException("Missing key 'fromEmail'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
message = message ?: throw ParsingException("Missing key 'message'"),
)
}
inline fun `dk_sdu_cloud_mail_api_SendRequestItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.SendRequestItem {
var receiver: String? = null
var mail: dk.sdu.cloud.mail.api.Mail? = null
var mandatory: Boolean? = null
var receivingEmail: String? = null
var testMail: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"receiver" -> {
if (prop.element is JsonStreamElement.Text) {
receiver = prop.element.value
} else { throw ParsingException("Wrong type for receiver") }
}
"mail" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
mail = parseJson<dk.sdu.cloud.mail.api.Mail>(parser)
} else { throw ParsingException("Wrong type for mail") }
}
"mandatory" -> {
if (prop.element is JsonStreamElement.Bool) {
mandatory = prop.element.value
} else { throw ParsingException("Wrong type for mandatory") }
}
"receivingEmail" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
receivingEmail = prop.element.value
} else { throw ParsingException("Wrong type for receivingEmail") }
}
"testMail" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Bool) {
testMail = prop.element.value
} else { throw ParsingException("Wrong type for testMail") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.SendRequestItem(
receiver = receiver ?: throw ParsingException("Missing key 'receiver'"),
mail = mail ?: throw ParsingException("Missing key 'mail'"),
mandatory = mandatory ?: throw ParsingException("Missing key 'mandatory'"),
receivingEmail = receivingEmail,
testMail = testMail,
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_TransferApplicationMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.TransferApplicationMail {
var senderProject: String? = null
var receiverProject: String? = null
var applicationProjectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"senderProject" -> {
if (prop.element is JsonStreamElement.Text) {
senderProject = prop.element.value
} else { throw ParsingException("Wrong type for senderProject") }
}
"receiverProject" -> {
if (prop.element is JsonStreamElement.Text) {
receiverProject = prop.element.value
} else { throw ParsingException("Wrong type for receiverProject") }
}
"applicationProjectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
applicationProjectTitle = prop.element.value
} else { throw ParsingException("Wrong type for applicationProjectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.TransferApplicationMail(
senderProject = senderProject ?: throw ParsingException("Missing key 'senderProject'"),
receiverProject = receiverProject ?: throw ParsingException("Missing key 'receiverProject'"),
applicationProjectTitle = applicationProjectTitle ?: throw ParsingException("Missing key 'applicationProjectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_LowFundsMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.LowFundsMail {
var categories: List<String>? = null
var providers: List<String>? = null
var projectTitles: List<String>? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"categories" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val categoriesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val categoriesElem: String
if (prop.element is JsonStreamElement.Text) {
categoriesElem = prop.element.value
} else { throw ParsingException("Wrong type for categoriesElem") }
categoriesList.add(categoriesElem)
} else { throw ParsingException("Wrong element type for categories") }
}
categories = categoriesList
} else { throw ParsingException("Wrong type for categories") }
}
"providers" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val providersList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val providersElem: String
if (prop.element is JsonStreamElement.Text) {
providersElem = prop.element.value
} else { throw ParsingException("Wrong type for providersElem") }
providersList.add(providersElem)
} else { throw ParsingException("Wrong element type for providers") }
}
providers = providersList
} else { throw ParsingException("Wrong type for providers") }
}
"projectTitles" -> {
if (prop.element is JsonStreamElement.ArrayStart) {
val projectTitlesList = ArrayList<String>()
while (true) {
val tok = parser.nextToken()
if (tok == JsonStreamElement.ArrayEnd) {
break
} else if (tok is JsonStreamElement.ArrayStart) {
val projectTitlesElem: String
if (prop.element is JsonStreamElement.Text) {
projectTitlesElem = prop.element.value
} else { throw ParsingException("Wrong type for projectTitlesElem") }
projectTitlesList.add(projectTitlesElem)
} else { throw ParsingException("Wrong element type for projectTitles") }
}
projectTitles = projectTitlesList
} else { throw ParsingException("Wrong type for projectTitles") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.LowFundsMail(
categories = categories ?: throw ParsingException("Missing key 'categories'"),
providers = providers ?: throw ParsingException("Missing key 'providers'"),
projectTitles = projectTitles ?: throw ParsingException("Missing key 'projectTitles'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_StillLowFundsMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.StillLowFundsMail {
var category: String? = null
var provider: String? = null
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"category" -> {
if (prop.element is JsonStreamElement.Text) {
category = prop.element.value
} else { throw ParsingException("Wrong type for category") }
}
"provider" -> {
if (prop.element is JsonStreamElement.Text) {
provider = prop.element.value
} else { throw ParsingException("Wrong type for provider") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.StillLowFundsMail(
category = category ?: throw ParsingException("Missing key 'category'"),
provider = provider ?: throw ParsingException("Missing key 'provider'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_UserRoleChangeMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.UserRoleChangeMail {
var subjectToChange: String? = null
var roleChange: String? = null
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"subjectToChange" -> {
if (prop.element is JsonStreamElement.Text) {
subjectToChange = prop.element.value
} else { throw ParsingException("Wrong type for subjectToChange") }
}
"roleChange" -> {
if (prop.element is JsonStreamElement.Text) {
roleChange = prop.element.value
} else { throw ParsingException("Wrong type for roleChange") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.UserRoleChangeMail(
subjectToChange = subjectToChange ?: throw ParsingException("Missing key 'subjectToChange'"),
roleChange = roleChange ?: throw ParsingException("Missing key 'roleChange'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_UserLeftMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.UserLeftMail {
var leavingUser: String? = null
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"leavingUser" -> {
if (prop.element is JsonStreamElement.Text) {
leavingUser = prop.element.value
} else { throw ParsingException("Wrong type for leavingUser") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.UserLeftMail(
leavingUser = leavingUser ?: throw ParsingException("Missing key 'leavingUser'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_UserRemovedMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.UserRemovedMail {
var leavingUser: String? = null
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"leavingUser" -> {
if (prop.element is JsonStreamElement.Text) {
leavingUser = prop.element.value
} else { throw ParsingException("Wrong type for leavingUser") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.UserRemovedMail(
leavingUser = leavingUser ?: throw ParsingException("Missing key 'leavingUser'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_UserRemovedMailToUser_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.UserRemovedMailToUser {
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.UserRemovedMailToUser(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_ProjectInviteMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.ProjectInviteMail {
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.ProjectInviteMail(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_NewGrantApplicationMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.NewGrantApplicationMail {
var sender: String? = null
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.NewGrantApplicationMail(
sender = sender ?: throw ParsingException("Missing key 'sender'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantAppAutoApproveToAdminsMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantAppAutoApproveToAdminsMail {
var sender: String? = null
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantAppAutoApproveToAdminsMail(
sender = sender ?: throw ParsingException("Missing key 'sender'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantApplicationUpdatedMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantApplicationUpdatedMail {
var projectTitle: String? = null
var sender: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantApplicationUpdatedMail(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
sender = sender ?: throw ParsingException("Missing key 'sender'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantApplicationUpdatedMailToAdmins_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantApplicationUpdatedMailToAdmins {
var projectTitle: String? = null
var sender: String? = null
var receivingProjectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"receivingProjectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
receivingProjectTitle = prop.element.value
} else { throw ParsingException("Wrong type for receivingProjectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantApplicationUpdatedMailToAdmins(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
sender = sender ?: throw ParsingException("Missing key 'sender'"),
receivingProjectTitle = receivingProjectTitle ?: throw ParsingException("Missing key 'receivingProjectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantApplicationStatusChangedToAdmin_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantApplicationStatusChangedToAdmin {
var status: String? = null
var projectTitle: String? = null
var sender: String? = null
var receivingProjectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"status" -> {
if (prop.element is JsonStreamElement.Text) {
status = prop.element.value
} else { throw ParsingException("Wrong type for status") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"receivingProjectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
receivingProjectTitle = prop.element.value
} else { throw ParsingException("Wrong type for receivingProjectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantApplicationStatusChangedToAdmin(
status = status ?: throw ParsingException("Missing key 'status'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
sender = sender ?: throw ParsingException("Missing key 'sender'"),
receivingProjectTitle = receivingProjectTitle ?: throw ParsingException("Missing key 'receivingProjectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantApplicationApproveMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantApplicationApproveMail {
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantApplicationApproveMail(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantApplicationApproveMailToAdmins_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantApplicationApproveMailToAdmins {
var sender: String? = null
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantApplicationApproveMailToAdmins(
sender = sender ?: throw ParsingException("Missing key 'sender'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantApplicationRejectedMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantApplicationRejectedMail {
var projectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantApplicationRejectedMail(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_GrantApplicationWithdrawnMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.GrantApplicationWithdrawnMail {
var projectTitle: String? = null
var sender: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.GrantApplicationWithdrawnMail(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
sender = sender ?: throw ParsingException("Missing key 'sender'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_NewCommentOnApplicationMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.NewCommentOnApplicationMail {
var sender: String? = null
var projectTitle: String? = null
var receivingProjectTitle: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"sender" -> {
if (prop.element is JsonStreamElement.Text) {
sender = prop.element.value
} else { throw ParsingException("Wrong type for sender") }
}
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"receivingProjectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
receivingProjectTitle = prop.element.value
} else { throw ParsingException("Wrong type for receivingProjectTitle") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.NewCommentOnApplicationMail(
sender = sender ?: throw ParsingException("Missing key 'sender'"),
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
receivingProjectTitle = receivingProjectTitle ?: throw ParsingException("Missing key 'receivingProjectTitle'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_ResetPasswordMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.ResetPasswordMail {
var token: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"token" -> {
if (prop.element is JsonStreamElement.Text) {
token = prop.element.value
} else { throw ParsingException("Wrong type for token") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.ResetPasswordMail(
token = token ?: throw ParsingException("Missing key 'token'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_Mail_VerificationReminderMail_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.Mail.VerificationReminderMail {
var projectTitle: String? = null
var role: String? = null
var subject: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"projectTitle" -> {
if (prop.element is JsonStreamElement.Text) {
projectTitle = prop.element.value
} else { throw ParsingException("Wrong type for projectTitle") }
}
"role" -> {
if (prop.element is JsonStreamElement.Text) {
role = prop.element.value
} else { throw ParsingException("Wrong type for role") }
}
"subject" -> {
if (prop.element is JsonStreamElement.Text) {
subject = prop.element.value
} else { throw ParsingException("Wrong type for subject") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.Mail.VerificationReminderMail(
projectTitle = projectTitle ?: throw ParsingException("Missing key 'projectTitle'"),
role = role ?: throw ParsingException("Missing key 'role'"),
subject = subject ?: throw ParsingException("Missing key 'subject'"),
)
}
inline fun `dk_sdu_cloud_mail_api_EmailSettingsItem_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.EmailSettingsItem {
var username: String? = null
var settings: dk.sdu.cloud.mail.api.EmailSettings? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
"settings" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
settings = parseJson<dk.sdu.cloud.mail.api.EmailSettings>(parser)
} else { throw ParsingException("Wrong type for settings") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.EmailSettingsItem(
username = username,
settings = settings ?: throw ParsingException("Missing key 'settings'"),
)
}
inline fun `dk_sdu_cloud_mail_api_EmailSettings_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.EmailSettings {
var newGrantApplication: Boolean? = null
var grantAutoApprove: Boolean? = null
var grantApplicationUpdated: Boolean? = null
var grantApplicationApproved: Boolean? = null
var grantApplicationRejected: Boolean? = null
var grantApplicationWithdrawn: Boolean? = null
var newCommentOnApplication: Boolean? = null
var applicationTransfer: Boolean? = null
var applicationStatusChange: Boolean? = null
var projectUserInvite: Boolean? = null
var projectUserRemoved: Boolean? = null
var verificationReminder: Boolean? = null
var userRoleChange: Boolean? = null
var userLeft: Boolean? = null
var lowFunds: Boolean? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"newGrantApplication" -> {
if (prop.element is JsonStreamElement.Bool) {
newGrantApplication = prop.element.value
} else { throw ParsingException("Wrong type for newGrantApplication") }
}
"grantAutoApprove" -> {
if (prop.element is JsonStreamElement.Bool) {
grantAutoApprove = prop.element.value
} else { throw ParsingException("Wrong type for grantAutoApprove") }
}
"grantApplicationUpdated" -> {
if (prop.element is JsonStreamElement.Bool) {
grantApplicationUpdated = prop.element.value
} else { throw ParsingException("Wrong type for grantApplicationUpdated") }
}
"grantApplicationApproved" -> {
if (prop.element is JsonStreamElement.Bool) {
grantApplicationApproved = prop.element.value
} else { throw ParsingException("Wrong type for grantApplicationApproved") }
}
"grantApplicationRejected" -> {
if (prop.element is JsonStreamElement.Bool) {
grantApplicationRejected = prop.element.value
} else { throw ParsingException("Wrong type for grantApplicationRejected") }
}
"grantApplicationWithdrawn" -> {
if (prop.element is JsonStreamElement.Bool) {
grantApplicationWithdrawn = prop.element.value
} else { throw ParsingException("Wrong type for grantApplicationWithdrawn") }
}
"newCommentOnApplication" -> {
if (prop.element is JsonStreamElement.Bool) {
newCommentOnApplication = prop.element.value
} else { throw ParsingException("Wrong type for newCommentOnApplication") }
}
"applicationTransfer" -> {
if (prop.element is JsonStreamElement.Bool) {
applicationTransfer = prop.element.value
} else { throw ParsingException("Wrong type for applicationTransfer") }
}
"applicationStatusChange" -> {
if (prop.element is JsonStreamElement.Bool) {
applicationStatusChange = prop.element.value
} else { throw ParsingException("Wrong type for applicationStatusChange") }
}
"projectUserInvite" -> {
if (prop.element is JsonStreamElement.Bool) {
projectUserInvite = prop.element.value
} else { throw ParsingException("Wrong type for projectUserInvite") }
}
"projectUserRemoved" -> {
if (prop.element is JsonStreamElement.Bool) {
projectUserRemoved = prop.element.value
} else { throw ParsingException("Wrong type for projectUserRemoved") }
}
"verificationReminder" -> {
if (prop.element is JsonStreamElement.Bool) {
verificationReminder = prop.element.value
} else { throw ParsingException("Wrong type for verificationReminder") }
}
"userRoleChange" -> {
if (prop.element is JsonStreamElement.Bool) {
userRoleChange = prop.element.value
} else { throw ParsingException("Wrong type for userRoleChange") }
}
"userLeft" -> {
if (prop.element is JsonStreamElement.Bool) {
userLeft = prop.element.value
} else { throw ParsingException("Wrong type for userLeft") }
}
"lowFunds" -> {
if (prop.element is JsonStreamElement.Bool) {
lowFunds = prop.element.value
} else { throw ParsingException("Wrong type for lowFunds") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.EmailSettings(
newGrantApplication = newGrantApplication ?: throw ParsingException("Missing key 'newGrantApplication'"),
grantAutoApprove = grantAutoApprove ?: throw ParsingException("Missing key 'grantAutoApprove'"),
grantApplicationUpdated = grantApplicationUpdated ?: throw ParsingException("Missing key 'grantApplicationUpdated'"),
grantApplicationApproved = grantApplicationApproved ?: throw ParsingException("Missing key 'grantApplicationApproved'"),
grantApplicationRejected = grantApplicationRejected ?: throw ParsingException("Missing key 'grantApplicationRejected'"),
grantApplicationWithdrawn = grantApplicationWithdrawn ?: throw ParsingException("Missing key 'grantApplicationWithdrawn'"),
newCommentOnApplication = newCommentOnApplication ?: throw ParsingException("Missing key 'newCommentOnApplication'"),
applicationTransfer = applicationTransfer ?: throw ParsingException("Missing key 'applicationTransfer'"),
applicationStatusChange = applicationStatusChange ?: throw ParsingException("Missing key 'applicationStatusChange'"),
projectUserInvite = projectUserInvite ?: throw ParsingException("Missing key 'projectUserInvite'"),
projectUserRemoved = projectUserRemoved ?: throw ParsingException("Missing key 'projectUserRemoved'"),
verificationReminder = verificationReminder ?: throw ParsingException("Missing key 'verificationReminder'"),
userRoleChange = userRoleChange ?: throw ParsingException("Missing key 'userRoleChange'"),
userLeft = userLeft ?: throw ParsingException("Missing key 'userLeft'"),
lowFunds = lowFunds ?: throw ParsingException("Missing key 'lowFunds'"),
)
}
inline fun `dk_sdu_cloud_mail_api_RetrieveEmailSettingsRequest_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.RetrieveEmailSettingsRequest {
var username: String? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"username" -> {
if (prop.element is JsonStreamElement.Null) { /* do nothing */ }
else if (prop.element is JsonStreamElement.Text) {
username = prop.element.value
} else { throw ParsingException("Wrong type for username") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.RetrieveEmailSettingsRequest(
username = username,
)
}
inline fun `dk_sdu_cloud_mail_api_RetrieveEmailSettingsResponse_deserialize`(parser: JsonParser, objectHasStarted: Boolean = false): dk.sdu.cloud.mail.api.RetrieveEmailSettingsResponse {
var settings: dk.sdu.cloud.mail.api.EmailSettings? = null
if (!objectHasStarted && parser.nextToken() != JsonStreamElement.ObjectStart) throw ParsingException("Expected an object")
while (true) {
val nextParserToken = parser.nextToken()
if (nextParserToken == JsonStreamElement.ObjectEnd) break
val prop = nextParserToken as? JsonStreamElement.Property ?: throw ParsingException("Expected property but got $nextParserToken")
when (prop.key) {
"settings" -> {
if (prop.element is JsonStreamElement.ObjectStart) {
settings = parseJson<dk.sdu.cloud.mail.api.EmailSettings>(parser)
} else { throw ParsingException("Wrong type for settings") }
}
else -> {
if (prop.element == JsonStreamElement.ArrayStart || prop.element == JsonStreamElement.ObjectStart) { parser.skipCurrentContext() }
}
}
}
return dk.sdu.cloud.mail.api.RetrieveEmailSettingsResponse(
settings = settings ?: throw ParsingException("Missing key 'settings'"),
)
}
inline fun <reified T> parseJson(parser: JsonParser, hasStartedObject: Boolean = false): T {
when (T::class.qualifiedName) {
"dk.sdu.cloud.app.orchestrator.api.QueueStatus" -> return `dk_sdu_cloud_app_orchestrator_api_QueueStatus_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.AvailableGiftsResponse" -> return `dk_sdu_cloud_grant_api_AvailableGiftsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProvidersRequestApprovalRequest.Information" -> return `dk_sdu_cloud_provider_api_ProvidersRequestApprovalRequest_Information_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.RegisterWalletRequestItem" -> return `dk_sdu_cloud_accounting_api_RegisterWalletRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProvidersRequestApprovalResponse.AwaitingAdministratorApproval" -> return `dk_sdu_cloud_provider_api_ProvidersRequestApprovalResponse_AwaitingAdministratorApproval_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ExampleResourceFlags" -> return `dk_sdu_cloud_provider_api_ExampleResourceFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesControlMarkAsCompleteRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesControlMarkAsCompleteRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantAppAutoApproveToAdminsMail" -> return `dk_sdu_cloud_mail_api_Mail_GrantAppAutoApproveToAdminsMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.DeleteGroupsRequest" -> return `dk_sdu_cloud_project_api_DeleteGroupsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationWithExtension" -> return `dk_sdu_cloud_app_store_api_ApplicationWithExtension_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupAdminsBulkResponse" -> return `dk_sdu_cloud_project_api_LookupAdminsBulkResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesCreateUploadResponseItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesCreateUploadResponseItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.calls.BulkResponse" -> return `dk_sdu_cloud_calls_BulkResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.Share" -> return `dk_sdu_cloud_file_orchestrator_api_Share_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.news.api.TogglePostHiddenRequest" -> return `dk_sdu_cloud_news_api_TogglePostHiddenRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ComputeSupport.Docker" -> return `dk_sdu_cloud_app_orchestrator_api_ComputeSupport_Docker_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.IngressStatus" -> return `dk_sdu_cloud_app_orchestrator_api_IngressStatus_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.UserGroupSummary" -> return `dk_sdu_cloud_project_api_UserGroupSummary_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIPUpdate" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIPUpdate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataAttached" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataAttached_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.BlockStorage" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_BlockStorage_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataOrDeleted.Deleted" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataOrDeleted_Deleted_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.Product.License" -> return `dk_sdu_cloud_accounting_api_Product_License_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantApplicationUpdatedMailToAdmins" -> return `dk_sdu_cloud_mail_api_Mail_GrantApplicationUpdatedMailToAdmins_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FSSupport" -> return `dk_sdu_cloud_file_orchestrator_api_FSSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.DeleteAppRequest" -> return `dk_sdu_cloud_app_store_api_DeleteAppRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.notification.api.Notification" -> return `dk_sdu_cloud_notification_api_Notification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.IsEnabledRequest" -> return `dk_sdu_cloud_grant_api_IsEnabledRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.FloatingPoint" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_FloatingPoint_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Update" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_Update_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.GroupExistsResponse" -> return `dk_sdu_cloud_project_api_GroupExistsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ExistsResponse" -> return `dk_sdu_cloud_project_api_ExistsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Pending" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_Pending_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.UserProjectSummary" -> return `dk_sdu_cloud_project_api_UserProjectSummary_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Spec" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_Spec_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.FindByNameAndVersion" -> return `dk_sdu_cloud_app_store_api_FindByNameAndVersion_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.notification.api.CreateNotification" -> return `dk_sdu_cloud_notification_api_CreateNotification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsFollowResponse" -> return `dk_sdu_cloud_app_orchestrator_api_JobsFollowResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileCollectionIncludeFlags" -> return `dk_sdu_cloud_file_orchestrator_api_FileCollectionIncludeFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.IngoingInvite" -> return `dk_sdu_cloud_project_api_IngoingInvite_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.IsMemberRequest" -> return `dk_sdu_cloud_project_api_IsMemberRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.password.reset.api.NewPasswordRequest" -> return `dk_sdu_cloud_password_reset_api_NewPasswordRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ResourcePermissions" -> return `dk_sdu_cloud_provider_api_ResourcePermissions_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AdvancedSearchRequest" -> return `dk_sdu_cloud_app_store_api_AdvancedSearchRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Approved" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_Approved_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesCreateFolderRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesCreateFolderRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.LowFundsMail" -> return `dk_sdu_cloud_mail_api_Mail_LowFundsMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.RejectApplicationRequest" -> return `dk_sdu_cloud_grant_api_RejectApplicationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantApplicationRejectedMail" -> return `dk_sdu_cloud_mail_api_Mail_GrantApplicationRejectedMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.LongRunningTask.ContinuesInBackground" -> return `dk_sdu_cloud_file_orchestrator_api_LongRunningTask_ContinuesInBackground_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ProjectMember" -> return `dk_sdu_cloud_project_api_ProjectMember_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.FetchLogoRequest" -> return `dk_sdu_cloud_grant_api_FetchLogoRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.UserCriteria.EmailDomain" -> return `dk_sdu_cloud_grant_api_UserCriteria_EmailDomain_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.Comment" -> return `dk_sdu_cloud_grant_api_Comment_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.ProductCategoryId" -> return `dk_sdu_cloud_accounting_api_ProductCategoryId_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesCopyRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesCopyRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ProjectAndGroup" -> return `dk_sdu_cloud_project_api_ProjectAndGroup_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProviderUpdate" -> return `dk_sdu_cloud_provider_api_ProviderUpdate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletAllocation" -> return `dk_sdu_cloud_accounting_api_WalletAllocation_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.EnvironmentVariableParameter" -> return `dk_sdu_cloud_app_store_api_EnvironmentVariableParameter_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ChangeUserRoleRequest" -> return `dk_sdu_cloud_project_api_ChangeUserRoleRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.Application" -> return `dk_sdu_cloud_app_store_api_Application_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.UFileIncludeFlags" -> return `dk_sdu_cloud_file_orchestrator_api_UFileIncludeFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ExampleResource.Spec" -> return `dk_sdu_cloud_provider_api_ExampleResource_Spec_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.OneTimeAccessToken" -> return `dk_sdu_cloud_auth_api_OneTimeAccessToken_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.InputFile" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_InputFile_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobUpdate" -> return `dk_sdu_cloud_app_orchestrator_api_JobUpdate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.BulkInvalidateRequest" -> return `dk_sdu_cloud_auth_api_BulkInvalidateRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.UsageChart" -> return `dk_sdu_cloud_accounting_api_UsageChart_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup" -> return `dk_sdu_cloud_file_orchestrator_api_OutgoingShareGroup_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.EmailSettingsItem" -> return `dk_sdu_cloud_mail_api_EmailSettingsItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ProjectSearchByPathRequest" -> return `dk_sdu_cloud_project_api_ProjectSearchByPathRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.notification.api.FindByNotificationIdBulk" -> return `dk_sdu_cloud_notification_api_FindByNotificationIdBulk_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileCollection.Status" -> return `dk_sdu_cloud_file_orchestrator_api_FileCollection_Status_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.LicenseServer" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_LicenseServer_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.FirewallAndIP" -> return `dk_sdu_cloud_app_orchestrator_api_FirewallAndIP_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.Person.ByPassword" -> return `dk_sdu_cloud_auth_api_Person_ByPassword_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.DeleteMemberRequest" -> return `dk_sdu_cloud_project_api_DeleteMemberRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProviderSupport" -> return `dk_sdu_cloud_provider_api_ProviderSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.SendSupportEmailRequest" -> return `dk_sdu_cloud_mail_api_SendSupportEmailRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.SharesBrowseOutgoingRequest" -> return `dk_sdu_cloud_file_orchestrator_api_SharesBrowseOutgoingRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.notification.api.InternalNotificationRequest" -> return `dk_sdu_cloud_notification_api_InternalNotificationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.UFile" -> return `dk_sdu_cloud_file_orchestrator_api_UFile_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.Project" -> return `dk_sdu_cloud_project_api_Project_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.EnumOption" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_EnumOption_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsRetrieveUtilizationRequest" -> return `dk_sdu_cloud_app_orchestrator_api_JobsRetrieveUtilizationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FindByPath" -> return `dk_sdu_cloud_file_orchestrator_api_FindByPath_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.GroupWithSummary" -> return `dk_sdu_cloud_project_api_GroupWithSummary_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AccessEntity" -> return `dk_sdu_cloud_app_store_api_AccessEntity_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIPSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.Session" -> return `dk_sdu_cloud_auth_api_Session_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsRetrieveUtilizationResponse" -> return `dk_sdu_cloud_app_orchestrator_api_JobsRetrieveUtilizationResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.GrantRecipient.PersonalProject" -> return `dk_sdu_cloud_grant_api_GrantRecipient_PersonalProject_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.InputDirectory" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_InputDirectory_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.Bool" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_Bool_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.PartialUFile" -> return `dk_sdu_cloud_file_orchestrator_api_PartialUFile_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.ResourceChargeCredits" -> return `dk_sdu_cloud_accounting_api_providers_ResourceChargeCredits_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesControlAddUpdateRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesControlAddUpdateRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.ClaimOneTimeToken" -> return `dk_sdu_cloud_auth_api_ClaimOneTimeToken_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.avatar.api.FindBulkResponse" -> return `dk_sdu_cloud_avatar_api_FindBulkResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.Share.Update" -> return `dk_sdu_cloud_file_orchestrator_api_Share_Update_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppSearchRequest" -> return `dk_sdu_cloud_app_store_api_AppSearchRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsProviderExtendRequestItem" -> return `dk_sdu_cloud_app_orchestrator_api_JobsProviderExtendRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.ChargeWalletRequestItem" -> return `dk_sdu_cloud_accounting_api_ChargeWalletRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.Product.Ingress" -> return `dk_sdu_cloud_accounting_api_Product_Ingress_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.GrantRecipient.ExistingProject" -> return `dk_sdu_cloud_grant_api_GrantRecipient_ExistingProject_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupUIDRequest" -> return `dk_sdu_cloud_auth_api_LookupUIDRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.PushWalletChangeRequestItem" -> return `dk_sdu_cloud_accounting_api_PushWalletChangeRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.AcceptInviteRequest" -> return `dk_sdu_cloud_project_api_AcceptInviteRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.LineChart" -> return `dk_sdu_cloud_accounting_api_LineChart_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.Provider" -> return `dk_sdu_cloud_provider_api_Provider_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.UpdateAclRequest" -> return `dk_sdu_cloud_app_store_api_UpdateAclRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.ResolvedSupport" -> return `dk_sdu_cloud_accounting_api_providers_ResolvedSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.UpdateGroupNameRequest" -> return `dk_sdu_cloud_project_api_UpdateGroupNameRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ResourceOwner" -> return `dk_sdu_cloud_provider_api_ResourceOwner_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.news.api.ListPostsRequest" -> return `dk_sdu_cloud_news_api_ListPostsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.IngressSpecification" -> return `dk_sdu_cloud_app_orchestrator_api_IngressSpecification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.IsEnabledResponse" -> return `dk_sdu_cloud_grant_api_IsEnabledResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.UpdatedAclWithResource" -> return `dk_sdu_cloud_provider_api_UpdatedAclWithResource_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.VariableInvocationParameter" -> return `dk_sdu_cloud_app_store_api_VariableInvocationParameter_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.GroupExistsRequest" -> return `dk_sdu_cloud_project_api_GroupExistsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.Project" -> return `dk_sdu_cloud_app_store_api_Project_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.DetailedAccessEntity" -> return `dk_sdu_cloud_app_store_api_DetailedAccessEntity_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.OpenSession.Web" -> return `dk_sdu_cloud_app_orchestrator_api_OpenSession_Web_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.Person.ByWAYF" -> return `dk_sdu_cloud_auth_api_Person_ByWAYF_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateSupport" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.OpenSession.Vnc" -> return `dk_sdu_cloud_app_orchestrator_api_OpenSession_Vnc_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.avatar.api.FindBulkRequest" -> return `dk_sdu_cloud_avatar_api_FindBulkRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ShellResponse.Initialized" -> return `dk_sdu_cloud_app_orchestrator_api_ShellResponse_Initialized_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupUserWithEmailResponse" -> return `dk_sdu_cloud_auth_api_LookupUserWithEmailResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.UploadDescriptionRequest" -> return `dk_sdu_cloud_grant_api_UploadDescriptionRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.UserCriteria.WayfOrganization" -> return `dk_sdu_cloud_grant_api_UserCriteria_WayfOrganization_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataMoveRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataMoveRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupByIdRequest" -> return `dk_sdu_cloud_project_api_LookupByIdRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.Peer" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_Peer_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.ResourceRetrieveRequest" -> return `dk_sdu_cloud_accounting_api_providers_ResourceRetrieveRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.Product.NetworkIP" -> return `dk_sdu_cloud_accounting_api_Product_NetworkIP_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletBrowseRequest" -> return `dk_sdu_cloud_accounting_api_WalletBrowseRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowRequest.CancelStream" -> return `dk_sdu_cloud_app_orchestrator_api_JobsProviderFollowRequest_CancelStream_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.slack.api.Ticket" -> return `dk_sdu_cloud_slack_api_Ticket_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantApplicationWithdrawnMail" -> return `dk_sdu_cloud_mail_api_Mail_GrantApplicationWithdrawnMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ExampleResource" -> return `dk_sdu_cloud_provider_api_ExampleResource_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.VisualizationRetrieveBreakdownResponse" -> return `dk_sdu_cloud_accounting_api_VisualizationRetrieveBreakdownResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.OpenSessionWithProvider" -> return `dk_sdu_cloud_app_orchestrator_api_OpenSessionWithProvider_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupByGroupTitleRequest" -> return `dk_sdu_cloud_project_api_LookupByGroupTitleRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileCollection.Update" -> return `dk_sdu_cloud_file_orchestrator_api_FileCollection_Update_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.SecurityPrincipal" -> return `dk_sdu_cloud_SecurityPrincipal_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupAdminsRequest" -> return `dk_sdu_cloud_project_api_LookupAdminsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.ProductsRetrieveRequest" -> return `dk_sdu_cloud_accounting_api_ProductsRetrieveRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ProjectWithTitle" -> return `dk_sdu_cloud_grant_api_ProjectWithTitle_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsProviderOpenInteractiveSessionRequestItem" -> return `dk_sdu_cloud_app_orchestrator_api_JobsProviderOpenInteractiveSessionRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.ChangePasswordRequest" -> return `dk_sdu_cloud_auth_api_ChangePasswordRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.File" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_File_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.RetrieveEmailSettingsResponse" -> return `dk_sdu_cloud_mail_api_RetrieveEmailSettingsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateUploadRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderCreateUploadRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ViewProjectRequest" -> return `dk_sdu_cloud_project_api_ViewProjectRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateAndVersion" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateAndVersion_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderMoveRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderMoveRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.LicenseSupport" -> return `dk_sdu_cloud_app_orchestrator_api_LicenseSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.VncDescription" -> return `dk_sdu_cloud_app_store_api_VncDescription_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.SearchRequest" -> return `dk_sdu_cloud_project_api_SearchRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.avatar.api.SerializedAvatar" -> return `dk_sdu_cloud_avatar_api_SerializedAvatar_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.AddGroupMemberRequest" -> return `dk_sdu_cloud_project_api_AddGroupMemberRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplatesBrowseTemplatesRequest" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplatesBrowseTemplatesRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.WordInvocationParameter" -> return `dk_sdu_cloud_app_store_api_WordInvocationParameter_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.ListUserSessionsRequest" -> return `dk_sdu_cloud_auth_api_ListUserSessionsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.OutgoingShareGroup.Preview" -> return `dk_sdu_cloud_file_orchestrator_api_OutgoingShareGroup_Preview_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ResourceUpdateAndId" -> return `dk_sdu_cloud_provider_api_ResourceUpdateAndId_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.TransferApplicationMail" -> return `dk_sdu_cloud_mail_api_Mail_TransferApplicationMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.AllowsRenamingRequest" -> return `dk_sdu_cloud_project_api_AllowsRenamingRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIPFlags" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIPFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.news.api.NewPostRequest" -> return `dk_sdu_cloud_news_api_NewPostRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileCollection" -> return `dk_sdu_cloud_file_orchestrator_api_FileCollection_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.GetPrincipalRequest" -> return `dk_sdu_cloud_auth_api_GetPrincipalRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ExampleResource.Status" -> return `dk_sdu_cloud_provider_api_ExampleResource_Status_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ApproveApplicationRequest" -> return `dk_sdu_cloud_grant_api_ApproveApplicationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.VisualizationRetrieveBreakdownRequest" -> return `dk_sdu_cloud_accounting_api_VisualizationRetrieveBreakdownRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletOwner.User" -> return `dk_sdu_cloud_accounting_api_WalletOwner_User_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.ChunkedUploadProtocolUploadChunkRequest" -> return `dk_sdu_cloud_file_orchestrator_api_ChunkedUploadProtocolUploadChunkRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.License" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_License_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.ResourceChargeCreditsResponse" -> return `dk_sdu_cloud_accounting_api_providers_ResourceChargeCreditsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.ShareFlags" -> return `dk_sdu_cloud_file_orchestrator_api_ShareFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsLog" -> return `dk_sdu_cloud_app_orchestrator_api_JobsLog_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AccessTokenAndCsrf" -> return `dk_sdu_cloud_auth_api_AccessTokenAndCsrf_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.GrantsRetrieveAffiliationsRequest" -> return `dk_sdu_cloud_grant_api_GrantsRetrieveAffiliationsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ExampleResource.Update" -> return `dk_sdu_cloud_provider_api_ExampleResource_Update_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.notification.api.DeleteResponse" -> return `dk_sdu_cloud_notification_api_DeleteResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.FirewallAndId" -> return `dk_sdu_cloud_app_orchestrator_api_FirewallAndId_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantApplicationApproveMail" -> return `dk_sdu_cloud_mail_api_Mail_GrantApplicationApproveMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.UpdateUserInfoRequest" -> return `dk_sdu_cloud_auth_api_UpdateUserInfoRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.Rejected" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_Rejected_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesMoveRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesMoveRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListSubProjectsRequest" -> return `dk_sdu_cloud_project_api_ListSubProjectsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowRequest.Init" -> return `dk_sdu_cloud_app_orchestrator_api_JobsProviderFollowRequest_Init_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ResourceRequest" -> return `dk_sdu_cloud_grant_api_ResourceRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.TwoFactorStatusResponse" -> return `dk_sdu_cloud_auth_api_TwoFactorStatusResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Status" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_Status_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupAdminsBulkRequest" -> return `dk_sdu_cloud_project_api_LookupAdminsBulkRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.UploadLogoRequest" -> return `dk_sdu_cloud_grant_api_UploadLogoRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderSearchRequest" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderSearchRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.PageV2" -> return `dk_sdu_cloud_PageV2_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.IngressIncludeFlags" -> return `dk_sdu_cloud_app_orchestrator_api_IngressIncludeFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletsRetrieveRecipientResponse" -> return `dk_sdu_cloud_accounting_api_WalletsRetrieveRecipientResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.IsPublicRequest" -> return `dk_sdu_cloud_app_store_api_IsPublicRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProvidersRequestApprovalResponse.RequiresSignature" -> return `dk_sdu_cloud_provider_api_ProvidersRequestApprovalResponse_RequiresSignature_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.ProjectInviteMail" -> return `dk_sdu_cloud_mail_api_Mail_ProjectInviteMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.OutgoingInvite" -> return `dk_sdu_cloud_project_api_OutgoingInvite_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.License" -> return `dk_sdu_cloud_app_orchestrator_api_License_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.NetworkIP" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_NetworkIP_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.RejectInviteRequest" -> return `dk_sdu_cloud_project_api_RejectInviteRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListFavoriteProjectsRequest" -> return `dk_sdu_cloud_project_api_ListFavoriteProjectsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.LongRunningTask.Complete" -> return `dk_sdu_cloud_file_orchestrator_api_LongRunningTask_Complete_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.UserStatusRequest" -> return `dk_sdu_cloud_project_api_UserStatusRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.Product.Storage" -> return `dk_sdu_cloud_accounting_api_Product_Storage_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.StillLowFundsMail" -> return `dk_sdu_cloud_mail_api_Mail_StillLowFundsMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.Integer" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_Integer_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.password.reset.api.PasswordResetRequest" -> return `dk_sdu_cloud_password_reset_api_PasswordResetRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ShellResponse.Data" -> return `dk_sdu_cloud_app_orchestrator_api_ShellResponse_Data_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.OutgoingApplicationsRequest" -> return `dk_sdu_cloud_grant_api_OutgoingApplicationsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ExistsRequest" -> return `dk_sdu_cloud_project_api_ExistsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.DeleteGiftRequest" -> return `dk_sdu_cloud_grant_api_DeleteGiftRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.AclEntity.ProjectGroup" -> return `dk_sdu_cloud_provider_api_AclEntity_ProjectGroup_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.BreakdownChart" -> return `dk_sdu_cloud_accounting_api_BreakdownChart_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.task.api.TaskUpdate" -> return `dk_sdu_cloud_task_api_TaskUpdate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.IsMemberQuery" -> return `dk_sdu_cloud_project_api_IsMemberQuery_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.UserRoleChangeMail" -> return `dk_sdu_cloud_mail_api_Mail_UserRoleChangeMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.GiftWithCriteria" -> return `dk_sdu_cloud_grant_api_GiftWithCriteria_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationWithFavoriteAndTags" -> return `dk_sdu_cloud_app_store_api_ApplicationWithFavoriteAndTags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.Pair" -> return `dk_sdu_cloud_project_api_Pair_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.FetchLogoRequest" -> return `dk_sdu_cloud_app_store_api_FetchLogoRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.IngressSupport" -> return `dk_sdu_cloud_app_orchestrator_api_IngressSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.ChangePasswordWithResetRequest" -> return `dk_sdu_cloud_auth_api_ChangePasswordWithResetRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.UFileSpecification" -> return `dk_sdu_cloud_file_orchestrator_api_UFileSpecification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.LicenseIncludeFlags" -> return `dk_sdu_cloud_app_orchestrator_api_LicenseIncludeFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.task.api.Progress" -> return `dk_sdu_cloud_task_api_Progress_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.SimpleDuration" -> return `dk_sdu_cloud_app_store_api_SimpleDuration_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.CreateGroupRequest" -> return `dk_sdu_cloud_project_api_CreateGroupRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.ShareSupport" -> return `dk_sdu_cloud_file_orchestrator_api_ShareSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantApplicationStatusChangedToAdmin" -> return `dk_sdu_cloud_mail_api_Mail_GrantApplicationStatusChangedToAdmin_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListGroupMembersRequest" -> return `dk_sdu_cloud_project_api_ListGroupMembersRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataRetrieveAllRequest" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataRetrieveAllRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.IsMemberResponse" -> return `dk_sdu_cloud_project_api_IsMemberResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.FetchDescriptionResponse" -> return `dk_sdu_cloud_grant_api_FetchDescriptionResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.PublicKeyAndRefreshToken" -> return `dk_sdu_cloud_auth_api_PublicKeyAndRefreshToken_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.EmailSettings" -> return `dk_sdu_cloud_mail_api_EmailSettings_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.CpuAndMemory" -> return `dk_sdu_cloud_app_orchestrator_api_CpuAndMemory_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.InviteRequest" -> return `dk_sdu_cloud_project_api_InviteRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.Text" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_Text_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.RequestOneTimeToken" -> return `dk_sdu_cloud_auth_api_RequestOneTimeToken_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AuthProvidersRetrievePublicKeyResponse" -> return `dk_sdu_cloud_auth_api_AuthProvidersRetrievePublicKeyResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AcceptSLARequest" -> return `dk_sdu_cloud_auth_api_AcceptSLARequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.UpdateAllocationRequestItem" -> return `dk_sdu_cloud_accounting_api_UpdateAllocationRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ExportedParametersRequest" -> return `dk_sdu_cloud_app_orchestrator_api_ExportedParametersRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletsBrowseSubAllocationsRequest" -> return `dk_sdu_cloud_accounting_api_WalletsBrowseSubAllocationsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsProviderFollowResponse" -> return `dk_sdu_cloud_app_orchestrator_api_JobsProviderFollowResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.EditApplicationRequest" -> return `dk_sdu_cloud_grant_api_EditApplicationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.UserCriteria.Anyone" -> return `dk_sdu_cloud_grant_api_UserCriteria_Anyone_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FSCollectionSupport" -> return `dk_sdu_cloud_file_orchestrator_api_FSCollectionSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ExportedParameters" -> return `dk_sdu_cloud_app_orchestrator_api_ExportedParameters_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.SubAllocation" -> return `dk_sdu_cloud_accounting_api_SubAllocation_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileCollectionsProviderRenameRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FileCollectionsProviderRenameRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ViewMemberInProjectRequest" -> return `dk_sdu_cloud_project_api_ViewMemberInProjectRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ProjectGroup" -> return `dk_sdu_cloud_project_api_ProjectGroup_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.TransferApplicationRequest" -> return `dk_sdu_cloud_grant_api_TransferApplicationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesCreateUploadRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesCreateUploadRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.FindByLongId" -> return `dk_sdu_cloud_FindByLongId_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.CommentOnApplicationRequest" -> return `dk_sdu_cloud_grant_api_CommentOnApplicationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIPSupport.Firewall" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIPSupport_Firewall_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.Create2FACredentialsResponse" -> return `dk_sdu_cloud_auth_api_Create2FACredentialsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ReadRequestSettingsRequest" -> return `dk_sdu_cloud_grant_api_ReadRequestSettingsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.LineChart.Point" -> return `dk_sdu_cloud_accounting_api_LineChart_Point_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplate" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupUsersResponse" -> return `dk_sdu_cloud_auth_api_LookupUsersResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.CreateTagsRequest" -> return `dk_sdu_cloud_app_store_api_CreateTagsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.FindLatestByToolRequest" -> return `dk_sdu_cloud_app_store_api_FindLatestByToolRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIPSpecification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.RenameProjectRequest" -> return `dk_sdu_cloud_project_api_RenameProjectRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.RemoveGroupMemberRequest" -> return `dk_sdu_cloud_project_api_RemoveGroupMemberRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesCreateDownloadRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesCreateDownloadRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobOutput" -> return `dk_sdu_cloud_app_orchestrator_api_JobOutput_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AuthProvidersRegisterRequestItem" -> return `dk_sdu_cloud_auth_api_AuthProvidersRegisterRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.ResourceBrowseRequest" -> return `dk_sdu_cloud_accounting_api_providers_ResourceBrowseRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.UploadApplicationLogoRequest" -> return `dk_sdu_cloud_app_store_api_UploadApplicationLogoRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.TransferToWalletRequestItem" -> return `dk_sdu_cloud_accounting_api_TransferToWalletRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AuthProvidersGenerateKeyPairResponse" -> return `dk_sdu_cloud_auth_api_AuthProvidersGenerateKeyPairResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationMetadata" -> return `dk_sdu_cloud_app_store_api_ApplicationMetadata_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIPStatus" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIPStatus_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderEmptyTrashRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderEmptyTrashRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.IngressUpdate" -> return `dk_sdu_cloud_app_orchestrator_api_IngressUpdate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.AllowsRenamingResponse" -> return `dk_sdu_cloud_project_api_AllowsRenamingResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.Product.Synchronization" -> return `dk_sdu_cloud_accounting_api_Product_Synchronization_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderRetrieveRequest" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderRetrieveRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupEmailRequest" -> return `dk_sdu_cloud_auth_api_LookupEmailRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ArchiveBulkRequest" -> return `dk_sdu_cloud_project_api_ArchiveBulkRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupPrincipalInvestigatorResponse" -> return `dk_sdu_cloud_project_api_LookupPrincipalInvestigatorResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProviderStatus" -> return `dk_sdu_cloud_provider_api_ProviderStatus_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.PortRangeAndProto" -> return `dk_sdu_cloud_app_orchestrator_api_PortRangeAndProto_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.CreateProjectRequest" -> return `dk_sdu_cloud_project_api_CreateProjectRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobStatus" -> return `dk_sdu_cloud_app_orchestrator_api_JobStatus_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupEmailResponse" -> return `dk_sdu_cloud_auth_api_LookupEmailResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.Spec" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_Spec_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.Wallet" -> return `dk_sdu_cloud_accounting_api_Wallet_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.NameAndVersion" -> return `dk_sdu_cloud_app_store_api_NameAndVersion_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.OpenSession.Shell" -> return `dk_sdu_cloud_app_orchestrator_api_OpenSession_Shell_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProvidersRenewRefreshTokenRequestItem" -> return `dk_sdu_cloud_provider_api_ProvidersRenewRefreshTokenRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ExampleResourceSupport" -> return `dk_sdu_cloud_provider_api_ExampleResourceSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupByIdBulkRequest" -> return `dk_sdu_cloud_project_api_LookupByIdBulkRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsExtendRequestItem" -> return `dk_sdu_cloud_app_orchestrator_api_JobsExtendRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.PieChart.Point" -> return `dk_sdu_cloud_accounting_api_PieChart_Point_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.RetrieveEmailSettingsRequest" -> return `dk_sdu_cloud_mail_api_RetrieveEmailSettingsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.news.api.UpdatePostRequest" -> return `dk_sdu_cloud_news_api_UpdatePostRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.FetchDescriptionRequest" -> return `dk_sdu_cloud_grant_api_FetchDescriptionRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderBrowseRequest" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderBrowseRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.Text" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_Text_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataBrowseRequest" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataBrowseRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ShellRequest.Input" -> return `dk_sdu_cloud_app_orchestrator_api_ShellRequest_Input_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.news.api.NewsPost" -> return `dk_sdu_cloud_news_api_NewsPost_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.task.api.Speed" -> return `dk_sdu_cloud_task_api_Speed_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantApplicationUpdatedMail" -> return `dk_sdu_cloud_mail_api_Mail_GrantApplicationUpdatedMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.task.api.PostStatusRequest" -> return `dk_sdu_cloud_task_api_PostStatusRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ViewApplicationRequest" -> return `dk_sdu_cloud_grant_api_ViewApplicationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.TransferPiRoleRequest" -> return `dk_sdu_cloud_project_api_TransferPiRoleRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.task.api.ListRequest" -> return `dk_sdu_cloud_task_api_ListRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.GrantsRetrieveProductsResponse" -> return `dk_sdu_cloud_grant_api_GrantsRetrieveProductsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.Share.Status" -> return `dk_sdu_cloud_file_orchestrator_api_Share_Status_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.SetPublicRequest" -> return `dk_sdu_cloud_app_store_api_SetPublicRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.SupportByProvider" -> return `dk_sdu_cloud_accounting_api_providers_SupportByProvider_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProviderSpecification" -> return `dk_sdu_cloud_provider_api_ProviderSpecification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileCollectionsRenameRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FileCollectionsRenameRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.GrantsRetrieveProductsRequest" -> return `dk_sdu_cloud_grant_api_GrantsRetrieveProductsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.UploadTemplatesRequest" -> return `dk_sdu_cloud_grant_api_UploadTemplatesRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.LicenseSpecification" -> return `dk_sdu_cloud_app_orchestrator_api_LicenseSpecification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.Enumeration" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_Enumeration_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.FavoriteRequest" -> return `dk_sdu_cloud_app_store_api_FavoriteRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.Share.Spec" -> return `dk_sdu_cloud_file_orchestrator_api_Share_Spec_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.TextArea" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_TextArea_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.SendRequestItem" -> return `dk_sdu_cloud_mail_api_SendRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.AclEntity.User" -> return `dk_sdu_cloud_provider_api_AclEntity_User_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.task.api.Task" -> return `dk_sdu_cloud_task_api_Task_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.UserStatusInProject" -> return `dk_sdu_cloud_project_api_UserStatusInProject_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.Peer" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_Peer_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.NormalizedToolDescription" -> return `dk_sdu_cloud_app_store_api_NormalizedToolDescription_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderTrashRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderTrashRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.CreateSingleUserRequest" -> return `dk_sdu_cloud_auth_api_CreateSingleUserRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.ServiceAgreementText" -> return `dk_sdu_cloud_auth_api_ServiceAgreementText_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.WebDescription" -> return `dk_sdu_cloud_app_store_api_WebDescription_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.RootDepositRequestItem" -> return `dk_sdu_cloud_accounting_api_RootDepositRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FSProductStatsSupport" -> return `dk_sdu_cloud_file_orchestrator_api_FSProductStatsSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.Ingress" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_Ingress_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AuthProvidersRefreshAsProviderRequestItem" -> return `dk_sdu_cloud_auth_api_AuthProvidersRefreshAsProviderRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.PaginationRequest" -> return `dk_sdu_cloud_PaginationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AnswerChallengeRequest" -> return `dk_sdu_cloud_auth_api_AnswerChallengeRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataHistory" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataHistory_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.CommonErrorMessage" -> return `dk_sdu_cloud_CommonErrorMessage_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace.Status" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_Status_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.FindByStringId" -> return `dk_sdu_cloud_FindByStringId_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.Ingress" -> return `dk_sdu_cloud_app_orchestrator_api_Ingress_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.FetchDataManagementPlanResponse" -> return `dk_sdu_cloud_project_api_FetchDataManagementPlanResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateDownloadRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderCreateDownloadRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.IsPublicResponse" -> return `dk_sdu_cloud_app_store_api_IsPublicResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ComputeSupport.VirtualMachine" -> return `dk_sdu_cloud_app_orchestrator_api_ComputeSupport_VirtualMachine_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ToolReference" -> return `dk_sdu_cloud_app_store_api_ToolReference_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.CloseApplicationRequest" -> return `dk_sdu_cloud_grant_api_CloseApplicationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.DeleteCommentRequest" -> return `dk_sdu_cloud_grant_api_DeleteCommentRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.Job" -> return `dk_sdu_cloud_app_orchestrator_api_Job_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupAdminsResponse" -> return `dk_sdu_cloud_project_api_LookupAdminsResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.TextArea" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_TextArea_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.Ingress" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_Ingress_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.UserStatusResponse" -> return `dk_sdu_cloud_project_api_UserStatusResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderCreateFolderRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderCreateFolderRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ViewMemberInProjectResponse" -> return `dk_sdu_cloud_project_api_ViewMemberInProjectResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.SharesUpdatePermissionsRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_SharesUpdatePermissionsRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.ResourceSearchRequest" -> return `dk_sdu_cloud_accounting_api_providers_ResourceSearchRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.FloatingPoint" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_FloatingPoint_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.GetUserInfoResponse" -> return `dk_sdu_cloud_auth_api_GetUserInfoResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.Product.Compute" -> return `dk_sdu_cloud_accounting_api_Product_Compute_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ShellRequest.Initialize" -> return `dk_sdu_cloud_app_orchestrator_api_ShellRequest_Initialize_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProvidersRequestApprovalRequest.Sign" -> return `dk_sdu_cloud_provider_api_ProvidersRequestApprovalRequest_Sign_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ReadTemplatesRequest" -> return `dk_sdu_cloud_grant_api_ReadTemplatesRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ACLEntryRequest" -> return `dk_sdu_cloud_app_store_api_ACLEntryRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListProjectsRequest" -> return `dk_sdu_cloud_project_api_ListProjectsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AuthProvidersRegisterResponseItem" -> return `dk_sdu_cloud_auth_api_AuthProvidersRegisterResponseItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ClearLogoRequest" -> return `dk_sdu_cloud_app_store_api_ClearLogoRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.news.api.GetPostByIdRequest" -> return `dk_sdu_cloud_news_api_GetPostByIdRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.UserLeftMail" -> return `dk_sdu_cloud_mail_api_Mail_UserLeftMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ArchiveRequest" -> return `dk_sdu_cloud_project_api_ArchiveRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListOutgoingInvitesRequest" -> return `dk_sdu_cloud_project_api_ListOutgoingInvitesRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.NewGrantApplicationMail" -> return `dk_sdu_cloud_mail_api_Mail_NewGrantApplicationMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobsOpenInteractiveSessionRequestItem" -> return `dk_sdu_cloud_app_orchestrator_api_JobsOpenInteractiveSessionRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.VisualizationRetrieveUsageResponse" -> return `dk_sdu_cloud_accounting_api_VisualizationRetrieveUsageResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupUIDResponse" -> return `dk_sdu_cloud_auth_api_LookupUIDResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ToggleRenamingRequest" -> return `dk_sdu_cloud_project_api_ToggleRenamingRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.LicenseStatus" -> return `dk_sdu_cloud_app_orchestrator_api_LicenseStatus_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ListAclRequest" -> return `dk_sdu_cloud_app_store_api_ListAclRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobIncludeFlags" -> return `dk_sdu_cloud_app_orchestrator_api_JobIncludeFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataRetrieveAllResponse" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataRetrieveAllResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.DetailedEntityWithPermission" -> return `dk_sdu_cloud_app_store_api_DetailedEntityWithPermission_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.ProductsBrowseRequest" -> return `dk_sdu_cloud_accounting_api_ProductsBrowseRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListAllGroupMembersRequest" -> return `dk_sdu_cloud_project_api_ListAllGroupMembersRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AccessToken" -> return `dk_sdu_cloud_auth_api_AccessToken_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.ServicePrincipal" -> return `dk_sdu_cloud_auth_api_ServicePrincipal_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationParameter.Integer" -> return `dk_sdu_cloud_app_store_api_ApplicationParameter_Integer_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.ResetPasswordMail" -> return `dk_sdu_cloud_mail_api_Mail_ResetPasswordMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIPSpecification.Firewall" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIPSpecification_Firewall_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.RefreshToken" -> return `dk_sdu_cloud_auth_api_RefreshToken_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.notification.api.MarkResponse" -> return `dk_sdu_cloud_notification_api_MarkResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProvidersApproveRequest" -> return `dk_sdu_cloud_provider_api_ProvidersApproveRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupUsersRequest" -> return `dk_sdu_cloud_auth_api_LookupUsersRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.ProductReference" -> return `dk_sdu_cloud_accounting_api_ProductReference_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ShellRequest.Resize" -> return `dk_sdu_cloud_app_orchestrator_api_ShellRequest_Resize_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ApplicationWithComments" -> return `dk_sdu_cloud_grant_api_ApplicationWithComments_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.UserRemovedMailToUser" -> return `dk_sdu_cloud_mail_api_Mail_UserRemovedMailToUser_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListIngoingInvitesRequest" -> return `dk_sdu_cloud_project_api_ListIngoingInvitesRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ComputeSupport" -> return `dk_sdu_cloud_app_orchestrator_api_ComputeSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.BrowseProjectsRequest" -> return `dk_sdu_cloud_grant_api_BrowseProjectsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.UserLookup" -> return `dk_sdu_cloud_auth_api_UserLookup_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesProviderCopyRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesProviderCopyRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.task.api.CreateRequest" -> return `dk_sdu_cloud_task_api_CreateRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.UpdateDataManagementPlanRequest" -> return `dk_sdu_cloud_project_api_UpdateDataManagementPlanRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.favorite.api.ToggleFavoriteRequest" -> return `dk_sdu_cloud_project_favorite_api_ToggleFavoriteRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.FindByNameAndPagination" -> return `dk_sdu_cloud_app_store_api_FindByNameAndPagination_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.notification.api.ListNotificationRequest" -> return `dk_sdu_cloud_notification_api_ListNotificationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileCollection.Spec" -> return `dk_sdu_cloud_file_orchestrator_api_FileCollection_Spec_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.GrantApplicationApproveMailToAdmins" -> return `dk_sdu_cloud_mail_api_Mail_GrantApplicationApproveMailToAdmins_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.news.api.DeleteNewsPostRequest" -> return `dk_sdu_cloud_news_api_DeleteNewsPostRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.SetEnabledStatusRequest" -> return `dk_sdu_cloud_grant_api_SetEnabledStatusRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.LookupUserWithEmailRequest" -> return `dk_sdu_cloud_auth_api_LookupUserWithEmailRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupProjectAndGroupRequest" -> return `dk_sdu_cloud_project_api_LookupProjectAndGroupRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ViewGroupRequest" -> return `dk_sdu_cloud_project_api_ViewGroupRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.TagSearchRequest" -> return `dk_sdu_cloud_app_store_api_TagSearchRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.HasPermissionRequest" -> return `dk_sdu_cloud_app_store_api_HasPermissionRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespace" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespace_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobSpecification" -> return `dk_sdu_cloud_app_orchestrator_api_JobSpecification_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletsSearchSubAllocationsRequest" -> return `dk_sdu_cloud_accounting_api_WalletsSearchSubAllocationsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.UpdatedAcl" -> return `dk_sdu_cloud_provider_api_UpdatedAcl_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDeleteRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDeleteRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.NetworkIP" -> return `dk_sdu_cloud_app_orchestrator_api_NetworkIP_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataAddRequestItem" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataAddRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationSummaryWithFavorite" -> return `dk_sdu_cloud_app_store_api_ApplicationSummaryWithFavorite_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.slack.api.Alert" -> return `dk_sdu_cloud_slack_api_Alert_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.LineChart.Line" -> return `dk_sdu_cloud_accounting_api_LineChart_Line_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataDocument.ApprovalStatus.NotRequired" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataDocument_ApprovalStatus_NotRequired_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.DepositToWalletRequestItem" -> return `dk_sdu_cloud_accounting_api_DepositToWalletRequestItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.support.api.CreateTicketRequest" -> return `dk_sdu_cloud_support_api_CreateTicketRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.TokenExtensionRequest" -> return `dk_sdu_cloud_auth_api_TokenExtensionRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.CreateApplication" -> return `dk_sdu_cloud_grant_api_CreateApplication_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ContainerDescription" -> return `dk_sdu_cloud_app_store_api_ContainerDescription_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.Tool" -> return `dk_sdu_cloud_app_store_api_Tool_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.UFileStatus" -> return `dk_sdu_cloud_file_orchestrator_api_UFileStatus_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.VerificationReminderMail" -> return `dk_sdu_cloud_mail_api_Mail_VerificationReminderMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.OptionalAuthenticationTokens" -> return `dk_sdu_cloud_auth_api_OptionalAuthenticationTokens_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.LookupByTitleRequest" -> return `dk_sdu_cloud_project_api_LookupByTitleRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ClaimGiftRequest" -> return `dk_sdu_cloud_grant_api_ClaimGiftRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.VisualizationRetrieveUsageRequest" -> return `dk_sdu_cloud_accounting_api_VisualizationRetrieveUsageRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletOwner.Project" -> return `dk_sdu_cloud_accounting_api_WalletOwner_Project_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.FindApplicationAndOptionalDependencies" -> return `dk_sdu_cloud_app_store_api_FindApplicationAndOptionalDependencies_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.Network" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_Network_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.EditReferenceIdRequest" -> return `dk_sdu_cloud_grant_api_EditReferenceIdRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.providers.ResourceInitializationRequest" -> return `dk_sdu_cloud_accounting_api_providers_ResourceInitializationRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.AppParameterValue.Bool" -> return `dk_sdu_cloud_app_store_api_AppParameterValue_Bool_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.ShellResponse.Acknowledged" -> return `dk_sdu_cloud_app_orchestrator_api_ShellResponse_Acknowledged_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.AuthenticationTokens" -> return `dk_sdu_cloud_auth_api_AuthenticationTokens_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.JobBinding" -> return `dk_sdu_cloud_app_orchestrator_api_JobBinding_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.Page" -> return `dk_sdu_cloud_Page_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListAllGroupIdsAndTitlesResponse" -> return `dk_sdu_cloud_project_api_ListAllGroupIdsAndTitlesResponse_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.auth.api.ProviderPrincipal" -> return `dk_sdu_cloud_auth_api_ProviderPrincipal_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.PieChart" -> return `dk_sdu_cloud_accounting_api_PieChart_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.BooleanFlagParameter" -> return `dk_sdu_cloud_app_store_api_BooleanFlagParameter_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.orchestrator.api.LicenseUpdate" -> return `dk_sdu_cloud_app_orchestrator_api_LicenseUpdate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.NewCommentOnApplicationMail" -> return `dk_sdu_cloud_mail_api_Mail_NewCommentOnApplicationMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.FindBySupportedFileExtension" -> return `dk_sdu_cloud_app_store_api_FindBySupportedFileExtension_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.accounting.api.WalletsRetrieveRecipientRequest" -> return `dk_sdu_cloud_accounting_api_WalletsRetrieveRecipientRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ProviderIncludeFlags" -> return `dk_sdu_cloud_provider_api_ProviderIncludeFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FilesCreateDownloadResponseItem" -> return `dk_sdu_cloud_file_orchestrator_api_FilesCreateDownloadResponseItem_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.UFileUpdate" -> return `dk_sdu_cloud_file_orchestrator_api_UFileUpdate_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.provider.api.ResourceAclEntry" -> return `dk_sdu_cloud_provider_api_ResourceAclEntry_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.MemberInProject" -> return `dk_sdu_cloud_project_api_MemberInProject_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.Application" -> return `dk_sdu_cloud_grant_api_Application_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.mail.api.Mail.UserRemovedMail" -> return `dk_sdu_cloud_mail_api_Mail_UserRemovedMail_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.project.api.ListGroupsWithSummaryRequest" -> return `dk_sdu_cloud_project_api_ListGroupsWithSummaryRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FSFileSupport" -> return `dk_sdu_cloud_file_orchestrator_api_FSFileSupport_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.AutomaticApprovalSettings" -> return `dk_sdu_cloud_grant_api_AutomaticApprovalSettings_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.GrantRecipient.NewProject" -> return `dk_sdu_cloud_grant_api_GrantRecipient_NewProject_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.app.store.api.ApplicationInvocationDescription" -> return `dk_sdu_cloud_app_store_api_ApplicationInvocationDescription_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.IngoingApplicationsRequest" -> return `dk_sdu_cloud_grant_api_IngoingApplicationsRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.file.orchestrator.api.FileMetadataTemplateNamespaceFlags" -> return `dk_sdu_cloud_file_orchestrator_api_FileMetadataTemplateNamespaceFlags_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.calls.BulkRequest" -> return `dk_sdu_cloud_calls_BulkRequest_deserialize`(parser, hasStartedObject) as T
"dk.sdu.cloud.grant.api.ProjectApplicationSettings" -> return `dk_sdu_cloud_grant_api_ProjectApplicationSettings_deserialize`(parser, hasStartedObject) as T
else -> throw IllegalStateException("Unknown type: ${T::class.qualifiedName}")
}
}
